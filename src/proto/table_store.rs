// This file is generated by rust-protobuf 2.25.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `table_store.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_0;

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    code: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Error {
    fn default() -> &'a Error {
        <Error as ::protobuf::Message>::default_instance()
    }
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // required string code = 1;


    pub fn get_code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code.set_default();
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        if self.code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.code)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.code.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "code",
                |m: &Error| { &m.code },
                |m: &mut Error| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Error| { &m.message },
                |m: &mut Error| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Error>(
                "Error",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Error {
        static instance: ::protobuf::rt::LazyV2<Error> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Error::new)
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.code.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrimaryKeySchema {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<PrimaryKeyType>,
    option: ::std::option::Option<PrimaryKeyOption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrimaryKeySchema {
    fn default() -> &'a PrimaryKeySchema {
        <PrimaryKeySchema as ::protobuf::Message>::default_instance()
    }
}

impl PrimaryKeySchema {
    pub fn new() -> PrimaryKeySchema {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .proto.PrimaryKeyType type = 2;


    pub fn get_field_type(&self) -> PrimaryKeyType {
        self.field_type.unwrap_or(PrimaryKeyType::INTEGER)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PrimaryKeyType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional .proto.PrimaryKeyOption option = 3;


    pub fn get_option(&self) -> PrimaryKeyOption {
        self.option.unwrap_or(PrimaryKeyOption::AUTO_INCREMENT)
    }
    pub fn clear_option(&mut self) {
        self.option = ::std::option::Option::None;
    }

    pub fn has_option(&self) -> bool {
        self.option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: PrimaryKeyOption) {
        self.option = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PrimaryKeySchema {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.option, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.option {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.option {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrimaryKeySchema {
        PrimaryKeySchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PrimaryKeySchema| { &m.name },
                |m: &mut PrimaryKeySchema| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PrimaryKeyType>>(
                "type",
                |m: &PrimaryKeySchema| { &m.field_type },
                |m: &mut PrimaryKeySchema| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PrimaryKeyOption>>(
                "option",
                |m: &PrimaryKeySchema| { &m.option },
                |m: &mut PrimaryKeySchema| { &mut m.option },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrimaryKeySchema>(
                "PrimaryKeySchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrimaryKeySchema {
        static instance: ::protobuf::rt::LazyV2<PrimaryKeySchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrimaryKeySchema::new)
    }
}

impl ::protobuf::Clear for PrimaryKeySchema {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = ::std::option::Option::None;
        self.option = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrimaryKeySchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimaryKeySchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartitionRange {
    // message fields
    begin: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    end: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PartitionRange {
    fn default() -> &'a PartitionRange {
        <PartitionRange as ::protobuf::Message>::default_instance()
    }
}

impl PartitionRange {
    pub fn new() -> PartitionRange {
        ::std::default::Default::default()
    }

    // required bytes begin = 1;


    pub fn get_begin(&self) -> &[u8] {
        match self.begin.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_begin(&mut self) {
        self.begin.clear();
    }

    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: ::std::vec::Vec<u8>) {
        self.begin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_begin(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.begin.is_none() {
            self.begin.set_default();
        }
        self.begin.as_mut().unwrap()
    }

    // Take field
    pub fn take_begin(&mut self) -> ::std::vec::Vec<u8> {
        self.begin.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes end = 2;


    pub fn get_end(&self) -> &[u8] {
        match self.end.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_end(&mut self) {
        self.end.clear();
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: ::std::vec::Vec<u8>) {
        self.end = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.end.is_none() {
            self.end.set_default();
        }
        self.end.as_mut().unwrap()
    }

    // Take field
    pub fn take_end(&mut self) -> ::std::vec::Vec<u8> {
        self.end.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PartitionRange {
    fn is_initialized(&self) -> bool {
        if self.begin.is_none() {
            return false;
        }
        if self.end.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.begin)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.end)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.begin.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.end.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.begin.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.end.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartitionRange {
        PartitionRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "begin",
                |m: &PartitionRange| { &m.begin },
                |m: &mut PartitionRange| { &mut m.begin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "end",
                |m: &PartitionRange| { &m.end },
                |m: &mut PartitionRange| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PartitionRange>(
                "PartitionRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PartitionRange {
        static instance: ::protobuf::rt::LazyV2<PartitionRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PartitionRange::new)
    }
}

impl ::protobuf::Clear for PartitionRange {
    fn clear(&mut self) {
        self.begin.clear();
        self.end.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartitionRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableOptions {
    // message fields
    time_to_live: ::std::option::Option<i32>,
    max_versions: ::std::option::Option<i32>,
    bloom_filter_type: ::std::option::Option<BloomFilterType>,
    block_size: ::std::option::Option<i32>,
    deviation_cell_version_in_sec: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableOptions {
    fn default() -> &'a TableOptions {
        <TableOptions as ::protobuf::Message>::default_instance()
    }
}

impl TableOptions {
    pub fn new() -> TableOptions {
        ::std::default::Default::default()
    }

    // optional int32 time_to_live = 1;


    pub fn get_time_to_live(&self) -> i32 {
        self.time_to_live.unwrap_or(0)
    }
    pub fn clear_time_to_live(&mut self) {
        self.time_to_live = ::std::option::Option::None;
    }

    pub fn has_time_to_live(&self) -> bool {
        self.time_to_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_live(&mut self, v: i32) {
        self.time_to_live = ::std::option::Option::Some(v);
    }

    // optional int32 max_versions = 2;


    pub fn get_max_versions(&self) -> i32 {
        self.max_versions.unwrap_or(0)
    }
    pub fn clear_max_versions(&mut self) {
        self.max_versions = ::std::option::Option::None;
    }

    pub fn has_max_versions(&self) -> bool {
        self.max_versions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_versions(&mut self, v: i32) {
        self.max_versions = ::std::option::Option::Some(v);
    }

    // optional .proto.BloomFilterType bloom_filter_type = 3;


    pub fn get_bloom_filter_type(&self) -> BloomFilterType {
        self.bloom_filter_type.unwrap_or(BloomFilterType::NONE)
    }
    pub fn clear_bloom_filter_type(&mut self) {
        self.bloom_filter_type = ::std::option::Option::None;
    }

    pub fn has_bloom_filter_type(&self) -> bool {
        self.bloom_filter_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bloom_filter_type(&mut self, v: BloomFilterType) {
        self.bloom_filter_type = ::std::option::Option::Some(v);
    }

    // optional int32 block_size = 4;


    pub fn get_block_size(&self) -> i32 {
        self.block_size.unwrap_or(0)
    }
    pub fn clear_block_size(&mut self) {
        self.block_size = ::std::option::Option::None;
    }

    pub fn has_block_size(&self) -> bool {
        self.block_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block_size(&mut self, v: i32) {
        self.block_size = ::std::option::Option::Some(v);
    }

    // optional int64 deviation_cell_version_in_sec = 5;


    pub fn get_deviation_cell_version_in_sec(&self) -> i64 {
        self.deviation_cell_version_in_sec.unwrap_or(0)
    }
    pub fn clear_deviation_cell_version_in_sec(&mut self) {
        self.deviation_cell_version_in_sec = ::std::option::Option::None;
    }

    pub fn has_deviation_cell_version_in_sec(&self) -> bool {
        self.deviation_cell_version_in_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deviation_cell_version_in_sec(&mut self, v: i64) {
        self.deviation_cell_version_in_sec = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TableOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time_to_live = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_versions = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.bloom_filter_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.block_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deviation_cell_version_in_sec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.time_to_live {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_versions {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.bloom_filter_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.block_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deviation_cell_version_in_sec {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.time_to_live {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.max_versions {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.bloom_filter_type {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.block_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.deviation_cell_version_in_sec {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableOptions {
        TableOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "time_to_live",
                |m: &TableOptions| { &m.time_to_live },
                |m: &mut TableOptions| { &mut m.time_to_live },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_versions",
                |m: &TableOptions| { &m.max_versions },
                |m: &mut TableOptions| { &mut m.max_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BloomFilterType>>(
                "bloom_filter_type",
                |m: &TableOptions| { &m.bloom_filter_type },
                |m: &mut TableOptions| { &mut m.bloom_filter_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "block_size",
                |m: &TableOptions| { &m.block_size },
                |m: &mut TableOptions| { &mut m.block_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "deviation_cell_version_in_sec",
                |m: &TableOptions| { &m.deviation_cell_version_in_sec },
                |m: &mut TableOptions| { &mut m.deviation_cell_version_in_sec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableOptions>(
                "TableOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableOptions {
        static instance: ::protobuf::rt::LazyV2<TableOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableOptions::new)
    }
}

impl ::protobuf::Clear for TableOptions {
    fn clear(&mut self) {
        self.time_to_live = ::std::option::Option::None;
        self.max_versions = ::std::option::Option::None;
        self.bloom_filter_type = ::std::option::Option::None;
        self.block_size = ::std::option::Option::None;
        self.deviation_cell_version_in_sec = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableMeta {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub primary_key: ::protobuf::RepeatedField<PrimaryKeySchema>,
    pub defined_column: ::protobuf::RepeatedField<DefinedColumnSchema>,
    pub index_meta: ::protobuf::RepeatedField<IndexMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableMeta {
    fn default() -> &'a TableMeta {
        <TableMeta as ::protobuf::Message>::default_instance()
    }
}

impl TableMeta {
    pub fn new() -> TableMeta {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .proto.PrimaryKeySchema primary_key = 2;


    pub fn get_primary_key(&self) -> &[PrimaryKeySchema] {
        &self.primary_key
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: ::protobuf::RepeatedField<PrimaryKeySchema>) {
        self.primary_key = v;
    }

    // Mutable pointer to the field.
    pub fn mut_primary_key(&mut self) -> &mut ::protobuf::RepeatedField<PrimaryKeySchema> {
        &mut self.primary_key
    }

    // Take field
    pub fn take_primary_key(&mut self) -> ::protobuf::RepeatedField<PrimaryKeySchema> {
        ::std::mem::replace(&mut self.primary_key, ::protobuf::RepeatedField::new())
    }

    // repeated .proto.DefinedColumnSchema defined_column = 3;


    pub fn get_defined_column(&self) -> &[DefinedColumnSchema] {
        &self.defined_column
    }
    pub fn clear_defined_column(&mut self) {
        self.defined_column.clear();
    }

    // Param is passed by value, moved
    pub fn set_defined_column(&mut self, v: ::protobuf::RepeatedField<DefinedColumnSchema>) {
        self.defined_column = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defined_column(&mut self) -> &mut ::protobuf::RepeatedField<DefinedColumnSchema> {
        &mut self.defined_column
    }

    // Take field
    pub fn take_defined_column(&mut self) -> ::protobuf::RepeatedField<DefinedColumnSchema> {
        ::std::mem::replace(&mut self.defined_column, ::protobuf::RepeatedField::new())
    }

    // repeated .proto.IndexMeta index_meta = 4;


    pub fn get_index_meta(&self) -> &[IndexMeta] {
        &self.index_meta
    }
    pub fn clear_index_meta(&mut self) {
        self.index_meta.clear();
    }

    // Param is passed by value, moved
    pub fn set_index_meta(&mut self, v: ::protobuf::RepeatedField<IndexMeta>) {
        self.index_meta = v;
    }

    // Mutable pointer to the field.
    pub fn mut_index_meta(&mut self) -> &mut ::protobuf::RepeatedField<IndexMeta> {
        &mut self.index_meta
    }

    // Take field
    pub fn take_index_meta(&mut self) -> ::protobuf::RepeatedField<IndexMeta> {
        ::std::mem::replace(&mut self.index_meta, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TableMeta {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        for v in &self.primary_key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.defined_column {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.primary_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.defined_column)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.index_meta)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.primary_key {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.defined_column {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.index_meta {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.primary_key {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.defined_column {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.index_meta {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableMeta {
        TableMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &TableMeta| { &m.table_name },
                |m: &mut TableMeta| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrimaryKeySchema>>(
                "primary_key",
                |m: &TableMeta| { &m.primary_key },
                |m: &mut TableMeta| { &mut m.primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefinedColumnSchema>>(
                "defined_column",
                |m: &TableMeta| { &m.defined_column },
                |m: &mut TableMeta| { &mut m.defined_column },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IndexMeta>>(
                "index_meta",
                |m: &TableMeta| { &m.index_meta },
                |m: &mut TableMeta| { &mut m.index_meta },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableMeta>(
                "TableMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableMeta {
        static instance: ::protobuf::rt::LazyV2<TableMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableMeta::new)
    }
}

impl ::protobuf::Clear for TableMeta {
    fn clear(&mut self) {
        self.table_name.clear();
        self.primary_key.clear();
        self.defined_column.clear();
        self.index_meta.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Condition {
    // message fields
    row_existence: ::std::option::Option<RowExistenceExpectation>,
    column_condition: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Condition {
    fn default() -> &'a Condition {
        <Condition as ::protobuf::Message>::default_instance()
    }
}

impl Condition {
    pub fn new() -> Condition {
        ::std::default::Default::default()
    }

    // required .proto.RowExistenceExpectation row_existence = 1;


    pub fn get_row_existence(&self) -> RowExistenceExpectation {
        self.row_existence.unwrap_or(RowExistenceExpectation::IGNORE)
    }
    pub fn clear_row_existence(&mut self) {
        self.row_existence = ::std::option::Option::None;
    }

    pub fn has_row_existence(&self) -> bool {
        self.row_existence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row_existence(&mut self, v: RowExistenceExpectation) {
        self.row_existence = ::std::option::Option::Some(v);
    }

    // optional bytes column_condition = 2;


    pub fn get_column_condition(&self) -> &[u8] {
        match self.column_condition.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_column_condition(&mut self) {
        self.column_condition.clear();
    }

    pub fn has_column_condition(&self) -> bool {
        self.column_condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_column_condition(&mut self, v: ::std::vec::Vec<u8>) {
        self.column_condition = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_condition(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.column_condition.is_none() {
            self.column_condition.set_default();
        }
        self.column_condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_column_condition(&mut self) -> ::std::vec::Vec<u8> {
        self.column_condition.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Condition {
    fn is_initialized(&self) -> bool {
        if self.row_existence.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.row_existence, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.column_condition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.row_existence {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.column_condition.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.row_existence {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.column_condition.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Condition {
        Condition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RowExistenceExpectation>>(
                "row_existence",
                |m: &Condition| { &m.row_existence },
                |m: &mut Condition| { &mut m.row_existence },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "column_condition",
                |m: &Condition| { &m.column_condition },
                |m: &mut Condition| { &mut m.column_condition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Condition>(
                "Condition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Condition {
        static instance: ::protobuf::rt::LazyV2<Condition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Condition::new)
    }
}

impl ::protobuf::Clear for Condition {
    fn clear(&mut self) {
        self.row_existence = ::std::option::Option::None;
        self.column_condition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Condition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Condition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CapacityUnit {
    // message fields
    read: ::std::option::Option<i32>,
    write: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CapacityUnit {
    fn default() -> &'a CapacityUnit {
        <CapacityUnit as ::protobuf::Message>::default_instance()
    }
}

impl CapacityUnit {
    pub fn new() -> CapacityUnit {
        ::std::default::Default::default()
    }

    // optional int32 read = 1;


    pub fn get_read(&self) -> i32 {
        self.read.unwrap_or(0)
    }
    pub fn clear_read(&mut self) {
        self.read = ::std::option::Option::None;
    }

    pub fn has_read(&self) -> bool {
        self.read.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read(&mut self, v: i32) {
        self.read = ::std::option::Option::Some(v);
    }

    // optional int32 write = 2;


    pub fn get_write(&self) -> i32 {
        self.write.unwrap_or(0)
    }
    pub fn clear_write(&mut self) {
        self.write = ::std::option::Option::None;
    }

    pub fn has_write(&self) -> bool {
        self.write.is_some()
    }

    // Param is passed by value, moved
    pub fn set_write(&mut self, v: i32) {
        self.write = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CapacityUnit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.read = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.write = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.read {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.write {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.read {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.write {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CapacityUnit {
        CapacityUnit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "read",
                |m: &CapacityUnit| { &m.read },
                |m: &mut CapacityUnit| { &mut m.read },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "write",
                |m: &CapacityUnit| { &m.write },
                |m: &mut CapacityUnit| { &mut m.write },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CapacityUnit>(
                "CapacityUnit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CapacityUnit {
        static instance: ::protobuf::rt::LazyV2<CapacityUnit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CapacityUnit::new)
    }
}

impl ::protobuf::Clear for CapacityUnit {
    fn clear(&mut self) {
        self.read = ::std::option::Option::None;
        self.write = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CapacityUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CapacityUnit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReservedThroughputDetails {
    // message fields
    pub capacity_unit: ::protobuf::SingularPtrField<CapacityUnit>,
    last_increase_time: ::std::option::Option<i64>,
    last_decrease_time: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReservedThroughputDetails {
    fn default() -> &'a ReservedThroughputDetails {
        <ReservedThroughputDetails as ::protobuf::Message>::default_instance()
    }
}

impl ReservedThroughputDetails {
    pub fn new() -> ReservedThroughputDetails {
        ::std::default::Default::default()
    }

    // required .proto.CapacityUnit capacity_unit = 1;


    pub fn get_capacity_unit(&self) -> &CapacityUnit {
        self.capacity_unit.as_ref().unwrap_or_else(|| <CapacityUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_capacity_unit(&mut self) {
        self.capacity_unit.clear();
    }

    pub fn has_capacity_unit(&self) -> bool {
        self.capacity_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity_unit(&mut self, v: CapacityUnit) {
        self.capacity_unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capacity_unit(&mut self) -> &mut CapacityUnit {
        if self.capacity_unit.is_none() {
            self.capacity_unit.set_default();
        }
        self.capacity_unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_capacity_unit(&mut self) -> CapacityUnit {
        self.capacity_unit.take().unwrap_or_else(|| CapacityUnit::new())
    }

    // required int64 last_increase_time = 2;


    pub fn get_last_increase_time(&self) -> i64 {
        self.last_increase_time.unwrap_or(0)
    }
    pub fn clear_last_increase_time(&mut self) {
        self.last_increase_time = ::std::option::Option::None;
    }

    pub fn has_last_increase_time(&self) -> bool {
        self.last_increase_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_increase_time(&mut self, v: i64) {
        self.last_increase_time = ::std::option::Option::Some(v);
    }

    // optional int64 last_decrease_time = 3;


    pub fn get_last_decrease_time(&self) -> i64 {
        self.last_decrease_time.unwrap_or(0)
    }
    pub fn clear_last_decrease_time(&mut self) {
        self.last_decrease_time = ::std::option::Option::None;
    }

    pub fn has_last_decrease_time(&self) -> bool {
        self.last_decrease_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_decrease_time(&mut self, v: i64) {
        self.last_decrease_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ReservedThroughputDetails {
    fn is_initialized(&self) -> bool {
        if self.capacity_unit.is_none() {
            return false;
        }
        if self.last_increase_time.is_none() {
            return false;
        }
        for v in &self.capacity_unit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capacity_unit)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_increase_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_decrease_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capacity_unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.last_increase_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_decrease_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capacity_unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.last_increase_time {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.last_decrease_time {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReservedThroughputDetails {
        ReservedThroughputDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CapacityUnit>>(
                "capacity_unit",
                |m: &ReservedThroughputDetails| { &m.capacity_unit },
                |m: &mut ReservedThroughputDetails| { &mut m.capacity_unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_increase_time",
                |m: &ReservedThroughputDetails| { &m.last_increase_time },
                |m: &mut ReservedThroughputDetails| { &mut m.last_increase_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_decrease_time",
                |m: &ReservedThroughputDetails| { &m.last_decrease_time },
                |m: &mut ReservedThroughputDetails| { &mut m.last_decrease_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReservedThroughputDetails>(
                "ReservedThroughputDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReservedThroughputDetails {
        static instance: ::protobuf::rt::LazyV2<ReservedThroughputDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReservedThroughputDetails::new)
    }
}

impl ::protobuf::Clear for ReservedThroughputDetails {
    fn clear(&mut self) {
        self.capacity_unit.clear();
        self.last_increase_time = ::std::option::Option::None;
        self.last_decrease_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReservedThroughputDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReservedThroughputDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReservedThroughput {
    // message fields
    pub capacity_unit: ::protobuf::SingularPtrField<CapacityUnit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReservedThroughput {
    fn default() -> &'a ReservedThroughput {
        <ReservedThroughput as ::protobuf::Message>::default_instance()
    }
}

impl ReservedThroughput {
    pub fn new() -> ReservedThroughput {
        ::std::default::Default::default()
    }

    // required .proto.CapacityUnit capacity_unit = 1;


    pub fn get_capacity_unit(&self) -> &CapacityUnit {
        self.capacity_unit.as_ref().unwrap_or_else(|| <CapacityUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_capacity_unit(&mut self) {
        self.capacity_unit.clear();
    }

    pub fn has_capacity_unit(&self) -> bool {
        self.capacity_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity_unit(&mut self, v: CapacityUnit) {
        self.capacity_unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capacity_unit(&mut self) -> &mut CapacityUnit {
        if self.capacity_unit.is_none() {
            self.capacity_unit.set_default();
        }
        self.capacity_unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_capacity_unit(&mut self) -> CapacityUnit {
        self.capacity_unit.take().unwrap_or_else(|| CapacityUnit::new())
    }
}

impl ::protobuf::Message for ReservedThroughput {
    fn is_initialized(&self) -> bool {
        if self.capacity_unit.is_none() {
            return false;
        }
        for v in &self.capacity_unit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capacity_unit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capacity_unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capacity_unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReservedThroughput {
        ReservedThroughput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CapacityUnit>>(
                "capacity_unit",
                |m: &ReservedThroughput| { &m.capacity_unit },
                |m: &mut ReservedThroughput| { &mut m.capacity_unit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReservedThroughput>(
                "ReservedThroughput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReservedThroughput {
        static instance: ::protobuf::rt::LazyV2<ReservedThroughput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReservedThroughput::new)
    }
}

impl ::protobuf::Clear for ReservedThroughput {
    fn clear(&mut self) {
        self.capacity_unit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReservedThroughput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReservedThroughput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConsumedCapacity {
    // message fields
    pub capacity_unit: ::protobuf::SingularPtrField<CapacityUnit>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConsumedCapacity {
    fn default() -> &'a ConsumedCapacity {
        <ConsumedCapacity as ::protobuf::Message>::default_instance()
    }
}

impl ConsumedCapacity {
    pub fn new() -> ConsumedCapacity {
        ::std::default::Default::default()
    }

    // required .proto.CapacityUnit capacity_unit = 1;


    pub fn get_capacity_unit(&self) -> &CapacityUnit {
        self.capacity_unit.as_ref().unwrap_or_else(|| <CapacityUnit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_capacity_unit(&mut self) {
        self.capacity_unit.clear();
    }

    pub fn has_capacity_unit(&self) -> bool {
        self.capacity_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity_unit(&mut self, v: CapacityUnit) {
        self.capacity_unit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capacity_unit(&mut self) -> &mut CapacityUnit {
        if self.capacity_unit.is_none() {
            self.capacity_unit.set_default();
        }
        self.capacity_unit.as_mut().unwrap()
    }

    // Take field
    pub fn take_capacity_unit(&mut self) -> CapacityUnit {
        self.capacity_unit.take().unwrap_or_else(|| CapacityUnit::new())
    }
}

impl ::protobuf::Message for ConsumedCapacity {
    fn is_initialized(&self) -> bool {
        if self.capacity_unit.is_none() {
            return false;
        }
        for v in &self.capacity_unit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capacity_unit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capacity_unit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capacity_unit.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConsumedCapacity {
        ConsumedCapacity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CapacityUnit>>(
                "capacity_unit",
                |m: &ConsumedCapacity| { &m.capacity_unit },
                |m: &mut ConsumedCapacity| { &mut m.capacity_unit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConsumedCapacity>(
                "ConsumedCapacity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConsumedCapacity {
        static instance: ::protobuf::rt::LazyV2<ConsumedCapacity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConsumedCapacity::new)
    }
}

impl ::protobuf::Clear for ConsumedCapacity {
    fn clear(&mut self) {
        self.capacity_unit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConsumedCapacity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConsumedCapacity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamSpecification {
    // message fields
    enable_stream: ::std::option::Option<bool>,
    expiration_time: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamSpecification {
    fn default() -> &'a StreamSpecification {
        <StreamSpecification as ::protobuf::Message>::default_instance()
    }
}

impl StreamSpecification {
    pub fn new() -> StreamSpecification {
        ::std::default::Default::default()
    }

    // required bool enable_stream = 1;


    pub fn get_enable_stream(&self) -> bool {
        self.enable_stream.unwrap_or(false)
    }
    pub fn clear_enable_stream(&mut self) {
        self.enable_stream = ::std::option::Option::None;
    }

    pub fn has_enable_stream(&self) -> bool {
        self.enable_stream.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_stream(&mut self, v: bool) {
        self.enable_stream = ::std::option::Option::Some(v);
    }

    // optional int32 expiration_time = 2;


    pub fn get_expiration_time(&self) -> i32 {
        self.expiration_time.unwrap_or(0)
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: i32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StreamSpecification {
    fn is_initialized(&self) -> bool {
        if self.enable_stream.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_stream = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enable_stream {
            my_size += 2;
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enable_stream {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamSpecification {
        StreamSpecification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_stream",
                |m: &StreamSpecification| { &m.enable_stream },
                |m: &mut StreamSpecification| { &mut m.enable_stream },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expiration_time",
                |m: &StreamSpecification| { &m.expiration_time },
                |m: &mut StreamSpecification| { &mut m.expiration_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamSpecification>(
                "StreamSpecification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamSpecification {
        static instance: ::protobuf::rt::LazyV2<StreamSpecification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamSpecification::new)
    }
}

impl ::protobuf::Clear for StreamSpecification {
    fn clear(&mut self) {
        self.enable_stream = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamSpecification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamSpecification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamDetails {
    // message fields
    enable_stream: ::std::option::Option<bool>,
    stream_id: ::protobuf::SingularField<::std::string::String>,
    expiration_time: ::std::option::Option<i32>,
    last_enable_time: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamDetails {
    fn default() -> &'a StreamDetails {
        <StreamDetails as ::protobuf::Message>::default_instance()
    }
}

impl StreamDetails {
    pub fn new() -> StreamDetails {
        ::std::default::Default::default()
    }

    // required bool enable_stream = 1;


    pub fn get_enable_stream(&self) -> bool {
        self.enable_stream.unwrap_or(false)
    }
    pub fn clear_enable_stream(&mut self) {
        self.enable_stream = ::std::option::Option::None;
    }

    pub fn has_enable_stream(&self) -> bool {
        self.enable_stream.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_stream(&mut self, v: bool) {
        self.enable_stream = ::std::option::Option::Some(v);
    }

    // optional string stream_id = 2;


    pub fn get_stream_id(&self) -> &str {
        match self.stream_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    pub fn has_stream_id(&self) -> bool {
        self.stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        if self.stream_id.is_none() {
            self.stream_id.set_default();
        }
        self.stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        self.stream_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 expiration_time = 3;


    pub fn get_expiration_time(&self) -> i32 {
        self.expiration_time.unwrap_or(0)
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: i32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    // optional int64 last_enable_time = 4;


    pub fn get_last_enable_time(&self) -> i64 {
        self.last_enable_time.unwrap_or(0)
    }
    pub fn clear_last_enable_time(&mut self) {
        self.last_enable_time = ::std::option::Option::None;
    }

    pub fn has_last_enable_time(&self) -> bool {
        self.last_enable_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_enable_time(&mut self, v: i64) {
        self.last_enable_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StreamDetails {
    fn is_initialized(&self) -> bool {
        if self.enable_stream.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_stream = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stream_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_enable_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.enable_stream {
            my_size += 2;
        }
        if let Some(ref v) = self.stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_enable_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.enable_stream {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.stream_id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.last_enable_time {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamDetails {
        StreamDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_stream",
                |m: &StreamDetails| { &m.enable_stream },
                |m: &mut StreamDetails| { &mut m.enable_stream },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &StreamDetails| { &m.stream_id },
                |m: &mut StreamDetails| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expiration_time",
                |m: &StreamDetails| { &m.expiration_time },
                |m: &mut StreamDetails| { &mut m.expiration_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "last_enable_time",
                |m: &StreamDetails| { &m.last_enable_time },
                |m: &mut StreamDetails| { &mut m.last_enable_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamDetails>(
                "StreamDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamDetails {
        static instance: ::protobuf::rt::LazyV2<StreamDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamDetails::new)
    }
}

impl ::protobuf::Clear for StreamDetails {
    fn clear(&mut self) {
        self.enable_stream = ::std::option::Option::None;
        self.stream_id.clear();
        self.expiration_time = ::std::option::Option::None;
        self.last_enable_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateTableRequest {
    // message fields
    pub table_meta: ::protobuf::SingularPtrField<TableMeta>,
    pub reserved_throughput: ::protobuf::SingularPtrField<ReservedThroughput>,
    pub table_options: ::protobuf::SingularPtrField<TableOptions>,
    pub partitions: ::protobuf::RepeatedField<PartitionRange>,
    pub stream_spec: ::protobuf::SingularPtrField<StreamSpecification>,
    pub index_metas: ::protobuf::RepeatedField<IndexMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateTableRequest {
    fn default() -> &'a CreateTableRequest {
        <CreateTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateTableRequest {
    pub fn new() -> CreateTableRequest {
        ::std::default::Default::default()
    }

    // required .proto.TableMeta table_meta = 1;


    pub fn get_table_meta(&self) -> &TableMeta {
        self.table_meta.as_ref().unwrap_or_else(|| <TableMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_meta(&mut self) {
        self.table_meta.clear();
    }

    pub fn has_table_meta(&self) -> bool {
        self.table_meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_meta(&mut self, v: TableMeta) {
        self.table_meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_meta(&mut self) -> &mut TableMeta {
        if self.table_meta.is_none() {
            self.table_meta.set_default();
        }
        self.table_meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_meta(&mut self) -> TableMeta {
        self.table_meta.take().unwrap_or_else(|| TableMeta::new())
    }

    // required .proto.ReservedThroughput reserved_throughput = 2;


    pub fn get_reserved_throughput(&self) -> &ReservedThroughput {
        self.reserved_throughput.as_ref().unwrap_or_else(|| <ReservedThroughput as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reserved_throughput(&mut self) {
        self.reserved_throughput.clear();
    }

    pub fn has_reserved_throughput(&self) -> bool {
        self.reserved_throughput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved_throughput(&mut self, v: ReservedThroughput) {
        self.reserved_throughput = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserved_throughput(&mut self) -> &mut ReservedThroughput {
        if self.reserved_throughput.is_none() {
            self.reserved_throughput.set_default();
        }
        self.reserved_throughput.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserved_throughput(&mut self) -> ReservedThroughput {
        self.reserved_throughput.take().unwrap_or_else(|| ReservedThroughput::new())
    }

    // optional .proto.TableOptions table_options = 3;


    pub fn get_table_options(&self) -> &TableOptions {
        self.table_options.as_ref().unwrap_or_else(|| <TableOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_options(&mut self) {
        self.table_options.clear();
    }

    pub fn has_table_options(&self) -> bool {
        self.table_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_options(&mut self, v: TableOptions) {
        self.table_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_options(&mut self) -> &mut TableOptions {
        if self.table_options.is_none() {
            self.table_options.set_default();
        }
        self.table_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_options(&mut self) -> TableOptions {
        self.table_options.take().unwrap_or_else(|| TableOptions::new())
    }

    // repeated .proto.PartitionRange partitions = 4;


    pub fn get_partitions(&self) -> &[PartitionRange] {
        &self.partitions
    }
    pub fn clear_partitions(&mut self) {
        self.partitions.clear();
    }

    // Param is passed by value, moved
    pub fn set_partitions(&mut self, v: ::protobuf::RepeatedField<PartitionRange>) {
        self.partitions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partitions(&mut self) -> &mut ::protobuf::RepeatedField<PartitionRange> {
        &mut self.partitions
    }

    // Take field
    pub fn take_partitions(&mut self) -> ::protobuf::RepeatedField<PartitionRange> {
        ::std::mem::replace(&mut self.partitions, ::protobuf::RepeatedField::new())
    }

    // optional .proto.StreamSpecification stream_spec = 5;


    pub fn get_stream_spec(&self) -> &StreamSpecification {
        self.stream_spec.as_ref().unwrap_or_else(|| <StreamSpecification as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stream_spec(&mut self) {
        self.stream_spec.clear();
    }

    pub fn has_stream_spec(&self) -> bool {
        self.stream_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_spec(&mut self, v: StreamSpecification) {
        self.stream_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_spec(&mut self) -> &mut StreamSpecification {
        if self.stream_spec.is_none() {
            self.stream_spec.set_default();
        }
        self.stream_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_spec(&mut self) -> StreamSpecification {
        self.stream_spec.take().unwrap_or_else(|| StreamSpecification::new())
    }

    // repeated .proto.IndexMeta index_metas = 7;


    pub fn get_index_metas(&self) -> &[IndexMeta] {
        &self.index_metas
    }
    pub fn clear_index_metas(&mut self) {
        self.index_metas.clear();
    }

    // Param is passed by value, moved
    pub fn set_index_metas(&mut self, v: ::protobuf::RepeatedField<IndexMeta>) {
        self.index_metas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_index_metas(&mut self) -> &mut ::protobuf::RepeatedField<IndexMeta> {
        &mut self.index_metas
    }

    // Take field
    pub fn take_index_metas(&mut self) -> ::protobuf::RepeatedField<IndexMeta> {
        ::std::mem::replace(&mut self.index_metas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CreateTableRequest {
    fn is_initialized(&self) -> bool {
        if self.table_meta.is_none() {
            return false;
        }
        if self.reserved_throughput.is_none() {
            return false;
        }
        for v in &self.table_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_throughput {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.table_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partitions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stream_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index_metas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_meta)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reserved_throughput)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_options)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partitions)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream_spec)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.index_metas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reserved_throughput.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.partitions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.stream_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.index_metas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_meta.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reserved_throughput.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.partitions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.stream_spec.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.index_metas {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateTableRequest {
        CreateTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableMeta>>(
                "table_meta",
                |m: &CreateTableRequest| { &m.table_meta },
                |m: &mut CreateTableRequest| { &mut m.table_meta },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReservedThroughput>>(
                "reserved_throughput",
                |m: &CreateTableRequest| { &m.reserved_throughput },
                |m: &mut CreateTableRequest| { &mut m.reserved_throughput },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableOptions>>(
                "table_options",
                |m: &CreateTableRequest| { &m.table_options },
                |m: &mut CreateTableRequest| { &mut m.table_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PartitionRange>>(
                "partitions",
                |m: &CreateTableRequest| { &m.partitions },
                |m: &mut CreateTableRequest| { &mut m.partitions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamSpecification>>(
                "stream_spec",
                |m: &CreateTableRequest| { &m.stream_spec },
                |m: &mut CreateTableRequest| { &mut m.stream_spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IndexMeta>>(
                "index_metas",
                |m: &CreateTableRequest| { &m.index_metas },
                |m: &mut CreateTableRequest| { &mut m.index_metas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateTableRequest>(
                "CreateTableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateTableRequest {
        static instance: ::protobuf::rt::LazyV2<CreateTableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateTableRequest::new)
    }
}

impl ::protobuf::Clear for CreateTableRequest {
    fn clear(&mut self) {
        self.table_meta.clear();
        self.reserved_throughput.clear();
        self.table_options.clear();
        self.partitions.clear();
        self.stream_spec.clear();
        self.index_metas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateTableResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateTableResponse {
    fn default() -> &'a CreateTableResponse {
        <CreateTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateTableResponse {
    pub fn new() -> CreateTableResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateTableResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateTableResponse {
        CreateTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateTableResponse>(
                "CreateTableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateTableResponse {
        static instance: ::protobuf::rt::LazyV2<CreateTableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateTableResponse::new)
    }
}

impl ::protobuf::Clear for CreateTableResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTableRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub reserved_throughput: ::protobuf::SingularPtrField<ReservedThroughput>,
    pub table_options: ::protobuf::SingularPtrField<TableOptions>,
    pub stream_spec: ::protobuf::SingularPtrField<StreamSpecification>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTableRequest {
    fn default() -> &'a UpdateTableRequest {
        <UpdateTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTableRequest {
    pub fn new() -> UpdateTableRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.ReservedThroughput reserved_throughput = 2;


    pub fn get_reserved_throughput(&self) -> &ReservedThroughput {
        self.reserved_throughput.as_ref().unwrap_or_else(|| <ReservedThroughput as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reserved_throughput(&mut self) {
        self.reserved_throughput.clear();
    }

    pub fn has_reserved_throughput(&self) -> bool {
        self.reserved_throughput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved_throughput(&mut self, v: ReservedThroughput) {
        self.reserved_throughput = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserved_throughput(&mut self) -> &mut ReservedThroughput {
        if self.reserved_throughput.is_none() {
            self.reserved_throughput.set_default();
        }
        self.reserved_throughput.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserved_throughput(&mut self) -> ReservedThroughput {
        self.reserved_throughput.take().unwrap_or_else(|| ReservedThroughput::new())
    }

    // optional .proto.TableOptions table_options = 3;


    pub fn get_table_options(&self) -> &TableOptions {
        self.table_options.as_ref().unwrap_or_else(|| <TableOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_options(&mut self) {
        self.table_options.clear();
    }

    pub fn has_table_options(&self) -> bool {
        self.table_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_options(&mut self, v: TableOptions) {
        self.table_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_options(&mut self) -> &mut TableOptions {
        if self.table_options.is_none() {
            self.table_options.set_default();
        }
        self.table_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_options(&mut self) -> TableOptions {
        self.table_options.take().unwrap_or_else(|| TableOptions::new())
    }

    // optional .proto.StreamSpecification stream_spec = 4;


    pub fn get_stream_spec(&self) -> &StreamSpecification {
        self.stream_spec.as_ref().unwrap_or_else(|| <StreamSpecification as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stream_spec(&mut self) {
        self.stream_spec.clear();
    }

    pub fn has_stream_spec(&self) -> bool {
        self.stream_spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_spec(&mut self, v: StreamSpecification) {
        self.stream_spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_spec(&mut self) -> &mut StreamSpecification {
        if self.stream_spec.is_none() {
            self.stream_spec.set_default();
        }
        self.stream_spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_spec(&mut self) -> StreamSpecification {
        self.stream_spec.take().unwrap_or_else(|| StreamSpecification::new())
    }
}

impl ::protobuf::Message for UpdateTableRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        for v in &self.reserved_throughput {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.table_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stream_spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reserved_throughput)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_options)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream_spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.reserved_throughput.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stream_spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.reserved_throughput.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stream_spec.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTableRequest {
        UpdateTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &UpdateTableRequest| { &m.table_name },
                |m: &mut UpdateTableRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReservedThroughput>>(
                "reserved_throughput",
                |m: &UpdateTableRequest| { &m.reserved_throughput },
                |m: &mut UpdateTableRequest| { &mut m.reserved_throughput },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableOptions>>(
                "table_options",
                |m: &UpdateTableRequest| { &m.table_options },
                |m: &mut UpdateTableRequest| { &mut m.table_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamSpecification>>(
                "stream_spec",
                |m: &UpdateTableRequest| { &m.stream_spec },
                |m: &mut UpdateTableRequest| { &mut m.stream_spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTableRequest>(
                "UpdateTableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateTableRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateTableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTableRequest::new)
    }
}

impl ::protobuf::Clear for UpdateTableRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.reserved_throughput.clear();
        self.table_options.clear();
        self.stream_spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTableResponse {
    // message fields
    pub reserved_throughput_details: ::protobuf::SingularPtrField<ReservedThroughputDetails>,
    pub table_options: ::protobuf::SingularPtrField<TableOptions>,
    pub stream_details: ::protobuf::SingularPtrField<StreamDetails>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTableResponse {
    fn default() -> &'a UpdateTableResponse {
        <UpdateTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTableResponse {
    pub fn new() -> UpdateTableResponse {
        ::std::default::Default::default()
    }

    // required .proto.ReservedThroughputDetails reserved_throughput_details = 1;


    pub fn get_reserved_throughput_details(&self) -> &ReservedThroughputDetails {
        self.reserved_throughput_details.as_ref().unwrap_or_else(|| <ReservedThroughputDetails as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reserved_throughput_details(&mut self) {
        self.reserved_throughput_details.clear();
    }

    pub fn has_reserved_throughput_details(&self) -> bool {
        self.reserved_throughput_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved_throughput_details(&mut self, v: ReservedThroughputDetails) {
        self.reserved_throughput_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserved_throughput_details(&mut self) -> &mut ReservedThroughputDetails {
        if self.reserved_throughput_details.is_none() {
            self.reserved_throughput_details.set_default();
        }
        self.reserved_throughput_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserved_throughput_details(&mut self) -> ReservedThroughputDetails {
        self.reserved_throughput_details.take().unwrap_or_else(|| ReservedThroughputDetails::new())
    }

    // required .proto.TableOptions table_options = 2;


    pub fn get_table_options(&self) -> &TableOptions {
        self.table_options.as_ref().unwrap_or_else(|| <TableOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_options(&mut self) {
        self.table_options.clear();
    }

    pub fn has_table_options(&self) -> bool {
        self.table_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_options(&mut self, v: TableOptions) {
        self.table_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_options(&mut self) -> &mut TableOptions {
        if self.table_options.is_none() {
            self.table_options.set_default();
        }
        self.table_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_options(&mut self) -> TableOptions {
        self.table_options.take().unwrap_or_else(|| TableOptions::new())
    }

    // optional .proto.StreamDetails stream_details = 3;


    pub fn get_stream_details(&self) -> &StreamDetails {
        self.stream_details.as_ref().unwrap_or_else(|| <StreamDetails as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stream_details(&mut self) {
        self.stream_details.clear();
    }

    pub fn has_stream_details(&self) -> bool {
        self.stream_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_details(&mut self, v: StreamDetails) {
        self.stream_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_details(&mut self) -> &mut StreamDetails {
        if self.stream_details.is_none() {
            self.stream_details.set_default();
        }
        self.stream_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_details(&mut self) -> StreamDetails {
        self.stream_details.take().unwrap_or_else(|| StreamDetails::new())
    }
}

impl ::protobuf::Message for UpdateTableResponse {
    fn is_initialized(&self) -> bool {
        if self.reserved_throughput_details.is_none() {
            return false;
        }
        if self.table_options.is_none() {
            return false;
        }
        for v in &self.reserved_throughput_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.table_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stream_details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reserved_throughput_details)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_options)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream_details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reserved_throughput_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stream_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reserved_throughput_details.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stream_details.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTableResponse {
        UpdateTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReservedThroughputDetails>>(
                "reserved_throughput_details",
                |m: &UpdateTableResponse| { &m.reserved_throughput_details },
                |m: &mut UpdateTableResponse| { &mut m.reserved_throughput_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableOptions>>(
                "table_options",
                |m: &UpdateTableResponse| { &m.table_options },
                |m: &mut UpdateTableResponse| { &mut m.table_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamDetails>>(
                "stream_details",
                |m: &UpdateTableResponse| { &m.stream_details },
                |m: &mut UpdateTableResponse| { &mut m.stream_details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTableResponse>(
                "UpdateTableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateTableResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateTableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTableResponse::new)
    }
}

impl ::protobuf::Clear for UpdateTableResponse {
    fn clear(&mut self) {
        self.reserved_throughput_details.clear();
        self.table_options.clear();
        self.stream_details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DescribeTableRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DescribeTableRequest {
    fn default() -> &'a DescribeTableRequest {
        <DescribeTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl DescribeTableRequest {
    pub fn new() -> DescribeTableRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DescribeTableRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DescribeTableRequest {
        DescribeTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &DescribeTableRequest| { &m.table_name },
                |m: &mut DescribeTableRequest| { &mut m.table_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DescribeTableRequest>(
                "DescribeTableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DescribeTableRequest {
        static instance: ::protobuf::rt::LazyV2<DescribeTableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DescribeTableRequest::new)
    }
}

impl ::protobuf::Clear for DescribeTableRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DescribeTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DescribeTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DescribeTableResponse {
    // message fields
    pub table_meta: ::protobuf::SingularPtrField<TableMeta>,
    pub reserved_throughput_details: ::protobuf::SingularPtrField<ReservedThroughputDetails>,
    pub table_options: ::protobuf::SingularPtrField<TableOptions>,
    table_status: ::std::option::Option<TableStatus>,
    pub stream_details: ::protobuf::SingularPtrField<StreamDetails>,
    pub shard_splits: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub index_metas: ::protobuf::RepeatedField<IndexMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DescribeTableResponse {
    fn default() -> &'a DescribeTableResponse {
        <DescribeTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl DescribeTableResponse {
    pub fn new() -> DescribeTableResponse {
        ::std::default::Default::default()
    }

    // required .proto.TableMeta table_meta = 1;


    pub fn get_table_meta(&self) -> &TableMeta {
        self.table_meta.as_ref().unwrap_or_else(|| <TableMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_meta(&mut self) {
        self.table_meta.clear();
    }

    pub fn has_table_meta(&self) -> bool {
        self.table_meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_meta(&mut self, v: TableMeta) {
        self.table_meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_meta(&mut self) -> &mut TableMeta {
        if self.table_meta.is_none() {
            self.table_meta.set_default();
        }
        self.table_meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_meta(&mut self) -> TableMeta {
        self.table_meta.take().unwrap_or_else(|| TableMeta::new())
    }

    // required .proto.ReservedThroughputDetails reserved_throughput_details = 2;


    pub fn get_reserved_throughput_details(&self) -> &ReservedThroughputDetails {
        self.reserved_throughput_details.as_ref().unwrap_or_else(|| <ReservedThroughputDetails as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reserved_throughput_details(&mut self) {
        self.reserved_throughput_details.clear();
    }

    pub fn has_reserved_throughput_details(&self) -> bool {
        self.reserved_throughput_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserved_throughput_details(&mut self, v: ReservedThroughputDetails) {
        self.reserved_throughput_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserved_throughput_details(&mut self) -> &mut ReservedThroughputDetails {
        if self.reserved_throughput_details.is_none() {
            self.reserved_throughput_details.set_default();
        }
        self.reserved_throughput_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserved_throughput_details(&mut self) -> ReservedThroughputDetails {
        self.reserved_throughput_details.take().unwrap_or_else(|| ReservedThroughputDetails::new())
    }

    // required .proto.TableOptions table_options = 3;


    pub fn get_table_options(&self) -> &TableOptions {
        self.table_options.as_ref().unwrap_or_else(|| <TableOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_table_options(&mut self) {
        self.table_options.clear();
    }

    pub fn has_table_options(&self) -> bool {
        self.table_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_options(&mut self, v: TableOptions) {
        self.table_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_options(&mut self) -> &mut TableOptions {
        if self.table_options.is_none() {
            self.table_options.set_default();
        }
        self.table_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_options(&mut self) -> TableOptions {
        self.table_options.take().unwrap_or_else(|| TableOptions::new())
    }

    // required .proto.TableStatus table_status = 4;


    pub fn get_table_status(&self) -> TableStatus {
        self.table_status.unwrap_or(TableStatus::ACTIVE)
    }
    pub fn clear_table_status(&mut self) {
        self.table_status = ::std::option::Option::None;
    }

    pub fn has_table_status(&self) -> bool {
        self.table_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_status(&mut self, v: TableStatus) {
        self.table_status = ::std::option::Option::Some(v);
    }

    // optional .proto.StreamDetails stream_details = 5;


    pub fn get_stream_details(&self) -> &StreamDetails {
        self.stream_details.as_ref().unwrap_or_else(|| <StreamDetails as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stream_details(&mut self) {
        self.stream_details.clear();
    }

    pub fn has_stream_details(&self) -> bool {
        self.stream_details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_details(&mut self, v: StreamDetails) {
        self.stream_details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_details(&mut self) -> &mut StreamDetails {
        if self.stream_details.is_none() {
            self.stream_details.set_default();
        }
        self.stream_details.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_details(&mut self) -> StreamDetails {
        self.stream_details.take().unwrap_or_else(|| StreamDetails::new())
    }

    // repeated bytes shard_splits = 6;


    pub fn get_shard_splits(&self) -> &[::std::vec::Vec<u8>] {
        &self.shard_splits
    }
    pub fn clear_shard_splits(&mut self) {
        self.shard_splits.clear();
    }

    // Param is passed by value, moved
    pub fn set_shard_splits(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.shard_splits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shard_splits(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.shard_splits
    }

    // Take field
    pub fn take_shard_splits(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.shard_splits, ::protobuf::RepeatedField::new())
    }

    // repeated .proto.IndexMeta index_metas = 8;


    pub fn get_index_metas(&self) -> &[IndexMeta] {
        &self.index_metas
    }
    pub fn clear_index_metas(&mut self) {
        self.index_metas.clear();
    }

    // Param is passed by value, moved
    pub fn set_index_metas(&mut self, v: ::protobuf::RepeatedField<IndexMeta>) {
        self.index_metas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_index_metas(&mut self) -> &mut ::protobuf::RepeatedField<IndexMeta> {
        &mut self.index_metas
    }

    // Take field
    pub fn take_index_metas(&mut self) -> ::protobuf::RepeatedField<IndexMeta> {
        ::std::mem::replace(&mut self.index_metas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DescribeTableResponse {
    fn is_initialized(&self) -> bool {
        if self.table_meta.is_none() {
            return false;
        }
        if self.reserved_throughput_details.is_none() {
            return false;
        }
        if self.table_options.is_none() {
            return false;
        }
        if self.table_status.is_none() {
            return false;
        }
        for v in &self.table_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_throughput_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.table_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stream_details {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.index_metas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_meta)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reserved_throughput_details)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.table_options)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.table_status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream_details)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.shard_splits)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.index_metas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reserved_throughput_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.table_status {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(ref v) = self.stream_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.shard_splits {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        for value in &self.index_metas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_meta.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reserved_throughput_details.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.table_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.table_status {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.stream_details.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.shard_splits {
            os.write_bytes(6, &v)?;
        };
        for v in &self.index_metas {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DescribeTableResponse {
        DescribeTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableMeta>>(
                "table_meta",
                |m: &DescribeTableResponse| { &m.table_meta },
                |m: &mut DescribeTableResponse| { &mut m.table_meta },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReservedThroughputDetails>>(
                "reserved_throughput_details",
                |m: &DescribeTableResponse| { &m.reserved_throughput_details },
                |m: &mut DescribeTableResponse| { &mut m.reserved_throughput_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableOptions>>(
                "table_options",
                |m: &DescribeTableResponse| { &m.table_options },
                |m: &mut DescribeTableResponse| { &mut m.table_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TableStatus>>(
                "table_status",
                |m: &DescribeTableResponse| { &m.table_status },
                |m: &mut DescribeTableResponse| { &mut m.table_status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamDetails>>(
                "stream_details",
                |m: &DescribeTableResponse| { &m.stream_details },
                |m: &mut DescribeTableResponse| { &mut m.stream_details },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "shard_splits",
                |m: &DescribeTableResponse| { &m.shard_splits },
                |m: &mut DescribeTableResponse| { &mut m.shard_splits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IndexMeta>>(
                "index_metas",
                |m: &DescribeTableResponse| { &m.index_metas },
                |m: &mut DescribeTableResponse| { &mut m.index_metas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DescribeTableResponse>(
                "DescribeTableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DescribeTableResponse {
        static instance: ::protobuf::rt::LazyV2<DescribeTableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DescribeTableResponse::new)
    }
}

impl ::protobuf::Clear for DescribeTableResponse {
    fn clear(&mut self) {
        self.table_meta.clear();
        self.reserved_throughput_details.clear();
        self.table_options.clear();
        self.table_status = ::std::option::Option::None;
        self.stream_details.clear();
        self.shard_splits.clear();
        self.index_metas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DescribeTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DescribeTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTableRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTableRequest {
    fn default() -> &'a ListTableRequest {
        <ListTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListTableRequest {
    pub fn new() -> ListTableRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListTableRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTableRequest {
        ListTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTableRequest>(
                "ListTableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTableRequest {
        static instance: ::protobuf::rt::LazyV2<ListTableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTableRequest::new)
    }
}

impl ::protobuf::Clear for ListTableRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListTableResponse {
    // message fields
    pub table_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListTableResponse {
    fn default() -> &'a ListTableResponse {
        <ListTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListTableResponse {
    pub fn new() -> ListTableResponse {
        ::std::default::Default::default()
    }

    // repeated string table_names = 1;


    pub fn get_table_names(&self) -> &[::std::string::String] {
        &self.table_names
    }
    pub fn clear_table_names(&mut self) {
        self.table_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.table_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_table_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.table_names
    }

    // Take field
    pub fn take_table_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.table_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListTableResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.table_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.table_names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.table_names {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListTableResponse {
        ListTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_names",
                |m: &ListTableResponse| { &m.table_names },
                |m: &mut ListTableResponse| { &mut m.table_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListTableResponse>(
                "ListTableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListTableResponse {
        static instance: ::protobuf::rt::LazyV2<ListTableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListTableResponse::new)
    }
}

impl ::protobuf::Clear for ListTableResponse {
    fn clear(&mut self) {
        self.table_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTableRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTableRequest {
    fn default() -> &'a DeleteTableRequest {
        <DeleteTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTableRequest {
    pub fn new() -> DeleteTableRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteTableRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTableRequest {
        DeleteTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &DeleteTableRequest| { &m.table_name },
                |m: &mut DeleteTableRequest| { &mut m.table_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteTableRequest>(
                "DeleteTableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteTableRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteTableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteTableRequest::new)
    }
}

impl ::protobuf::Clear for DeleteTableRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteTableResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteTableResponse {
    fn default() -> &'a DeleteTableResponse {
        <DeleteTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTableResponse {
    pub fn new() -> DeleteTableResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteTableResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteTableResponse {
        DeleteTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteTableResponse>(
                "DeleteTableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteTableResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteTableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteTableResponse::new)
    }
}

impl ::protobuf::Clear for DeleteTableResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadTableRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadTableRequest {
    fn default() -> &'a LoadTableRequest {
        <LoadTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoadTableRequest {
    pub fn new() -> LoadTableRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for LoadTableRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadTableRequest {
        LoadTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &LoadTableRequest| { &m.table_name },
                |m: &mut LoadTableRequest| { &mut m.table_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadTableRequest>(
                "LoadTableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadTableRequest {
        static instance: ::protobuf::rt::LazyV2<LoadTableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadTableRequest::new)
    }
}

impl ::protobuf::Clear for LoadTableRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadTableResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadTableResponse {
    fn default() -> &'a LoadTableResponse {
        <LoadTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoadTableResponse {
    pub fn new() -> LoadTableResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LoadTableResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadTableResponse {
        LoadTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadTableResponse>(
                "LoadTableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadTableResponse {
        static instance: ::protobuf::rt::LazyV2<LoadTableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadTableResponse::new)
    }
}

impl ::protobuf::Clear for LoadTableResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnloadTableRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnloadTableRequest {
    fn default() -> &'a UnloadTableRequest {
        <UnloadTableRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnloadTableRequest {
    pub fn new() -> UnloadTableRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UnloadTableRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnloadTableRequest {
        UnloadTableRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &UnloadTableRequest| { &m.table_name },
                |m: &mut UnloadTableRequest| { &mut m.table_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnloadTableRequest>(
                "UnloadTableRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnloadTableRequest {
        static instance: ::protobuf::rt::LazyV2<UnloadTableRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnloadTableRequest::new)
    }
}

impl ::protobuf::Clear for UnloadTableRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnloadTableRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnloadTableRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnloadTableResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnloadTableResponse {
    fn default() -> &'a UnloadTableResponse {
        <UnloadTableResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnloadTableResponse {
    pub fn new() -> UnloadTableResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnloadTableResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnloadTableResponse {
        UnloadTableResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnloadTableResponse>(
                "UnloadTableResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnloadTableResponse {
        static instance: ::protobuf::rt::LazyV2<UnloadTableResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnloadTableResponse::new)
    }
}

impl ::protobuf::Clear for UnloadTableResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnloadTableResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnloadTableResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeRange {
    // message fields
    start_time: ::std::option::Option<i64>,
    end_time: ::std::option::Option<i64>,
    specific_time: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeRange {
    fn default() -> &'a TimeRange {
        <TimeRange as ::protobuf::Message>::default_instance()
    }
}

impl TimeRange {
    pub fn new() -> TimeRange {
        ::std::default::Default::default()
    }

    // optional int64 start_time = 1;


    pub fn get_start_time(&self) -> i64 {
        self.start_time.unwrap_or(0)
    }
    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional int64 end_time = 2;


    pub fn get_end_time(&self) -> i64 {
        self.end_time.unwrap_or(0)
    }
    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: i64) {
        self.end_time = ::std::option::Option::Some(v);
    }

    // optional int64 specific_time = 3;


    pub fn get_specific_time(&self) -> i64 {
        self.specific_time.unwrap_or(0)
    }
    pub fn clear_specific_time(&mut self) {
        self.specific_time = ::std::option::Option::None;
    }

    pub fn has_specific_time(&self) -> bool {
        self.specific_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specific_time(&mut self, v: i64) {
        self.specific_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TimeRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_time = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.specific_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.specific_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start_time {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.specific_time {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeRange {
        TimeRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_time",
                |m: &TimeRange| { &m.start_time },
                |m: &mut TimeRange| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end_time",
                |m: &TimeRange| { &m.end_time },
                |m: &mut TimeRange| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "specific_time",
                |m: &TimeRange| { &m.specific_time },
                |m: &mut TimeRange| { &mut m.specific_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeRange>(
                "TimeRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeRange {
        static instance: ::protobuf::rt::LazyV2<TimeRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeRange::new)
    }
}

impl ::protobuf::Clear for TimeRange {
    fn clear(&mut self) {
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.specific_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReturnContent {
    // message fields
    return_type: ::std::option::Option<ReturnType>,
    pub return_column_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReturnContent {
    fn default() -> &'a ReturnContent {
        <ReturnContent as ::protobuf::Message>::default_instance()
    }
}

impl ReturnContent {
    pub fn new() -> ReturnContent {
        ::std::default::Default::default()
    }

    // optional .proto.ReturnType return_type = 1;


    pub fn get_return_type(&self) -> ReturnType {
        self.return_type.unwrap_or(ReturnType::RT_NONE)
    }
    pub fn clear_return_type(&mut self) {
        self.return_type = ::std::option::Option::None;
    }

    pub fn has_return_type(&self) -> bool {
        self.return_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_type(&mut self, v: ReturnType) {
        self.return_type = ::std::option::Option::Some(v);
    }

    // repeated string return_column_names = 2;


    pub fn get_return_column_names(&self) -> &[::std::string::String] {
        &self.return_column_names
    }
    pub fn clear_return_column_names(&mut self) {
        self.return_column_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_return_column_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.return_column_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_return_column_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.return_column_names
    }

    // Take field
    pub fn take_return_column_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.return_column_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReturnContent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.return_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.return_column_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.return_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        for value in &self.return_column_names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.return_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.return_column_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReturnContent {
        ReturnContent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ReturnType>>(
                "return_type",
                |m: &ReturnContent| { &m.return_type },
                |m: &mut ReturnContent| { &mut m.return_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "return_column_names",
                |m: &ReturnContent| { &m.return_column_names },
                |m: &mut ReturnContent| { &mut m.return_column_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReturnContent>(
                "ReturnContent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReturnContent {
        static instance: ::protobuf::rt::LazyV2<ReturnContent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReturnContent::new)
    }
}

impl ::protobuf::Clear for ReturnContent {
    fn clear(&mut self) {
        self.return_type = ::std::option::Option::None;
        self.return_column_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReturnContent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReturnContent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRowRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    primary_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub columns_to_get: ::protobuf::RepeatedField<::std::string::String>,
    pub time_range: ::protobuf::SingularPtrField<TimeRange>,
    max_versions: ::std::option::Option<i32>,
    cache_blocks: ::std::option::Option<bool>,
    filter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    start_column: ::protobuf::SingularField<::std::string::String>,
    end_column: ::protobuf::SingularField<::std::string::String>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRowRequest {
    fn default() -> &'a GetRowRequest {
        <GetRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRowRequest {
    pub fn new() -> GetRowRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes primary_key = 2;


    pub fn get_primary_key(&self) -> &[u8] {
        match self.primary_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    pub fn has_primary_key(&self) -> bool {
        self.primary_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.primary_key.is_none() {
            self.primary_key.set_default();
        }
        self.primary_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_primary_key(&mut self) -> ::std::vec::Vec<u8> {
        self.primary_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated string columns_to_get = 3;


    pub fn get_columns_to_get(&self) -> &[::std::string::String] {
        &self.columns_to_get
    }
    pub fn clear_columns_to_get(&mut self) {
        self.columns_to_get.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns_to_get(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.columns_to_get = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns_to_get(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.columns_to_get
    }

    // Take field
    pub fn take_columns_to_get(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.columns_to_get, ::protobuf::RepeatedField::new())
    }

    // optional .proto.TimeRange time_range = 4;


    pub fn get_time_range(&self) -> &TimeRange {
        self.time_range.as_ref().unwrap_or_else(|| <TimeRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_range(&mut self) {
        self.time_range.clear();
    }

    pub fn has_time_range(&self) -> bool {
        self.time_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_range(&mut self, v: TimeRange) {
        self.time_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_range(&mut self) -> &mut TimeRange {
        if self.time_range.is_none() {
            self.time_range.set_default();
        }
        self.time_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_range(&mut self) -> TimeRange {
        self.time_range.take().unwrap_or_else(|| TimeRange::new())
    }

    // optional int32 max_versions = 5;


    pub fn get_max_versions(&self) -> i32 {
        self.max_versions.unwrap_or(0)
    }
    pub fn clear_max_versions(&mut self) {
        self.max_versions = ::std::option::Option::None;
    }

    pub fn has_max_versions(&self) -> bool {
        self.max_versions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_versions(&mut self, v: i32) {
        self.max_versions = ::std::option::Option::Some(v);
    }

    // optional bool cache_blocks = 6;


    pub fn get_cache_blocks(&self) -> bool {
        self.cache_blocks.unwrap_or(true)
    }
    pub fn clear_cache_blocks(&mut self) {
        self.cache_blocks = ::std::option::Option::None;
    }

    pub fn has_cache_blocks(&self) -> bool {
        self.cache_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_blocks(&mut self, v: bool) {
        self.cache_blocks = ::std::option::Option::Some(v);
    }

    // optional bytes filter = 7;


    pub fn get_filter(&self) -> &[u8] {
        match self.filter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::vec::Vec<u8> {
        self.filter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string start_column = 8;


    pub fn get_start_column(&self) -> &str {
        match self.start_column.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_start_column(&mut self) {
        self.start_column.clear();
    }

    pub fn has_start_column(&self) -> bool {
        self.start_column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_column(&mut self, v: ::std::string::String) {
        self.start_column = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_column(&mut self) -> &mut ::std::string::String {
        if self.start_column.is_none() {
            self.start_column.set_default();
        }
        self.start_column.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_column(&mut self) -> ::std::string::String {
        self.start_column.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string end_column = 9;


    pub fn get_end_column(&self) -> &str {
        match self.end_column.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_end_column(&mut self) {
        self.end_column.clear();
    }

    pub fn has_end_column(&self) -> bool {
        self.end_column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_column(&mut self, v: ::std::string::String) {
        self.end_column = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_column(&mut self) -> &mut ::std::string::String {
        if self.end_column.is_none() {
            self.end_column.set_default();
        }
        self.end_column.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_column(&mut self) -> ::std::string::String {
        self.end_column.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes token = 10;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string transaction_id = 11;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetRowRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        if self.primary_key.is_none() {
            return false;
        }
        for v in &self.time_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.primary_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.columns_to_get)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_range)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_versions = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cache_blocks = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.filter)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.start_column)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.end_column)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.primary_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.columns_to_get {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.time_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.max_versions {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cache_blocks {
            my_size += 2;
        }
        if let Some(ref v) = self.filter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.start_column.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.end_column.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.primary_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.columns_to_get {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.time_range.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.max_versions {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cache_blocks {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.start_column.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.end_column.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRowRequest {
        GetRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &GetRowRequest| { &m.table_name },
                |m: &mut GetRowRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "primary_key",
                |m: &GetRowRequest| { &m.primary_key },
                |m: &mut GetRowRequest| { &mut m.primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columns_to_get",
                |m: &GetRowRequest| { &m.columns_to_get },
                |m: &mut GetRowRequest| { &mut m.columns_to_get },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeRange>>(
                "time_range",
                |m: &GetRowRequest| { &m.time_range },
                |m: &mut GetRowRequest| { &mut m.time_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_versions",
                |m: &GetRowRequest| { &m.max_versions },
                |m: &mut GetRowRequest| { &mut m.max_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cache_blocks",
                |m: &GetRowRequest| { &m.cache_blocks },
                |m: &mut GetRowRequest| { &mut m.cache_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "filter",
                |m: &GetRowRequest| { &m.filter },
                |m: &mut GetRowRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start_column",
                |m: &GetRowRequest| { &m.start_column },
                |m: &mut GetRowRequest| { &mut m.start_column },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "end_column",
                |m: &GetRowRequest| { &m.end_column },
                |m: &mut GetRowRequest| { &mut m.end_column },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &GetRowRequest| { &m.token },
                |m: &mut GetRowRequest| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &GetRowRequest| { &m.transaction_id },
                |m: &mut GetRowRequest| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRowRequest>(
                "GetRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRowRequest {
        static instance: ::protobuf::rt::LazyV2<GetRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRowRequest::new)
    }
}

impl ::protobuf::Clear for GetRowRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.primary_key.clear();
        self.columns_to_get.clear();
        self.time_range.clear();
        self.max_versions = ::std::option::Option::None;
        self.cache_blocks = ::std::option::Option::None;
        self.filter.clear();
        self.start_column.clear();
        self.end_column.clear();
        self.token.clear();
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRowResponse {
    // message fields
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    row: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    next_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRowResponse {
    fn default() -> &'a GetRowResponse {
        <GetRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetRowResponse {
    pub fn new() -> GetRowResponse {
        ::std::default::Default::default()
    }

    // required .proto.ConsumedCapacity consumed = 1;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // required bytes row = 2;


    pub fn get_row(&self) -> &[u8] {
        match self.row.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::vec::Vec<u8>) {
        self.row = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row.is_none() {
            self.row.set_default();
        }
        self.row.as_mut().unwrap()
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::vec::Vec<u8> {
        self.row.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes next_token = 3;


    pub fn get_next_token(&self) -> &[u8] {
        match self.next_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_next_token(&mut self) {
        self.next_token.clear();
    }

    pub fn has_next_token(&self) -> bool {
        self.next_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.next_token.is_none() {
            self.next_token.set_default();
        }
        self.next_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_token(&mut self) -> ::std::vec::Vec<u8> {
        self.next_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetRowResponse {
    fn is_initialized(&self) -> bool {
        if self.consumed.is_none() {
            return false;
        }
        if self.row.is_none() {
            return false;
        }
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.next_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.row.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.next_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.row.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.next_token.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRowResponse {
        GetRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &GetRowResponse| { &m.consumed },
                |m: &mut GetRowResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row",
                |m: &GetRowResponse| { &m.row },
                |m: &mut GetRowResponse| { &mut m.row },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_token",
                |m: &GetRowResponse| { &m.next_token },
                |m: &mut GetRowResponse| { &mut m.next_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRowResponse>(
                "GetRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRowResponse {
        static instance: ::protobuf::rt::LazyV2<GetRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRowResponse::new)
    }
}

impl ::protobuf::Clear for GetRowResponse {
    fn clear(&mut self) {
        self.consumed.clear();
        self.row.clear();
        self.next_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRowRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    row_change: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub condition: ::protobuf::SingularPtrField<Condition>,
    pub return_content: ::protobuf::SingularPtrField<ReturnContent>,
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRowRequest {
    fn default() -> &'a UpdateRowRequest {
        <UpdateRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRowRequest {
    pub fn new() -> UpdateRowRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes row_change = 2;


    pub fn get_row_change(&self) -> &[u8] {
        match self.row_change.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row_change(&mut self) {
        self.row_change.clear();
    }

    pub fn has_row_change(&self) -> bool {
        self.row_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row_change(&mut self, v: ::std::vec::Vec<u8>) {
        self.row_change = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row_change(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row_change.is_none() {
            self.row_change.set_default();
        }
        self.row_change.as_mut().unwrap()
    }

    // Take field
    pub fn take_row_change(&mut self) -> ::std::vec::Vec<u8> {
        self.row_change.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .proto.Condition condition = 3;


    pub fn get_condition(&self) -> &Condition {
        self.condition.as_ref().unwrap_or_else(|| <Condition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: Condition) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut Condition {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> Condition {
        self.condition.take().unwrap_or_else(|| Condition::new())
    }

    // optional .proto.ReturnContent return_content = 4;


    pub fn get_return_content(&self) -> &ReturnContent {
        self.return_content.as_ref().unwrap_or_else(|| <ReturnContent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_return_content(&mut self) {
        self.return_content.clear();
    }

    pub fn has_return_content(&self) -> bool {
        self.return_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_content(&mut self, v: ReturnContent) {
        self.return_content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_content(&mut self) -> &mut ReturnContent {
        if self.return_content.is_none() {
            self.return_content.set_default();
        }
        self.return_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_content(&mut self) -> ReturnContent {
        self.return_content.take().unwrap_or_else(|| ReturnContent::new())
    }

    // optional string transaction_id = 5;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateRowRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        if self.row_change.is_none() {
            return false;
        }
        if self.condition.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row_change)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.return_content)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.row_change.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.row_change.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRowRequest {
        UpdateRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &UpdateRowRequest| { &m.table_name },
                |m: &mut UpdateRowRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row_change",
                |m: &UpdateRowRequest| { &m.row_change },
                |m: &mut UpdateRowRequest| { &mut m.row_change },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Condition>>(
                "condition",
                |m: &UpdateRowRequest| { &m.condition },
                |m: &mut UpdateRowRequest| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReturnContent>>(
                "return_content",
                |m: &UpdateRowRequest| { &m.return_content },
                |m: &mut UpdateRowRequest| { &mut m.return_content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &UpdateRowRequest| { &m.transaction_id },
                |m: &mut UpdateRowRequest| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRowRequest>(
                "UpdateRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRowRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRowRequest::new)
    }
}

impl ::protobuf::Clear for UpdateRowRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.row_change.clear();
        self.condition.clear();
        self.return_content.clear();
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateRowResponse {
    // message fields
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    row: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateRowResponse {
    fn default() -> &'a UpdateRowResponse {
        <UpdateRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateRowResponse {
    pub fn new() -> UpdateRowResponse {
        ::std::default::Default::default()
    }

    // required .proto.ConsumedCapacity consumed = 1;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // optional bytes row = 2;


    pub fn get_row(&self) -> &[u8] {
        match self.row.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::vec::Vec<u8>) {
        self.row = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row.is_none() {
            self.row.set_default();
        }
        self.row.as_mut().unwrap()
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::vec::Vec<u8> {
        self.row.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for UpdateRowResponse {
    fn is_initialized(&self) -> bool {
        if self.consumed.is_none() {
            return false;
        }
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.row.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.row.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateRowResponse {
        UpdateRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &UpdateRowResponse| { &m.consumed },
                |m: &mut UpdateRowResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row",
                |m: &UpdateRowResponse| { &m.row },
                |m: &mut UpdateRowResponse| { &mut m.row },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateRowResponse>(
                "UpdateRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateRowResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateRowResponse::new)
    }
}

impl ::protobuf::Clear for UpdateRowResponse {
    fn clear(&mut self) {
        self.consumed.clear();
        self.row.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutRowRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    row: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub condition: ::protobuf::SingularPtrField<Condition>,
    pub return_content: ::protobuf::SingularPtrField<ReturnContent>,
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PutRowRequest {
    fn default() -> &'a PutRowRequest {
        <PutRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl PutRowRequest {
    pub fn new() -> PutRowRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes row = 2;


    pub fn get_row(&self) -> &[u8] {
        match self.row.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::vec::Vec<u8>) {
        self.row = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row.is_none() {
            self.row.set_default();
        }
        self.row.as_mut().unwrap()
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::vec::Vec<u8> {
        self.row.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .proto.Condition condition = 3;


    pub fn get_condition(&self) -> &Condition {
        self.condition.as_ref().unwrap_or_else(|| <Condition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: Condition) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut Condition {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> Condition {
        self.condition.take().unwrap_or_else(|| Condition::new())
    }

    // optional .proto.ReturnContent return_content = 4;


    pub fn get_return_content(&self) -> &ReturnContent {
        self.return_content.as_ref().unwrap_or_else(|| <ReturnContent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_return_content(&mut self) {
        self.return_content.clear();
    }

    pub fn has_return_content(&self) -> bool {
        self.return_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_content(&mut self, v: ReturnContent) {
        self.return_content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_content(&mut self) -> &mut ReturnContent {
        if self.return_content.is_none() {
            self.return_content.set_default();
        }
        self.return_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_content(&mut self) -> ReturnContent {
        self.return_content.take().unwrap_or_else(|| ReturnContent::new())
    }

    // optional string transaction_id = 5;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PutRowRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        if self.row.is_none() {
            return false;
        }
        if self.condition.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.return_content)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.row.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.row.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutRowRequest {
        PutRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &PutRowRequest| { &m.table_name },
                |m: &mut PutRowRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row",
                |m: &PutRowRequest| { &m.row },
                |m: &mut PutRowRequest| { &mut m.row },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Condition>>(
                "condition",
                |m: &PutRowRequest| { &m.condition },
                |m: &mut PutRowRequest| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReturnContent>>(
                "return_content",
                |m: &PutRowRequest| { &m.return_content },
                |m: &mut PutRowRequest| { &mut m.return_content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &PutRowRequest| { &m.transaction_id },
                |m: &mut PutRowRequest| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PutRowRequest>(
                "PutRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PutRowRequest {
        static instance: ::protobuf::rt::LazyV2<PutRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PutRowRequest::new)
    }
}

impl ::protobuf::Clear for PutRowRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.row.clear();
        self.condition.clear();
        self.return_content.clear();
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PutRowResponse {
    // message fields
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    row: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PutRowResponse {
    fn default() -> &'a PutRowResponse {
        <PutRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl PutRowResponse {
    pub fn new() -> PutRowResponse {
        ::std::default::Default::default()
    }

    // required .proto.ConsumedCapacity consumed = 1;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // optional bytes row = 2;


    pub fn get_row(&self) -> &[u8] {
        match self.row.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::vec::Vec<u8>) {
        self.row = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row.is_none() {
            self.row.set_default();
        }
        self.row.as_mut().unwrap()
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::vec::Vec<u8> {
        self.row.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PutRowResponse {
    fn is_initialized(&self) -> bool {
        if self.consumed.is_none() {
            return false;
        }
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.row.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.row.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PutRowResponse {
        PutRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &PutRowResponse| { &m.consumed },
                |m: &mut PutRowResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row",
                |m: &PutRowResponse| { &m.row },
                |m: &mut PutRowResponse| { &mut m.row },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PutRowResponse>(
                "PutRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PutRowResponse {
        static instance: ::protobuf::rt::LazyV2<PutRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PutRowResponse::new)
    }
}

impl ::protobuf::Clear for PutRowResponse {
    fn clear(&mut self) {
        self.consumed.clear();
        self.row.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PutRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PutRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRowRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    primary_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub condition: ::protobuf::SingularPtrField<Condition>,
    pub return_content: ::protobuf::SingularPtrField<ReturnContent>,
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRowRequest {
    fn default() -> &'a DeleteRowRequest {
        <DeleteRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRowRequest {
    pub fn new() -> DeleteRowRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes primary_key = 2;


    pub fn get_primary_key(&self) -> &[u8] {
        match self.primary_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    pub fn has_primary_key(&self) -> bool {
        self.primary_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.primary_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.primary_key.is_none() {
            self.primary_key.set_default();
        }
        self.primary_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_primary_key(&mut self) -> ::std::vec::Vec<u8> {
        self.primary_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .proto.Condition condition = 3;


    pub fn get_condition(&self) -> &Condition {
        self.condition.as_ref().unwrap_or_else(|| <Condition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: Condition) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut Condition {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> Condition {
        self.condition.take().unwrap_or_else(|| Condition::new())
    }

    // optional .proto.ReturnContent return_content = 4;


    pub fn get_return_content(&self) -> &ReturnContent {
        self.return_content.as_ref().unwrap_or_else(|| <ReturnContent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_return_content(&mut self) {
        self.return_content.clear();
    }

    pub fn has_return_content(&self) -> bool {
        self.return_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_content(&mut self, v: ReturnContent) {
        self.return_content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_content(&mut self) -> &mut ReturnContent {
        if self.return_content.is_none() {
            self.return_content.set_default();
        }
        self.return_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_content(&mut self) -> ReturnContent {
        self.return_content.take().unwrap_or_else(|| ReturnContent::new())
    }

    // optional string transaction_id = 5;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteRowRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        if self.primary_key.is_none() {
            return false;
        }
        if self.condition.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.primary_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.return_content)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.primary_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.primary_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRowRequest {
        DeleteRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &DeleteRowRequest| { &m.table_name },
                |m: &mut DeleteRowRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "primary_key",
                |m: &DeleteRowRequest| { &m.primary_key },
                |m: &mut DeleteRowRequest| { &mut m.primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Condition>>(
                "condition",
                |m: &DeleteRowRequest| { &m.condition },
                |m: &mut DeleteRowRequest| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReturnContent>>(
                "return_content",
                |m: &DeleteRowRequest| { &m.return_content },
                |m: &mut DeleteRowRequest| { &mut m.return_content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &DeleteRowRequest| { &m.transaction_id },
                |m: &mut DeleteRowRequest| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRowRequest>(
                "DeleteRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRowRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRowRequest::new)
    }
}

impl ::protobuf::Clear for DeleteRowRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.primary_key.clear();
        self.condition.clear();
        self.return_content.clear();
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteRowResponse {
    // message fields
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    row: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteRowResponse {
    fn default() -> &'a DeleteRowResponse {
        <DeleteRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteRowResponse {
    pub fn new() -> DeleteRowResponse {
        ::std::default::Default::default()
    }

    // required .proto.ConsumedCapacity consumed = 1;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // optional bytes row = 2;


    pub fn get_row(&self) -> &[u8] {
        match self.row.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::vec::Vec<u8>) {
        self.row = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row.is_none() {
            self.row.set_default();
        }
        self.row.as_mut().unwrap()
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::vec::Vec<u8> {
        self.row.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DeleteRowResponse {
    fn is_initialized(&self) -> bool {
        if self.consumed.is_none() {
            return false;
        }
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.row.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.row.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteRowResponse {
        DeleteRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &DeleteRowResponse| { &m.consumed },
                |m: &mut DeleteRowResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row",
                |m: &DeleteRowResponse| { &m.row },
                |m: &mut DeleteRowResponse| { &mut m.row },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteRowResponse>(
                "DeleteRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteRowResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteRowResponse::new)
    }
}

impl ::protobuf::Clear for DeleteRowResponse {
    fn clear(&mut self) {
        self.consumed.clear();
        self.row.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableInBatchGetRowRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub primary_key: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub token: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub columns_to_get: ::protobuf::RepeatedField<::std::string::String>,
    pub time_range: ::protobuf::SingularPtrField<TimeRange>,
    max_versions: ::std::option::Option<i32>,
    cache_blocks: ::std::option::Option<bool>,
    filter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    start_column: ::protobuf::SingularField<::std::string::String>,
    end_column: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableInBatchGetRowRequest {
    fn default() -> &'a TableInBatchGetRowRequest {
        <TableInBatchGetRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl TableInBatchGetRowRequest {
    pub fn new() -> TableInBatchGetRowRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated bytes primary_key = 2;


    pub fn get_primary_key(&self) -> &[::std::vec::Vec<u8>] {
        &self.primary_key
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.primary_key = v;
    }

    // Mutable pointer to the field.
    pub fn mut_primary_key(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.primary_key
    }

    // Take field
    pub fn take_primary_key(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.primary_key, ::protobuf::RepeatedField::new())
    }

    // repeated bytes token = 3;


    pub fn get_token(&self) -> &[::std::vec::Vec<u8>] {
        &self.token
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.token = v;
    }

    // Mutable pointer to the field.
    pub fn mut_token(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.token
    }

    // Take field
    pub fn take_token(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.token, ::protobuf::RepeatedField::new())
    }

    // repeated string columns_to_get = 4;


    pub fn get_columns_to_get(&self) -> &[::std::string::String] {
        &self.columns_to_get
    }
    pub fn clear_columns_to_get(&mut self) {
        self.columns_to_get.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns_to_get(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.columns_to_get = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns_to_get(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.columns_to_get
    }

    // Take field
    pub fn take_columns_to_get(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.columns_to_get, ::protobuf::RepeatedField::new())
    }

    // optional .proto.TimeRange time_range = 5;


    pub fn get_time_range(&self) -> &TimeRange {
        self.time_range.as_ref().unwrap_or_else(|| <TimeRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_range(&mut self) {
        self.time_range.clear();
    }

    pub fn has_time_range(&self) -> bool {
        self.time_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_range(&mut self, v: TimeRange) {
        self.time_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_range(&mut self) -> &mut TimeRange {
        if self.time_range.is_none() {
            self.time_range.set_default();
        }
        self.time_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_range(&mut self) -> TimeRange {
        self.time_range.take().unwrap_or_else(|| TimeRange::new())
    }

    // optional int32 max_versions = 6;


    pub fn get_max_versions(&self) -> i32 {
        self.max_versions.unwrap_or(0)
    }
    pub fn clear_max_versions(&mut self) {
        self.max_versions = ::std::option::Option::None;
    }

    pub fn has_max_versions(&self) -> bool {
        self.max_versions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_versions(&mut self, v: i32) {
        self.max_versions = ::std::option::Option::Some(v);
    }

    // optional bool cache_blocks = 7;


    pub fn get_cache_blocks(&self) -> bool {
        self.cache_blocks.unwrap_or(true)
    }
    pub fn clear_cache_blocks(&mut self) {
        self.cache_blocks = ::std::option::Option::None;
    }

    pub fn has_cache_blocks(&self) -> bool {
        self.cache_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_blocks(&mut self, v: bool) {
        self.cache_blocks = ::std::option::Option::Some(v);
    }

    // optional bytes filter = 8;


    pub fn get_filter(&self) -> &[u8] {
        match self.filter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::vec::Vec<u8> {
        self.filter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string start_column = 9;


    pub fn get_start_column(&self) -> &str {
        match self.start_column.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_start_column(&mut self) {
        self.start_column.clear();
    }

    pub fn has_start_column(&self) -> bool {
        self.start_column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_column(&mut self, v: ::std::string::String) {
        self.start_column = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_column(&mut self) -> &mut ::std::string::String {
        if self.start_column.is_none() {
            self.start_column.set_default();
        }
        self.start_column.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_column(&mut self) -> ::std::string::String {
        self.start_column.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string end_column = 10;


    pub fn get_end_column(&self) -> &str {
        match self.end_column.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_end_column(&mut self) {
        self.end_column.clear();
    }

    pub fn has_end_column(&self) -> bool {
        self.end_column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_column(&mut self, v: ::std::string::String) {
        self.end_column = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_column(&mut self) -> &mut ::std::string::String {
        if self.end_column.is_none() {
            self.end_column.set_default();
        }
        self.end_column.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_column(&mut self) -> ::std::string::String {
        self.end_column.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TableInBatchGetRowRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        for v in &self.time_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.primary_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.token)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.columns_to_get)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_range)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_versions = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cache_blocks = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.filter)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.start_column)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.end_column)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.primary_key {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        for value in &self.token {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in &self.columns_to_get {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.time_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.max_versions {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cache_blocks {
            my_size += 2;
        }
        if let Some(ref v) = self.filter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.start_column.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.end_column.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.primary_key {
            os.write_bytes(2, &v)?;
        };
        for v in &self.token {
            os.write_bytes(3, &v)?;
        };
        for v in &self.columns_to_get {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.time_range.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.max_versions {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.cache_blocks {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.start_column.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.end_column.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableInBatchGetRowRequest {
        TableInBatchGetRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &TableInBatchGetRowRequest| { &m.table_name },
                |m: &mut TableInBatchGetRowRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "primary_key",
                |m: &TableInBatchGetRowRequest| { &m.primary_key },
                |m: &mut TableInBatchGetRowRequest| { &mut m.primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &TableInBatchGetRowRequest| { &m.token },
                |m: &mut TableInBatchGetRowRequest| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columns_to_get",
                |m: &TableInBatchGetRowRequest| { &m.columns_to_get },
                |m: &mut TableInBatchGetRowRequest| { &mut m.columns_to_get },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeRange>>(
                "time_range",
                |m: &TableInBatchGetRowRequest| { &m.time_range },
                |m: &mut TableInBatchGetRowRequest| { &mut m.time_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_versions",
                |m: &TableInBatchGetRowRequest| { &m.max_versions },
                |m: &mut TableInBatchGetRowRequest| { &mut m.max_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cache_blocks",
                |m: &TableInBatchGetRowRequest| { &m.cache_blocks },
                |m: &mut TableInBatchGetRowRequest| { &mut m.cache_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "filter",
                |m: &TableInBatchGetRowRequest| { &m.filter },
                |m: &mut TableInBatchGetRowRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start_column",
                |m: &TableInBatchGetRowRequest| { &m.start_column },
                |m: &mut TableInBatchGetRowRequest| { &mut m.start_column },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "end_column",
                |m: &TableInBatchGetRowRequest| { &m.end_column },
                |m: &mut TableInBatchGetRowRequest| { &mut m.end_column },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableInBatchGetRowRequest>(
                "TableInBatchGetRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableInBatchGetRowRequest {
        static instance: ::protobuf::rt::LazyV2<TableInBatchGetRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableInBatchGetRowRequest::new)
    }
}

impl ::protobuf::Clear for TableInBatchGetRowRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.primary_key.clear();
        self.token.clear();
        self.columns_to_get.clear();
        self.time_range.clear();
        self.max_versions = ::std::option::Option::None;
        self.cache_blocks = ::std::option::Option::None;
        self.filter.clear();
        self.start_column.clear();
        self.end_column.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableInBatchGetRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableInBatchGetRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetRowRequest {
    // message fields
    pub tables: ::protobuf::RepeatedField<TableInBatchGetRowRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetRowRequest {
    fn default() -> &'a BatchGetRowRequest {
        <BatchGetRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetRowRequest {
    pub fn new() -> BatchGetRowRequest {
        ::std::default::Default::default()
    }

    // repeated .proto.TableInBatchGetRowRequest tables = 1;


    pub fn get_tables(&self) -> &[TableInBatchGetRowRequest] {
        &self.tables
    }
    pub fn clear_tables(&mut self) {
        self.tables.clear();
    }

    // Param is passed by value, moved
    pub fn set_tables(&mut self, v: ::protobuf::RepeatedField<TableInBatchGetRowRequest>) {
        self.tables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tables(&mut self) -> &mut ::protobuf::RepeatedField<TableInBatchGetRowRequest> {
        &mut self.tables
    }

    // Take field
    pub fn take_tables(&mut self) -> ::protobuf::RepeatedField<TableInBatchGetRowRequest> {
        ::std::mem::replace(&mut self.tables, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetRowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tables)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tables {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetRowRequest {
        BatchGetRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableInBatchGetRowRequest>>(
                "tables",
                |m: &BatchGetRowRequest| { &m.tables },
                |m: &mut BatchGetRowRequest| { &mut m.tables },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetRowRequest>(
                "BatchGetRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetRowRequest {
        static instance: ::protobuf::rt::LazyV2<BatchGetRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetRowRequest::new)
    }
}

impl ::protobuf::Clear for BatchGetRowRequest {
    fn clear(&mut self) {
        self.tables.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowInBatchGetRowResponse {
    // message fields
    is_ok: ::std::option::Option<bool>,
    pub error: ::protobuf::SingularPtrField<Error>,
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    row: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    next_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowInBatchGetRowResponse {
    fn default() -> &'a RowInBatchGetRowResponse {
        <RowInBatchGetRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl RowInBatchGetRowResponse {
    pub fn new() -> RowInBatchGetRowResponse {
        ::std::default::Default::default()
    }

    // required bool is_ok = 1;


    pub fn get_is_ok(&self) -> bool {
        self.is_ok.unwrap_or(false)
    }
    pub fn clear_is_ok(&mut self) {
        self.is_ok = ::std::option::Option::None;
    }

    pub fn has_is_ok(&self) -> bool {
        self.is_ok.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ok(&mut self, v: bool) {
        self.is_ok = ::std::option::Option::Some(v);
    }

    // optional .proto.Error error = 2;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| <Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }

    // optional .proto.ConsumedCapacity consumed = 3;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // optional bytes row = 4;


    pub fn get_row(&self) -> &[u8] {
        match self.row.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::vec::Vec<u8>) {
        self.row = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row.is_none() {
            self.row.set_default();
        }
        self.row.as_mut().unwrap()
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::vec::Vec<u8> {
        self.row.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes next_token = 5;


    pub fn get_next_token(&self) -> &[u8] {
        match self.next_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_next_token(&mut self) {
        self.next_token.clear();
    }

    pub fn has_next_token(&self) -> bool {
        self.next_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.next_token.is_none() {
            self.next_token.set_default();
        }
        self.next_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_token(&mut self) -> ::std::vec::Vec<u8> {
        self.next_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RowInBatchGetRowResponse {
    fn is_initialized(&self) -> bool {
        if self.is_ok.is_none() {
            return false;
        }
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_ok = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.next_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_ok {
            my_size += 2;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.row.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.next_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_ok {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.row.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.next_token.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowInBatchGetRowResponse {
        RowInBatchGetRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_ok",
                |m: &RowInBatchGetRowResponse| { &m.is_ok },
                |m: &mut RowInBatchGetRowResponse| { &mut m.is_ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                "error",
                |m: &RowInBatchGetRowResponse| { &m.error },
                |m: &mut RowInBatchGetRowResponse| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &RowInBatchGetRowResponse| { &m.consumed },
                |m: &mut RowInBatchGetRowResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row",
                |m: &RowInBatchGetRowResponse| { &m.row },
                |m: &mut RowInBatchGetRowResponse| { &mut m.row },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_token",
                |m: &RowInBatchGetRowResponse| { &m.next_token },
                |m: &mut RowInBatchGetRowResponse| { &mut m.next_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowInBatchGetRowResponse>(
                "RowInBatchGetRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowInBatchGetRowResponse {
        static instance: ::protobuf::rt::LazyV2<RowInBatchGetRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowInBatchGetRowResponse::new)
    }
}

impl ::protobuf::Clear for RowInBatchGetRowResponse {
    fn clear(&mut self) {
        self.is_ok = ::std::option::Option::None;
        self.error.clear();
        self.consumed.clear();
        self.row.clear();
        self.next_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowInBatchGetRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowInBatchGetRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableInBatchGetRowResponse {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub rows: ::protobuf::RepeatedField<RowInBatchGetRowResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableInBatchGetRowResponse {
    fn default() -> &'a TableInBatchGetRowResponse {
        <TableInBatchGetRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl TableInBatchGetRowResponse {
    pub fn new() -> TableInBatchGetRowResponse {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .proto.RowInBatchGetRowResponse rows = 2;


    pub fn get_rows(&self) -> &[RowInBatchGetRowResponse] {
        &self.rows
    }
    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::protobuf::RepeatedField<RowInBatchGetRowResponse>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows(&mut self) -> &mut ::protobuf::RepeatedField<RowInBatchGetRowResponse> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::protobuf::RepeatedField<RowInBatchGetRowResponse> {
        ::std::mem::replace(&mut self.rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TableInBatchGetRowResponse {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        for v in &self.rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.rows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableInBatchGetRowResponse {
        TableInBatchGetRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &TableInBatchGetRowResponse| { &m.table_name },
                |m: &mut TableInBatchGetRowResponse| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowInBatchGetRowResponse>>(
                "rows",
                |m: &TableInBatchGetRowResponse| { &m.rows },
                |m: &mut TableInBatchGetRowResponse| { &mut m.rows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableInBatchGetRowResponse>(
                "TableInBatchGetRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableInBatchGetRowResponse {
        static instance: ::protobuf::rt::LazyV2<TableInBatchGetRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableInBatchGetRowResponse::new)
    }
}

impl ::protobuf::Clear for TableInBatchGetRowResponse {
    fn clear(&mut self) {
        self.table_name.clear();
        self.rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableInBatchGetRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableInBatchGetRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetRowResponse {
    // message fields
    pub tables: ::protobuf::RepeatedField<TableInBatchGetRowResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchGetRowResponse {
    fn default() -> &'a BatchGetRowResponse {
        <BatchGetRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchGetRowResponse {
    pub fn new() -> BatchGetRowResponse {
        ::std::default::Default::default()
    }

    // repeated .proto.TableInBatchGetRowResponse tables = 1;


    pub fn get_tables(&self) -> &[TableInBatchGetRowResponse] {
        &self.tables
    }
    pub fn clear_tables(&mut self) {
        self.tables.clear();
    }

    // Param is passed by value, moved
    pub fn set_tables(&mut self, v: ::protobuf::RepeatedField<TableInBatchGetRowResponse>) {
        self.tables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tables(&mut self) -> &mut ::protobuf::RepeatedField<TableInBatchGetRowResponse> {
        &mut self.tables
    }

    // Take field
    pub fn take_tables(&mut self) -> ::protobuf::RepeatedField<TableInBatchGetRowResponse> {
        ::std::mem::replace(&mut self.tables, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchGetRowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tables)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tables {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetRowResponse {
        BatchGetRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableInBatchGetRowResponse>>(
                "tables",
                |m: &BatchGetRowResponse| { &m.tables },
                |m: &mut BatchGetRowResponse| { &mut m.tables },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchGetRowResponse>(
                "BatchGetRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchGetRowResponse {
        static instance: ::protobuf::rt::LazyV2<BatchGetRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchGetRowResponse::new)
    }
}

impl ::protobuf::Clear for BatchGetRowResponse {
    fn clear(&mut self) {
        self.tables.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowInBatchWriteRowRequest {
    // message fields
    field_type: ::std::option::Option<OperationType>,
    row_change: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub condition: ::protobuf::SingularPtrField<Condition>,
    pub return_content: ::protobuf::SingularPtrField<ReturnContent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowInBatchWriteRowRequest {
    fn default() -> &'a RowInBatchWriteRowRequest {
        <RowInBatchWriteRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl RowInBatchWriteRowRequest {
    pub fn new() -> RowInBatchWriteRowRequest {
        ::std::default::Default::default()
    }

    // required .proto.OperationType type = 1;


    pub fn get_field_type(&self) -> OperationType {
        self.field_type.unwrap_or(OperationType::PUT)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: OperationType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required bytes row_change = 2;


    pub fn get_row_change(&self) -> &[u8] {
        match self.row_change.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row_change(&mut self) {
        self.row_change.clear();
    }

    pub fn has_row_change(&self) -> bool {
        self.row_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row_change(&mut self, v: ::std::vec::Vec<u8>) {
        self.row_change = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row_change(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row_change.is_none() {
            self.row_change.set_default();
        }
        self.row_change.as_mut().unwrap()
    }

    // Take field
    pub fn take_row_change(&mut self) -> ::std::vec::Vec<u8> {
        self.row_change.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required .proto.Condition condition = 3;


    pub fn get_condition(&self) -> &Condition {
        self.condition.as_ref().unwrap_or_else(|| <Condition as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: Condition) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut Condition {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> Condition {
        self.condition.take().unwrap_or_else(|| Condition::new())
    }

    // optional .proto.ReturnContent return_content = 4;


    pub fn get_return_content(&self) -> &ReturnContent {
        self.return_content.as_ref().unwrap_or_else(|| <ReturnContent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_return_content(&mut self) {
        self.return_content.clear();
    }

    pub fn has_return_content(&self) -> bool {
        self.return_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_content(&mut self, v: ReturnContent) {
        self.return_content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_content(&mut self) -> &mut ReturnContent {
        if self.return_content.is_none() {
            self.return_content.set_default();
        }
        self.return_content.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_content(&mut self) -> ReturnContent {
        self.return_content.take().unwrap_or_else(|| ReturnContent::new())
    }
}

impl ::protobuf::Message for RowInBatchWriteRowRequest {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.row_change.is_none() {
            return false;
        }
        if self.condition.is_none() {
            return false;
        }
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row_change)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.return_content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.row_change.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.row_change.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.return_content.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowInBatchWriteRowRequest {
        RowInBatchWriteRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperationType>>(
                "type",
                |m: &RowInBatchWriteRowRequest| { &m.field_type },
                |m: &mut RowInBatchWriteRowRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row_change",
                |m: &RowInBatchWriteRowRequest| { &m.row_change },
                |m: &mut RowInBatchWriteRowRequest| { &mut m.row_change },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Condition>>(
                "condition",
                |m: &RowInBatchWriteRowRequest| { &m.condition },
                |m: &mut RowInBatchWriteRowRequest| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReturnContent>>(
                "return_content",
                |m: &RowInBatchWriteRowRequest| { &m.return_content },
                |m: &mut RowInBatchWriteRowRequest| { &mut m.return_content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowInBatchWriteRowRequest>(
                "RowInBatchWriteRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowInBatchWriteRowRequest {
        static instance: ::protobuf::rt::LazyV2<RowInBatchWriteRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowInBatchWriteRowRequest::new)
    }
}

impl ::protobuf::Clear for RowInBatchWriteRowRequest {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.row_change.clear();
        self.condition.clear();
        self.return_content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowInBatchWriteRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowInBatchWriteRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableInBatchWriteRowRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub rows: ::protobuf::RepeatedField<RowInBatchWriteRowRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableInBatchWriteRowRequest {
    fn default() -> &'a TableInBatchWriteRowRequest {
        <TableInBatchWriteRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl TableInBatchWriteRowRequest {
    pub fn new() -> TableInBatchWriteRowRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .proto.RowInBatchWriteRowRequest rows = 2;


    pub fn get_rows(&self) -> &[RowInBatchWriteRowRequest] {
        &self.rows
    }
    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::protobuf::RepeatedField<RowInBatchWriteRowRequest>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows(&mut self) -> &mut ::protobuf::RepeatedField<RowInBatchWriteRowRequest> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::protobuf::RepeatedField<RowInBatchWriteRowRequest> {
        ::std::mem::replace(&mut self.rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TableInBatchWriteRowRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        for v in &self.rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.rows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableInBatchWriteRowRequest {
        TableInBatchWriteRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &TableInBatchWriteRowRequest| { &m.table_name },
                |m: &mut TableInBatchWriteRowRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowInBatchWriteRowRequest>>(
                "rows",
                |m: &TableInBatchWriteRowRequest| { &m.rows },
                |m: &mut TableInBatchWriteRowRequest| { &mut m.rows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableInBatchWriteRowRequest>(
                "TableInBatchWriteRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableInBatchWriteRowRequest {
        static instance: ::protobuf::rt::LazyV2<TableInBatchWriteRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableInBatchWriteRowRequest::new)
    }
}

impl ::protobuf::Clear for TableInBatchWriteRowRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableInBatchWriteRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableInBatchWriteRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchWriteRowRequest {
    // message fields
    pub tables: ::protobuf::RepeatedField<TableInBatchWriteRowRequest>,
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    is_atomic: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchWriteRowRequest {
    fn default() -> &'a BatchWriteRowRequest {
        <BatchWriteRowRequest as ::protobuf::Message>::default_instance()
    }
}

impl BatchWriteRowRequest {
    pub fn new() -> BatchWriteRowRequest {
        ::std::default::Default::default()
    }

    // repeated .proto.TableInBatchWriteRowRequest tables = 1;


    pub fn get_tables(&self) -> &[TableInBatchWriteRowRequest] {
        &self.tables
    }
    pub fn clear_tables(&mut self) {
        self.tables.clear();
    }

    // Param is passed by value, moved
    pub fn set_tables(&mut self, v: ::protobuf::RepeatedField<TableInBatchWriteRowRequest>) {
        self.tables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tables(&mut self) -> &mut ::protobuf::RepeatedField<TableInBatchWriteRowRequest> {
        &mut self.tables
    }

    // Take field
    pub fn take_tables(&mut self) -> ::protobuf::RepeatedField<TableInBatchWriteRowRequest> {
        ::std::mem::replace(&mut self.tables, ::protobuf::RepeatedField::new())
    }

    // optional string transaction_id = 2;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_atomic = 3;


    pub fn get_is_atomic(&self) -> bool {
        self.is_atomic.unwrap_or(false)
    }
    pub fn clear_is_atomic(&mut self) {
        self.is_atomic = ::std::option::Option::None;
    }

    pub fn has_is_atomic(&self) -> bool {
        self.is_atomic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_atomic(&mut self, v: bool) {
        self.is_atomic = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BatchWriteRowRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tables)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_atomic = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_atomic {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tables {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.is_atomic {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchWriteRowRequest {
        BatchWriteRowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableInBatchWriteRowRequest>>(
                "tables",
                |m: &BatchWriteRowRequest| { &m.tables },
                |m: &mut BatchWriteRowRequest| { &mut m.tables },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &BatchWriteRowRequest| { &m.transaction_id },
                |m: &mut BatchWriteRowRequest| { &mut m.transaction_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_atomic",
                |m: &BatchWriteRowRequest| { &m.is_atomic },
                |m: &mut BatchWriteRowRequest| { &mut m.is_atomic },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchWriteRowRequest>(
                "BatchWriteRowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchWriteRowRequest {
        static instance: ::protobuf::rt::LazyV2<BatchWriteRowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchWriteRowRequest::new)
    }
}

impl ::protobuf::Clear for BatchWriteRowRequest {
    fn clear(&mut self) {
        self.tables.clear();
        self.transaction_id.clear();
        self.is_atomic = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchWriteRowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchWriteRowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RowInBatchWriteRowResponse {
    // message fields
    is_ok: ::std::option::Option<bool>,
    pub error: ::protobuf::SingularPtrField<Error>,
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    row: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RowInBatchWriteRowResponse {
    fn default() -> &'a RowInBatchWriteRowResponse {
        <RowInBatchWriteRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl RowInBatchWriteRowResponse {
    pub fn new() -> RowInBatchWriteRowResponse {
        ::std::default::Default::default()
    }

    // required bool is_ok = 1;


    pub fn get_is_ok(&self) -> bool {
        self.is_ok.unwrap_or(false)
    }
    pub fn clear_is_ok(&mut self) {
        self.is_ok = ::std::option::Option::None;
    }

    pub fn has_is_ok(&self) -> bool {
        self.is_ok.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_ok(&mut self, v: bool) {
        self.is_ok = ::std::option::Option::Some(v);
    }

    // optional .proto.Error error = 2;


    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| <Error as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }

    // optional .proto.ConsumedCapacity consumed = 3;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // optional bytes row = 4;


    pub fn get_row(&self) -> &[u8] {
        match self.row.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_row(&mut self) {
        self.row.clear();
    }

    pub fn has_row(&self) -> bool {
        self.row.is_some()
    }

    // Param is passed by value, moved
    pub fn set_row(&mut self, v: ::std::vec::Vec<u8>) {
        self.row = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_row(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.row.is_none() {
            self.row.set_default();
        }
        self.row.as_mut().unwrap()
    }

    // Take field
    pub fn take_row(&mut self) -> ::std::vec::Vec<u8> {
        self.row.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RowInBatchWriteRowResponse {
    fn is_initialized(&self) -> bool {
        if self.is_ok.is_none() {
            return false;
        }
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_ok = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.row)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.is_ok {
            my_size += 2;
        }
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.row.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_ok {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.row.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RowInBatchWriteRowResponse {
        RowInBatchWriteRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_ok",
                |m: &RowInBatchWriteRowResponse| { &m.is_ok },
                |m: &mut RowInBatchWriteRowResponse| { &mut m.is_ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                "error",
                |m: &RowInBatchWriteRowResponse| { &m.error },
                |m: &mut RowInBatchWriteRowResponse| { &mut m.error },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &RowInBatchWriteRowResponse| { &m.consumed },
                |m: &mut RowInBatchWriteRowResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "row",
                |m: &RowInBatchWriteRowResponse| { &m.row },
                |m: &mut RowInBatchWriteRowResponse| { &mut m.row },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RowInBatchWriteRowResponse>(
                "RowInBatchWriteRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RowInBatchWriteRowResponse {
        static instance: ::protobuf::rt::LazyV2<RowInBatchWriteRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RowInBatchWriteRowResponse::new)
    }
}

impl ::protobuf::Clear for RowInBatchWriteRowResponse {
    fn clear(&mut self) {
        self.is_ok = ::std::option::Option::None;
        self.error.clear();
        self.consumed.clear();
        self.row.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RowInBatchWriteRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowInBatchWriteRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableInBatchWriteRowResponse {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub rows: ::protobuf::RepeatedField<RowInBatchWriteRowResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableInBatchWriteRowResponse {
    fn default() -> &'a TableInBatchWriteRowResponse {
        <TableInBatchWriteRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl TableInBatchWriteRowResponse {
    pub fn new() -> TableInBatchWriteRowResponse {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .proto.RowInBatchWriteRowResponse rows = 2;


    pub fn get_rows(&self) -> &[RowInBatchWriteRowResponse] {
        &self.rows
    }
    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::protobuf::RepeatedField<RowInBatchWriteRowResponse>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows(&mut self) -> &mut ::protobuf::RepeatedField<RowInBatchWriteRowResponse> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::protobuf::RepeatedField<RowInBatchWriteRowResponse> {
        ::std::mem::replace(&mut self.rows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TableInBatchWriteRowResponse {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        for v in &self.rows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.rows {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableInBatchWriteRowResponse {
        TableInBatchWriteRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &TableInBatchWriteRowResponse| { &m.table_name },
                |m: &mut TableInBatchWriteRowResponse| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RowInBatchWriteRowResponse>>(
                "rows",
                |m: &TableInBatchWriteRowResponse| { &m.rows },
                |m: &mut TableInBatchWriteRowResponse| { &mut m.rows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableInBatchWriteRowResponse>(
                "TableInBatchWriteRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableInBatchWriteRowResponse {
        static instance: ::protobuf::rt::LazyV2<TableInBatchWriteRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableInBatchWriteRowResponse::new)
    }
}

impl ::protobuf::Clear for TableInBatchWriteRowResponse {
    fn clear(&mut self) {
        self.table_name.clear();
        self.rows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableInBatchWriteRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableInBatchWriteRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchWriteRowResponse {
    // message fields
    pub tables: ::protobuf::RepeatedField<TableInBatchWriteRowResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchWriteRowResponse {
    fn default() -> &'a BatchWriteRowResponse {
        <BatchWriteRowResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatchWriteRowResponse {
    pub fn new() -> BatchWriteRowResponse {
        ::std::default::Default::default()
    }

    // repeated .proto.TableInBatchWriteRowResponse tables = 1;


    pub fn get_tables(&self) -> &[TableInBatchWriteRowResponse] {
        &self.tables
    }
    pub fn clear_tables(&mut self) {
        self.tables.clear();
    }

    // Param is passed by value, moved
    pub fn set_tables(&mut self, v: ::protobuf::RepeatedField<TableInBatchWriteRowResponse>) {
        self.tables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tables(&mut self) -> &mut ::protobuf::RepeatedField<TableInBatchWriteRowResponse> {
        &mut self.tables
    }

    // Take field
    pub fn take_tables(&mut self) -> ::protobuf::RepeatedField<TableInBatchWriteRowResponse> {
        ::std::mem::replace(&mut self.tables, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchWriteRowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tables)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tables {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchWriteRowResponse {
        BatchWriteRowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TableInBatchWriteRowResponse>>(
                "tables",
                |m: &BatchWriteRowResponse| { &m.tables },
                |m: &mut BatchWriteRowResponse| { &mut m.tables },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchWriteRowResponse>(
                "BatchWriteRowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BatchWriteRowResponse {
        static instance: ::protobuf::rt::LazyV2<BatchWriteRowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BatchWriteRowResponse::new)
    }
}

impl ::protobuf::Clear for BatchWriteRowResponse {
    fn clear(&mut self) {
        self.tables.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchWriteRowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchWriteRowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRangeRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    direction: ::std::option::Option<Direction>,
    pub columns_to_get: ::protobuf::RepeatedField<::std::string::String>,
    pub time_range: ::protobuf::SingularPtrField<TimeRange>,
    max_versions: ::std::option::Option<i32>,
    limit: ::std::option::Option<i32>,
    inclusive_start_primary_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    exclusive_end_primary_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    cache_blocks: ::std::option::Option<bool>,
    filter: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    start_column: ::protobuf::SingularField<::std::string::String>,
    end_column: ::protobuf::SingularField<::std::string::String>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRangeRequest {
    fn default() -> &'a GetRangeRequest {
        <GetRangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRangeRequest {
    pub fn new() -> GetRangeRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .proto.Direction direction = 2;


    pub fn get_direction(&self) -> Direction {
        self.direction.unwrap_or(Direction::FORWARD)
    }
    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: Direction) {
        self.direction = ::std::option::Option::Some(v);
    }

    // repeated string columns_to_get = 3;


    pub fn get_columns_to_get(&self) -> &[::std::string::String] {
        &self.columns_to_get
    }
    pub fn clear_columns_to_get(&mut self) {
        self.columns_to_get.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns_to_get(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.columns_to_get = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns_to_get(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.columns_to_get
    }

    // Take field
    pub fn take_columns_to_get(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.columns_to_get, ::protobuf::RepeatedField::new())
    }

    // optional .proto.TimeRange time_range = 4;


    pub fn get_time_range(&self) -> &TimeRange {
        self.time_range.as_ref().unwrap_or_else(|| <TimeRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_range(&mut self) {
        self.time_range.clear();
    }

    pub fn has_time_range(&self) -> bool {
        self.time_range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_range(&mut self, v: TimeRange) {
        self.time_range = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_range(&mut self) -> &mut TimeRange {
        if self.time_range.is_none() {
            self.time_range.set_default();
        }
        self.time_range.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_range(&mut self) -> TimeRange {
        self.time_range.take().unwrap_or_else(|| TimeRange::new())
    }

    // optional int32 max_versions = 5;


    pub fn get_max_versions(&self) -> i32 {
        self.max_versions.unwrap_or(0)
    }
    pub fn clear_max_versions(&mut self) {
        self.max_versions = ::std::option::Option::None;
    }

    pub fn has_max_versions(&self) -> bool {
        self.max_versions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_versions(&mut self, v: i32) {
        self.max_versions = ::std::option::Option::Some(v);
    }

    // optional int32 limit = 6;


    pub fn get_limit(&self) -> i32 {
        self.limit.unwrap_or(0)
    }
    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = ::std::option::Option::Some(v);
    }

    // required bytes inclusive_start_primary_key = 7;


    pub fn get_inclusive_start_primary_key(&self) -> &[u8] {
        match self.inclusive_start_primary_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_inclusive_start_primary_key(&mut self) {
        self.inclusive_start_primary_key.clear();
    }

    pub fn has_inclusive_start_primary_key(&self) -> bool {
        self.inclusive_start_primary_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inclusive_start_primary_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.inclusive_start_primary_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inclusive_start_primary_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.inclusive_start_primary_key.is_none() {
            self.inclusive_start_primary_key.set_default();
        }
        self.inclusive_start_primary_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_inclusive_start_primary_key(&mut self) -> ::std::vec::Vec<u8> {
        self.inclusive_start_primary_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes exclusive_end_primary_key = 8;


    pub fn get_exclusive_end_primary_key(&self) -> &[u8] {
        match self.exclusive_end_primary_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_exclusive_end_primary_key(&mut self) {
        self.exclusive_end_primary_key.clear();
    }

    pub fn has_exclusive_end_primary_key(&self) -> bool {
        self.exclusive_end_primary_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exclusive_end_primary_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.exclusive_end_primary_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exclusive_end_primary_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.exclusive_end_primary_key.is_none() {
            self.exclusive_end_primary_key.set_default();
        }
        self.exclusive_end_primary_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_exclusive_end_primary_key(&mut self) -> ::std::vec::Vec<u8> {
        self.exclusive_end_primary_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool cache_blocks = 9;


    pub fn get_cache_blocks(&self) -> bool {
        self.cache_blocks.unwrap_or(true)
    }
    pub fn clear_cache_blocks(&mut self) {
        self.cache_blocks = ::std::option::Option::None;
    }

    pub fn has_cache_blocks(&self) -> bool {
        self.cache_blocks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_blocks(&mut self, v: bool) {
        self.cache_blocks = ::std::option::Option::Some(v);
    }

    // optional bytes filter = 10;


    pub fn get_filter(&self) -> &[u8] {
        match self.filter.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::vec::Vec<u8>) {
        self.filter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::vec::Vec<u8> {
        self.filter.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string start_column = 11;


    pub fn get_start_column(&self) -> &str {
        match self.start_column.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_start_column(&mut self) {
        self.start_column.clear();
    }

    pub fn has_start_column(&self) -> bool {
        self.start_column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_column(&mut self, v: ::std::string::String) {
        self.start_column = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_column(&mut self) -> &mut ::std::string::String {
        if self.start_column.is_none() {
            self.start_column.set_default();
        }
        self.start_column.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_column(&mut self) -> ::std::string::String {
        self.start_column.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string end_column = 12;


    pub fn get_end_column(&self) -> &str {
        match self.end_column.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_end_column(&mut self) {
        self.end_column.clear();
    }

    pub fn has_end_column(&self) -> bool {
        self.end_column.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_column(&mut self, v: ::std::string::String) {
        self.end_column = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_column(&mut self) -> &mut ::std::string::String {
        if self.end_column.is_none() {
            self.end_column.set_default();
        }
        self.end_column.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_column(&mut self) -> ::std::string::String {
        self.end_column.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes token = 13;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string transaction_id = 14;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetRangeRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        if self.direction.is_none() {
            return false;
        }
        if self.inclusive_start_primary_key.is_none() {
            return false;
        }
        if self.exclusive_end_primary_key.is_none() {
            return false;
        }
        for v in &self.time_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.columns_to_get)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_range)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_versions = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.inclusive_start_primary_key)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.exclusive_end_primary_key)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cache_blocks = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.filter)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.start_column)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.end_column)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.direction {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        for value in &self.columns_to_get {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.time_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.max_versions {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.inclusive_start_primary_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.exclusive_end_primary_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.cache_blocks {
            my_size += 2;
        }
        if let Some(ref v) = self.filter.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(ref v) = self.start_column.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.end_column.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.direction {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.columns_to_get {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.time_range.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.max_versions {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.limit {
            os.write_int32(6, v)?;
        }
        if let Some(ref v) = self.inclusive_start_primary_key.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.exclusive_end_primary_key.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(v) = self.cache_blocks {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.filter.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(ref v) = self.start_column.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.end_column.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(13, &v)?;
        }
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(14, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRangeRequest {
        GetRangeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &GetRangeRequest| { &m.table_name },
                |m: &mut GetRangeRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Direction>>(
                "direction",
                |m: &GetRangeRequest| { &m.direction },
                |m: &mut GetRangeRequest| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columns_to_get",
                |m: &GetRangeRequest| { &m.columns_to_get },
                |m: &mut GetRangeRequest| { &mut m.columns_to_get },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeRange>>(
                "time_range",
                |m: &GetRangeRequest| { &m.time_range },
                |m: &mut GetRangeRequest| { &mut m.time_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_versions",
                |m: &GetRangeRequest| { &m.max_versions },
                |m: &mut GetRangeRequest| { &mut m.max_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "limit",
                |m: &GetRangeRequest| { &m.limit },
                |m: &mut GetRangeRequest| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "inclusive_start_primary_key",
                |m: &GetRangeRequest| { &m.inclusive_start_primary_key },
                |m: &mut GetRangeRequest| { &mut m.inclusive_start_primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "exclusive_end_primary_key",
                |m: &GetRangeRequest| { &m.exclusive_end_primary_key },
                |m: &mut GetRangeRequest| { &mut m.exclusive_end_primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "cache_blocks",
                |m: &GetRangeRequest| { &m.cache_blocks },
                |m: &mut GetRangeRequest| { &mut m.cache_blocks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "filter",
                |m: &GetRangeRequest| { &m.filter },
                |m: &mut GetRangeRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start_column",
                |m: &GetRangeRequest| { &m.start_column },
                |m: &mut GetRangeRequest| { &mut m.start_column },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "end_column",
                |m: &GetRangeRequest| { &m.end_column },
                |m: &mut GetRangeRequest| { &mut m.end_column },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "token",
                |m: &GetRangeRequest| { &m.token },
                |m: &mut GetRangeRequest| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &GetRangeRequest| { &m.transaction_id },
                |m: &mut GetRangeRequest| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRangeRequest>(
                "GetRangeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRangeRequest {
        static instance: ::protobuf::rt::LazyV2<GetRangeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRangeRequest::new)
    }
}

impl ::protobuf::Clear for GetRangeRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.direction = ::std::option::Option::None;
        self.columns_to_get.clear();
        self.time_range.clear();
        self.max_versions = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.inclusive_start_primary_key.clear();
        self.exclusive_end_primary_key.clear();
        self.cache_blocks = ::std::option::Option::None;
        self.filter.clear();
        self.start_column.clear();
        self.end_column.clear();
        self.token.clear();
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRangeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetRangeResponse {
    // message fields
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    rows: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    next_start_primary_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    next_token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRangeResponse {
    fn default() -> &'a GetRangeResponse {
        <GetRangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetRangeResponse {
    pub fn new() -> GetRangeResponse {
        ::std::default::Default::default()
    }

    // required .proto.ConsumedCapacity consumed = 1;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // required bytes rows = 2;


    pub fn get_rows(&self) -> &[u8] {
        match self.rows.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    pub fn has_rows(&self) -> bool {
        self.rows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::std::vec::Vec<u8>) {
        self.rows = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rows(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rows.is_none() {
            self.rows.set_default();
        }
        self.rows.as_mut().unwrap()
    }

    // Take field
    pub fn take_rows(&mut self) -> ::std::vec::Vec<u8> {
        self.rows.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes next_start_primary_key = 3;


    pub fn get_next_start_primary_key(&self) -> &[u8] {
        match self.next_start_primary_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_next_start_primary_key(&mut self) {
        self.next_start_primary_key.clear();
    }

    pub fn has_next_start_primary_key(&self) -> bool {
        self.next_start_primary_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_start_primary_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_start_primary_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_start_primary_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.next_start_primary_key.is_none() {
            self.next_start_primary_key.set_default();
        }
        self.next_start_primary_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_start_primary_key(&mut self) -> ::std::vec::Vec<u8> {
        self.next_start_primary_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes next_token = 4;


    pub fn get_next_token(&self) -> &[u8] {
        match self.next_token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_next_token(&mut self) {
        self.next_token.clear();
    }

    pub fn has_next_token(&self) -> bool {
        self.next_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.next_token.is_none() {
            self.next_token.set_default();
        }
        self.next_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_token(&mut self) -> ::std::vec::Vec<u8> {
        self.next_token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetRangeResponse {
    fn is_initialized(&self) -> bool {
        if self.consumed.is_none() {
            return false;
        }
        if self.rows.is_none() {
            return false;
        }
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rows)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.next_start_primary_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.next_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rows.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.next_start_primary_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.next_token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rows.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.next_start_primary_key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.next_token.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRangeResponse {
        GetRangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &GetRangeResponse| { &m.consumed },
                |m: &mut GetRangeResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "rows",
                |m: &GetRangeResponse| { &m.rows },
                |m: &mut GetRangeResponse| { &mut m.rows },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_start_primary_key",
                |m: &GetRangeResponse| { &m.next_start_primary_key },
                |m: &mut GetRangeResponse| { &mut m.next_start_primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "next_token",
                |m: &GetRangeResponse| { &m.next_token },
                |m: &mut GetRangeResponse| { &mut m.next_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetRangeResponse>(
                "GetRangeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetRangeResponse {
        static instance: ::protobuf::rt::LazyV2<GetRangeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRangeResponse::new)
    }
}

impl ::protobuf::Clear for GetRangeResponse {
    fn clear(&mut self) {
        self.consumed.clear();
        self.rows.clear();
        self.next_start_primary_key.clear();
        self.next_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetRangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStreamRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListStreamRequest {
    fn default() -> &'a ListStreamRequest {
        <ListStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListStreamRequest {
    pub fn new() -> ListStreamRequest {
        ::std::default::Default::default()
    }

    // optional string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListStreamRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStreamRequest {
        ListStreamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &ListStreamRequest| { &m.table_name },
                |m: &mut ListStreamRequest| { &mut m.table_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListStreamRequest>(
                "ListStreamRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListStreamRequest {
        static instance: ::protobuf::rt::LazyV2<ListStreamRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListStreamRequest::new)
    }
}

impl ::protobuf::Clear for ListStreamRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStreamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stream {
    // message fields
    stream_id: ::protobuf::SingularField<::std::string::String>,
    table_name: ::protobuf::SingularField<::std::string::String>,
    creation_time: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stream {
    fn default() -> &'a Stream {
        <Stream as ::protobuf::Message>::default_instance()
    }
}

impl Stream {
    pub fn new() -> Stream {
        ::std::default::Default::default()
    }

    // required string stream_id = 1;


    pub fn get_stream_id(&self) -> &str {
        match self.stream_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    pub fn has_stream_id(&self) -> bool {
        self.stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        if self.stream_id.is_none() {
            self.stream_id.set_default();
        }
        self.stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        self.stream_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string table_name = 2;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 creation_time = 3;


    pub fn get_creation_time(&self) -> i64 {
        self.creation_time.unwrap_or(0)
    }
    pub fn clear_creation_time(&mut self) {
        self.creation_time = ::std::option::Option::None;
    }

    pub fn has_creation_time(&self) -> bool {
        self.creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: i64) {
        self.creation_time = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Stream {
    fn is_initialized(&self) -> bool {
        if self.stream_id.is_none() {
            return false;
        }
        if self.table_name.is_none() {
            return false;
        }
        if self.creation_time.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stream_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_time = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.creation_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.creation_time {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stream {
        Stream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &Stream| { &m.stream_id },
                |m: &mut Stream| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &Stream| { &m.table_name },
                |m: &mut Stream| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creation_time",
                |m: &Stream| { &m.creation_time },
                |m: &mut Stream| { &mut m.creation_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Stream>(
                "Stream",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Stream {
        static instance: ::protobuf::rt::LazyV2<Stream> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Stream::new)
    }
}

impl ::protobuf::Clear for Stream {
    fn clear(&mut self) {
        self.stream_id.clear();
        self.table_name.clear();
        self.creation_time = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListStreamResponse {
    // message fields
    pub streams: ::protobuf::RepeatedField<Stream>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListStreamResponse {
    fn default() -> &'a ListStreamResponse {
        <ListStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListStreamResponse {
    pub fn new() -> ListStreamResponse {
        ::std::default::Default::default()
    }

    // repeated .proto.Stream streams = 1;


    pub fn get_streams(&self) -> &[Stream] {
        &self.streams
    }
    pub fn clear_streams(&mut self) {
        self.streams.clear();
    }

    // Param is passed by value, moved
    pub fn set_streams(&mut self, v: ::protobuf::RepeatedField<Stream>) {
        self.streams = v;
    }

    // Mutable pointer to the field.
    pub fn mut_streams(&mut self) -> &mut ::protobuf::RepeatedField<Stream> {
        &mut self.streams
    }

    // Take field
    pub fn take_streams(&mut self) -> ::protobuf::RepeatedField<Stream> {
        ::std::mem::replace(&mut self.streams, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListStreamResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.streams {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.streams)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.streams {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListStreamResponse {
        ListStreamResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                "streams",
                |m: &ListStreamResponse| { &m.streams },
                |m: &mut ListStreamResponse| { &mut m.streams },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListStreamResponse>(
                "ListStreamResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListStreamResponse {
        static instance: ::protobuf::rt::LazyV2<ListStreamResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListStreamResponse::new)
    }
}

impl ::protobuf::Clear for ListStreamResponse {
    fn clear(&mut self) {
        self.streams.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListStreamResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamShard {
    // message fields
    shard_id: ::protobuf::SingularField<::std::string::String>,
    parent_id: ::protobuf::SingularField<::std::string::String>,
    parent_sibling_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StreamShard {
    fn default() -> &'a StreamShard {
        <StreamShard as ::protobuf::Message>::default_instance()
    }
}

impl StreamShard {
    pub fn new() -> StreamShard {
        ::std::default::Default::default()
    }

    // required string shard_id = 1;


    pub fn get_shard_id(&self) -> &str {
        match self.shard_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id.clear();
    }

    pub fn has_shard_id(&self) -> bool {
        self.shard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: ::std::string::String) {
        self.shard_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_id(&mut self) -> &mut ::std::string::String {
        if self.shard_id.is_none() {
            self.shard_id.set_default();
        }
        self.shard_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_shard_id(&mut self) -> ::std::string::String {
        self.shard_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parent_id = 2;


    pub fn get_parent_id(&self) -> &str {
        match self.parent_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_parent_id(&mut self) {
        self.parent_id.clear();
    }

    pub fn has_parent_id(&self) -> bool {
        self.parent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_id(&mut self, v: ::std::string::String) {
        self.parent_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_id(&mut self) -> &mut ::std::string::String {
        if self.parent_id.is_none() {
            self.parent_id.set_default();
        }
        self.parent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_id(&mut self) -> ::std::string::String {
        self.parent_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parent_sibling_id = 3;


    pub fn get_parent_sibling_id(&self) -> &str {
        match self.parent_sibling_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_parent_sibling_id(&mut self) {
        self.parent_sibling_id.clear();
    }

    pub fn has_parent_sibling_id(&self) -> bool {
        self.parent_sibling_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_sibling_id(&mut self, v: ::std::string::String) {
        self.parent_sibling_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_sibling_id(&mut self) -> &mut ::std::string::String {
        if self.parent_sibling_id.is_none() {
            self.parent_sibling_id.set_default();
        }
        self.parent_sibling_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent_sibling_id(&mut self) -> ::std::string::String {
        self.parent_sibling_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StreamShard {
    fn is_initialized(&self) -> bool {
        if self.shard_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shard_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parent_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parent_sibling_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shard_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.parent_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.parent_sibling_id.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shard_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.parent_id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.parent_sibling_id.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamShard {
        StreamShard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shard_id",
                |m: &StreamShard| { &m.shard_id },
                |m: &mut StreamShard| { &mut m.shard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent_id",
                |m: &StreamShard| { &m.parent_id },
                |m: &mut StreamShard| { &mut m.parent_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent_sibling_id",
                |m: &StreamShard| { &m.parent_sibling_id },
                |m: &mut StreamShard| { &mut m.parent_sibling_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StreamShard>(
                "StreamShard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StreamShard {
        static instance: ::protobuf::rt::LazyV2<StreamShard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StreamShard::new)
    }
}

impl ::protobuf::Clear for StreamShard {
    fn clear(&mut self) {
        self.shard_id.clear();
        self.parent_id.clear();
        self.parent_sibling_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamShard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamShard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DescribeStreamRequest {
    // message fields
    stream_id: ::protobuf::SingularField<::std::string::String>,
    inclusive_start_shard_id: ::protobuf::SingularField<::std::string::String>,
    shard_limit: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DescribeStreamRequest {
    fn default() -> &'a DescribeStreamRequest {
        <DescribeStreamRequest as ::protobuf::Message>::default_instance()
    }
}

impl DescribeStreamRequest {
    pub fn new() -> DescribeStreamRequest {
        ::std::default::Default::default()
    }

    // required string stream_id = 1;


    pub fn get_stream_id(&self) -> &str {
        match self.stream_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    pub fn has_stream_id(&self) -> bool {
        self.stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        if self.stream_id.is_none() {
            self.stream_id.set_default();
        }
        self.stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        self.stream_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string inclusive_start_shard_id = 2;


    pub fn get_inclusive_start_shard_id(&self) -> &str {
        match self.inclusive_start_shard_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_inclusive_start_shard_id(&mut self) {
        self.inclusive_start_shard_id.clear();
    }

    pub fn has_inclusive_start_shard_id(&self) -> bool {
        self.inclusive_start_shard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inclusive_start_shard_id(&mut self, v: ::std::string::String) {
        self.inclusive_start_shard_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inclusive_start_shard_id(&mut self) -> &mut ::std::string::String {
        if self.inclusive_start_shard_id.is_none() {
            self.inclusive_start_shard_id.set_default();
        }
        self.inclusive_start_shard_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_inclusive_start_shard_id(&mut self) -> ::std::string::String {
        self.inclusive_start_shard_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 shard_limit = 3;


    pub fn get_shard_limit(&self) -> i32 {
        self.shard_limit.unwrap_or(0)
    }
    pub fn clear_shard_limit(&mut self) {
        self.shard_limit = ::std::option::Option::None;
    }

    pub fn has_shard_limit(&self) -> bool {
        self.shard_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_limit(&mut self, v: i32) {
        self.shard_limit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DescribeStreamRequest {
    fn is_initialized(&self) -> bool {
        if self.stream_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stream_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.inclusive_start_shard_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shard_limit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.inclusive_start_shard_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.shard_limit {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.inclusive_start_shard_id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.shard_limit {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DescribeStreamRequest {
        DescribeStreamRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &DescribeStreamRequest| { &m.stream_id },
                |m: &mut DescribeStreamRequest| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inclusive_start_shard_id",
                |m: &DescribeStreamRequest| { &m.inclusive_start_shard_id },
                |m: &mut DescribeStreamRequest| { &mut m.inclusive_start_shard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "shard_limit",
                |m: &DescribeStreamRequest| { &m.shard_limit },
                |m: &mut DescribeStreamRequest| { &mut m.shard_limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DescribeStreamRequest>(
                "DescribeStreamRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DescribeStreamRequest {
        static instance: ::protobuf::rt::LazyV2<DescribeStreamRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DescribeStreamRequest::new)
    }
}

impl ::protobuf::Clear for DescribeStreamRequest {
    fn clear(&mut self) {
        self.stream_id.clear();
        self.inclusive_start_shard_id.clear();
        self.shard_limit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DescribeStreamRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DescribeStreamRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DescribeStreamResponse {
    // message fields
    stream_id: ::protobuf::SingularField<::std::string::String>,
    expiration_time: ::std::option::Option<i32>,
    table_name: ::protobuf::SingularField<::std::string::String>,
    creation_time: ::std::option::Option<i64>,
    stream_status: ::std::option::Option<StreamStatus>,
    pub shards: ::protobuf::RepeatedField<StreamShard>,
    next_shard_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DescribeStreamResponse {
    fn default() -> &'a DescribeStreamResponse {
        <DescribeStreamResponse as ::protobuf::Message>::default_instance()
    }
}

impl DescribeStreamResponse {
    pub fn new() -> DescribeStreamResponse {
        ::std::default::Default::default()
    }

    // required string stream_id = 1;


    pub fn get_stream_id(&self) -> &str {
        match self.stream_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    pub fn has_stream_id(&self) -> bool {
        self.stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        if self.stream_id.is_none() {
            self.stream_id.set_default();
        }
        self.stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        self.stream_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 expiration_time = 2;


    pub fn get_expiration_time(&self) -> i32 {
        self.expiration_time.unwrap_or(0)
    }
    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: i32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    // required string table_name = 3;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 creation_time = 4;


    pub fn get_creation_time(&self) -> i64 {
        self.creation_time.unwrap_or(0)
    }
    pub fn clear_creation_time(&mut self) {
        self.creation_time = ::std::option::Option::None;
    }

    pub fn has_creation_time(&self) -> bool {
        self.creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: i64) {
        self.creation_time = ::std::option::Option::Some(v);
    }

    // required .proto.StreamStatus stream_status = 5;


    pub fn get_stream_status(&self) -> StreamStatus {
        self.stream_status.unwrap_or(StreamStatus::STREAM_ENABLING)
    }
    pub fn clear_stream_status(&mut self) {
        self.stream_status = ::std::option::Option::None;
    }

    pub fn has_stream_status(&self) -> bool {
        self.stream_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_status(&mut self, v: StreamStatus) {
        self.stream_status = ::std::option::Option::Some(v);
    }

    // repeated .proto.StreamShard shards = 6;


    pub fn get_shards(&self) -> &[StreamShard] {
        &self.shards
    }
    pub fn clear_shards(&mut self) {
        self.shards.clear();
    }

    // Param is passed by value, moved
    pub fn set_shards(&mut self, v: ::protobuf::RepeatedField<StreamShard>) {
        self.shards = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shards(&mut self) -> &mut ::protobuf::RepeatedField<StreamShard> {
        &mut self.shards
    }

    // Take field
    pub fn take_shards(&mut self) -> ::protobuf::RepeatedField<StreamShard> {
        ::std::mem::replace(&mut self.shards, ::protobuf::RepeatedField::new())
    }

    // optional string next_shard_id = 7;


    pub fn get_next_shard_id(&self) -> &str {
        match self.next_shard_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_next_shard_id(&mut self) {
        self.next_shard_id.clear();
    }

    pub fn has_next_shard_id(&self) -> bool {
        self.next_shard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_shard_id(&mut self, v: ::std::string::String) {
        self.next_shard_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_shard_id(&mut self) -> &mut ::std::string::String {
        if self.next_shard_id.is_none() {
            self.next_shard_id.set_default();
        }
        self.next_shard_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_shard_id(&mut self) -> ::std::string::String {
        self.next_shard_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DescribeStreamResponse {
    fn is_initialized(&self) -> bool {
        if self.stream_id.is_none() {
            return false;
        }
        if self.expiration_time.is_none() {
            return false;
        }
        if self.table_name.is_none() {
            return false;
        }
        if self.creation_time.is_none() {
            return false;
        }
        if self.stream_status.is_none() {
            return false;
        }
        for v in &self.shards {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stream_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.expiration_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.creation_time = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.stream_status, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shards)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.next_shard_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expiration_time {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.creation_time {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.stream_status {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        for value in &self.shards {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.next_shard_id.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.creation_time {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.stream_status {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.shards {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.next_shard_id.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DescribeStreamResponse {
        DescribeStreamResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &DescribeStreamResponse| { &m.stream_id },
                |m: &mut DescribeStreamResponse| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "expiration_time",
                |m: &DescribeStreamResponse| { &m.expiration_time },
                |m: &mut DescribeStreamResponse| { &mut m.expiration_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &DescribeStreamResponse| { &m.table_name },
                |m: &mut DescribeStreamResponse| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "creation_time",
                |m: &DescribeStreamResponse| { &m.creation_time },
                |m: &mut DescribeStreamResponse| { &mut m.creation_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StreamStatus>>(
                "stream_status",
                |m: &DescribeStreamResponse| { &m.stream_status },
                |m: &mut DescribeStreamResponse| { &mut m.stream_status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamShard>>(
                "shards",
                |m: &DescribeStreamResponse| { &m.shards },
                |m: &mut DescribeStreamResponse| { &mut m.shards },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_shard_id",
                |m: &DescribeStreamResponse| { &m.next_shard_id },
                |m: &mut DescribeStreamResponse| { &mut m.next_shard_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DescribeStreamResponse>(
                "DescribeStreamResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DescribeStreamResponse {
        static instance: ::protobuf::rt::LazyV2<DescribeStreamResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DescribeStreamResponse::new)
    }
}

impl ::protobuf::Clear for DescribeStreamResponse {
    fn clear(&mut self) {
        self.stream_id.clear();
        self.expiration_time = ::std::option::Option::None;
        self.table_name.clear();
        self.creation_time = ::std::option::Option::None;
        self.stream_status = ::std::option::Option::None;
        self.shards.clear();
        self.next_shard_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DescribeStreamResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DescribeStreamResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetShardIteratorRequest {
    // message fields
    stream_id: ::protobuf::SingularField<::std::string::String>,
    shard_id: ::protobuf::SingularField<::std::string::String>,
    timestamp: ::std::option::Option<i64>,
    token: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetShardIteratorRequest {
    fn default() -> &'a GetShardIteratorRequest {
        <GetShardIteratorRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetShardIteratorRequest {
    pub fn new() -> GetShardIteratorRequest {
        ::std::default::Default::default()
    }

    // required string stream_id = 1;


    pub fn get_stream_id(&self) -> &str {
        match self.stream_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    pub fn has_stream_id(&self) -> bool {
        self.stream_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        if self.stream_id.is_none() {
            self.stream_id.set_default();
        }
        self.stream_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        self.stream_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string shard_id = 2;


    pub fn get_shard_id(&self) -> &str {
        match self.shard_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shard_id(&mut self) {
        self.shard_id.clear();
    }

    pub fn has_shard_id(&self) -> bool {
        self.shard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_id(&mut self, v: ::std::string::String) {
        self.shard_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_id(&mut self) -> &mut ::std::string::String {
        if self.shard_id.is_none() {
            self.shard_id.set_default();
        }
        self.shard_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_shard_id(&mut self) -> ::std::string::String {
        self.shard_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 timestamp = 3;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional string token = 4;


    pub fn get_token(&self) -> &str {
        match self.token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::string::String) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::string::String {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::string::String {
        self.token.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetShardIteratorRequest {
    fn is_initialized(&self) -> bool {
        if self.stream_id.is_none() {
            return false;
        }
        if self.shard_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.stream_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shard_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.shard_id.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream_id.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.shard_id.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetShardIteratorRequest {
        GetShardIteratorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stream_id",
                |m: &GetShardIteratorRequest| { &m.stream_id },
                |m: &mut GetShardIteratorRequest| { &mut m.stream_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shard_id",
                |m: &GetShardIteratorRequest| { &m.shard_id },
                |m: &mut GetShardIteratorRequest| { &mut m.shard_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &GetShardIteratorRequest| { &m.timestamp },
                |m: &mut GetShardIteratorRequest| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "token",
                |m: &GetShardIteratorRequest| { &m.token },
                |m: &mut GetShardIteratorRequest| { &mut m.token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetShardIteratorRequest>(
                "GetShardIteratorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetShardIteratorRequest {
        static instance: ::protobuf::rt::LazyV2<GetShardIteratorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetShardIteratorRequest::new)
    }
}

impl ::protobuf::Clear for GetShardIteratorRequest {
    fn clear(&mut self) {
        self.stream_id.clear();
        self.shard_id.clear();
        self.timestamp = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetShardIteratorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShardIteratorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetShardIteratorResponse {
    // message fields
    shard_iterator: ::protobuf::SingularField<::std::string::String>,
    next_token: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetShardIteratorResponse {
    fn default() -> &'a GetShardIteratorResponse {
        <GetShardIteratorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetShardIteratorResponse {
    pub fn new() -> GetShardIteratorResponse {
        ::std::default::Default::default()
    }

    // required string shard_iterator = 1;


    pub fn get_shard_iterator(&self) -> &str {
        match self.shard_iterator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shard_iterator(&mut self) {
        self.shard_iterator.clear();
    }

    pub fn has_shard_iterator(&self) -> bool {
        self.shard_iterator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_iterator(&mut self, v: ::std::string::String) {
        self.shard_iterator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_iterator(&mut self) -> &mut ::std::string::String {
        if self.shard_iterator.is_none() {
            self.shard_iterator.set_default();
        }
        self.shard_iterator.as_mut().unwrap()
    }

    // Take field
    pub fn take_shard_iterator(&mut self) -> ::std::string::String {
        self.shard_iterator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string next_token = 2;


    pub fn get_next_token(&self) -> &str {
        match self.next_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_next_token(&mut self) {
        self.next_token.clear();
    }

    pub fn has_next_token(&self) -> bool {
        self.next_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_token(&mut self, v: ::std::string::String) {
        self.next_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_token(&mut self) -> &mut ::std::string::String {
        if self.next_token.is_none() {
            self.next_token.set_default();
        }
        self.next_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_token(&mut self) -> ::std::string::String {
        self.next_token.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetShardIteratorResponse {
    fn is_initialized(&self) -> bool {
        if self.shard_iterator.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shard_iterator)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.next_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shard_iterator.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.next_token.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shard_iterator.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.next_token.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetShardIteratorResponse {
        GetShardIteratorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shard_iterator",
                |m: &GetShardIteratorResponse| { &m.shard_iterator },
                |m: &mut GetShardIteratorResponse| { &mut m.shard_iterator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_token",
                |m: &GetShardIteratorResponse| { &m.next_token },
                |m: &mut GetShardIteratorResponse| { &mut m.next_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetShardIteratorResponse>(
                "GetShardIteratorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetShardIteratorResponse {
        static instance: ::protobuf::rt::LazyV2<GetShardIteratorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetShardIteratorResponse::new)
    }
}

impl ::protobuf::Clear for GetShardIteratorResponse {
    fn clear(&mut self) {
        self.shard_iterator.clear();
        self.next_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetShardIteratorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShardIteratorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStreamRecordRequest {
    // message fields
    shard_iterator: ::protobuf::SingularField<::std::string::String>,
    limit: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStreamRecordRequest {
    fn default() -> &'a GetStreamRecordRequest {
        <GetStreamRecordRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStreamRecordRequest {
    pub fn new() -> GetStreamRecordRequest {
        ::std::default::Default::default()
    }

    // required string shard_iterator = 1;


    pub fn get_shard_iterator(&self) -> &str {
        match self.shard_iterator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shard_iterator(&mut self) {
        self.shard_iterator.clear();
    }

    pub fn has_shard_iterator(&self) -> bool {
        self.shard_iterator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shard_iterator(&mut self, v: ::std::string::String) {
        self.shard_iterator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shard_iterator(&mut self) -> &mut ::std::string::String {
        if self.shard_iterator.is_none() {
            self.shard_iterator.set_default();
        }
        self.shard_iterator.as_mut().unwrap()
    }

    // Take field
    pub fn take_shard_iterator(&mut self) -> ::std::string::String {
        self.shard_iterator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 limit = 2;


    pub fn get_limit(&self) -> i32 {
        self.limit.unwrap_or(0)
    }
    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GetStreamRecordRequest {
    fn is_initialized(&self) -> bool {
        if self.shard_iterator.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shard_iterator)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shard_iterator.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shard_iterator.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.limit {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStreamRecordRequest {
        GetStreamRecordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shard_iterator",
                |m: &GetStreamRecordRequest| { &m.shard_iterator },
                |m: &mut GetStreamRecordRequest| { &mut m.shard_iterator },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "limit",
                |m: &GetStreamRecordRequest| { &m.limit },
                |m: &mut GetStreamRecordRequest| { &mut m.limit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStreamRecordRequest>(
                "GetStreamRecordRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStreamRecordRequest {
        static instance: ::protobuf::rt::LazyV2<GetStreamRecordRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStreamRecordRequest::new)
    }
}

impl ::protobuf::Clear for GetStreamRecordRequest {
    fn clear(&mut self) {
        self.shard_iterator.clear();
        self.limit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStreamRecordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStreamRecordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStreamRecordResponse {
    // message fields
    pub stream_records: ::protobuf::RepeatedField<GetStreamRecordResponse_StreamRecord>,
    next_shard_iterator: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStreamRecordResponse {
    fn default() -> &'a GetStreamRecordResponse {
        <GetStreamRecordResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetStreamRecordResponse {
    pub fn new() -> GetStreamRecordResponse {
        ::std::default::Default::default()
    }

    // repeated .proto.GetStreamRecordResponse.StreamRecord stream_records = 1;


    pub fn get_stream_records(&self) -> &[GetStreamRecordResponse_StreamRecord] {
        &self.stream_records
    }
    pub fn clear_stream_records(&mut self) {
        self.stream_records.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_records(&mut self, v: ::protobuf::RepeatedField<GetStreamRecordResponse_StreamRecord>) {
        self.stream_records = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stream_records(&mut self) -> &mut ::protobuf::RepeatedField<GetStreamRecordResponse_StreamRecord> {
        &mut self.stream_records
    }

    // Take field
    pub fn take_stream_records(&mut self) -> ::protobuf::RepeatedField<GetStreamRecordResponse_StreamRecord> {
        ::std::mem::replace(&mut self.stream_records, ::protobuf::RepeatedField::new())
    }

    // optional string next_shard_iterator = 2;


    pub fn get_next_shard_iterator(&self) -> &str {
        match self.next_shard_iterator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_next_shard_iterator(&mut self) {
        self.next_shard_iterator.clear();
    }

    pub fn has_next_shard_iterator(&self) -> bool {
        self.next_shard_iterator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_shard_iterator(&mut self, v: ::std::string::String) {
        self.next_shard_iterator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_shard_iterator(&mut self) -> &mut ::std::string::String {
        if self.next_shard_iterator.is_none() {
            self.next_shard_iterator.set_default();
        }
        self.next_shard_iterator.as_mut().unwrap()
    }

    // Take field
    pub fn take_next_shard_iterator(&mut self) -> ::std::string::String {
        self.next_shard_iterator.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetStreamRecordResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stream_records {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stream_records)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.next_shard_iterator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stream_records {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.next_shard_iterator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stream_records {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.next_shard_iterator.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStreamRecordResponse {
        GetStreamRecordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetStreamRecordResponse_StreamRecord>>(
                "stream_records",
                |m: &GetStreamRecordResponse| { &m.stream_records },
                |m: &mut GetStreamRecordResponse| { &mut m.stream_records },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_shard_iterator",
                |m: &GetStreamRecordResponse| { &m.next_shard_iterator },
                |m: &mut GetStreamRecordResponse| { &mut m.next_shard_iterator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStreamRecordResponse>(
                "GetStreamRecordResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStreamRecordResponse {
        static instance: ::protobuf::rt::LazyV2<GetStreamRecordResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStreamRecordResponse::new)
    }
}

impl ::protobuf::Clear for GetStreamRecordResponse {
    fn clear(&mut self) {
        self.stream_records.clear();
        self.next_shard_iterator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStreamRecordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStreamRecordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStreamRecordResponse_StreamRecord {
    // message fields
    action_type: ::std::option::Option<ActionType>,
    record: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStreamRecordResponse_StreamRecord {
    fn default() -> &'a GetStreamRecordResponse_StreamRecord {
        <GetStreamRecordResponse_StreamRecord as ::protobuf::Message>::default_instance()
    }
}

impl GetStreamRecordResponse_StreamRecord {
    pub fn new() -> GetStreamRecordResponse_StreamRecord {
        ::std::default::Default::default()
    }

    // required .proto.ActionType action_type = 1;


    pub fn get_action_type(&self) -> ActionType {
        self.action_type.unwrap_or(ActionType::PUT_ROW)
    }
    pub fn clear_action_type(&mut self) {
        self.action_type = ::std::option::Option::None;
    }

    pub fn has_action_type(&self) -> bool {
        self.action_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_type(&mut self, v: ActionType) {
        self.action_type = ::std::option::Option::Some(v);
    }

    // required bytes record = 2;


    pub fn get_record(&self) -> &[u8] {
        match self.record.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_record(&mut self) {
        self.record.clear();
    }

    pub fn has_record(&self) -> bool {
        self.record.is_some()
    }

    // Param is passed by value, moved
    pub fn set_record(&mut self, v: ::std::vec::Vec<u8>) {
        self.record = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_record(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.record.is_none() {
            self.record.set_default();
        }
        self.record.as_mut().unwrap()
    }

    // Take field
    pub fn take_record(&mut self) -> ::std::vec::Vec<u8> {
        self.record.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetStreamRecordResponse_StreamRecord {
    fn is_initialized(&self) -> bool {
        if self.action_type.is_none() {
            return false;
        }
        if self.record.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.action_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.record)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.action_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.record.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.action_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.record.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStreamRecordResponse_StreamRecord {
        GetStreamRecordResponse_StreamRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ActionType>>(
                "action_type",
                |m: &GetStreamRecordResponse_StreamRecord| { &m.action_type },
                |m: &mut GetStreamRecordResponse_StreamRecord| { &mut m.action_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "record",
                |m: &GetStreamRecordResponse_StreamRecord| { &m.record },
                |m: &mut GetStreamRecordResponse_StreamRecord| { &mut m.record },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStreamRecordResponse_StreamRecord>(
                "GetStreamRecordResponse.StreamRecord",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStreamRecordResponse_StreamRecord {
        static instance: ::protobuf::rt::LazyV2<GetStreamRecordResponse_StreamRecord> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStreamRecordResponse_StreamRecord::new)
    }
}

impl ::protobuf::Clear for GetStreamRecordResponse_StreamRecord {
    fn clear(&mut self) {
        self.action_type = ::std::option::Option::None;
        self.record.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStreamRecordResponse_StreamRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStreamRecordResponse_StreamRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputeSplitPointsBySizeRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    split_size: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputeSplitPointsBySizeRequest {
    fn default() -> &'a ComputeSplitPointsBySizeRequest {
        <ComputeSplitPointsBySizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl ComputeSplitPointsBySizeRequest {
    pub fn new() -> ComputeSplitPointsBySizeRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 split_size = 2;


    pub fn get_split_size(&self) -> i64 {
        self.split_size.unwrap_or(0)
    }
    pub fn clear_split_size(&mut self) {
        self.split_size = ::std::option::Option::None;
    }

    pub fn has_split_size(&self) -> bool {
        self.split_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_split_size(&mut self, v: i64) {
        self.split_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ComputeSplitPointsBySizeRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        if self.split_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.split_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.split_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.split_size {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputeSplitPointsBySizeRequest {
        ComputeSplitPointsBySizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &ComputeSplitPointsBySizeRequest| { &m.table_name },
                |m: &mut ComputeSplitPointsBySizeRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "split_size",
                |m: &ComputeSplitPointsBySizeRequest| { &m.split_size },
                |m: &mut ComputeSplitPointsBySizeRequest| { &mut m.split_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputeSplitPointsBySizeRequest>(
                "ComputeSplitPointsBySizeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputeSplitPointsBySizeRequest {
        static instance: ::protobuf::rt::LazyV2<ComputeSplitPointsBySizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputeSplitPointsBySizeRequest::new)
    }
}

impl ::protobuf::Clear for ComputeSplitPointsBySizeRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.split_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputeSplitPointsBySizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeSplitPointsBySizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputeSplitPointsBySizeResponse {
    // message fields
    pub consumed: ::protobuf::SingularPtrField<ConsumedCapacity>,
    pub schema: ::protobuf::RepeatedField<PrimaryKeySchema>,
    pub split_points: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub locations: ::protobuf::RepeatedField<ComputeSplitPointsBySizeResponse_SplitLocation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputeSplitPointsBySizeResponse {
    fn default() -> &'a ComputeSplitPointsBySizeResponse {
        <ComputeSplitPointsBySizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComputeSplitPointsBySizeResponse {
    pub fn new() -> ComputeSplitPointsBySizeResponse {
        ::std::default::Default::default()
    }

    // required .proto.ConsumedCapacity consumed = 1;


    pub fn get_consumed(&self) -> &ConsumedCapacity {
        self.consumed.as_ref().unwrap_or_else(|| <ConsumedCapacity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumed(&mut self) {
        self.consumed.clear();
    }

    pub fn has_consumed(&self) -> bool {
        self.consumed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumed(&mut self, v: ConsumedCapacity) {
        self.consumed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumed(&mut self) -> &mut ConsumedCapacity {
        if self.consumed.is_none() {
            self.consumed.set_default();
        }
        self.consumed.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumed(&mut self) -> ConsumedCapacity {
        self.consumed.take().unwrap_or_else(|| ConsumedCapacity::new())
    }

    // repeated .proto.PrimaryKeySchema schema = 2;


    pub fn get_schema(&self) -> &[PrimaryKeySchema] {
        &self.schema
    }
    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::protobuf::RepeatedField<PrimaryKeySchema>) {
        self.schema = v;
    }

    // Mutable pointer to the field.
    pub fn mut_schema(&mut self) -> &mut ::protobuf::RepeatedField<PrimaryKeySchema> {
        &mut self.schema
    }

    // Take field
    pub fn take_schema(&mut self) -> ::protobuf::RepeatedField<PrimaryKeySchema> {
        ::std::mem::replace(&mut self.schema, ::protobuf::RepeatedField::new())
    }

    // repeated bytes split_points = 3;


    pub fn get_split_points(&self) -> &[::std::vec::Vec<u8>] {
        &self.split_points
    }
    pub fn clear_split_points(&mut self) {
        self.split_points.clear();
    }

    // Param is passed by value, moved
    pub fn set_split_points(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.split_points = v;
    }

    // Mutable pointer to the field.
    pub fn mut_split_points(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.split_points
    }

    // Take field
    pub fn take_split_points(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.split_points, ::protobuf::RepeatedField::new())
    }

    // repeated .proto.ComputeSplitPointsBySizeResponse.SplitLocation locations = 4;


    pub fn get_locations(&self) -> &[ComputeSplitPointsBySizeResponse_SplitLocation] {
        &self.locations
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: ::protobuf::RepeatedField<ComputeSplitPointsBySizeResponse_SplitLocation>) {
        self.locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locations(&mut self) -> &mut ::protobuf::RepeatedField<ComputeSplitPointsBySizeResponse_SplitLocation> {
        &mut self.locations
    }

    // Take field
    pub fn take_locations(&mut self) -> ::protobuf::RepeatedField<ComputeSplitPointsBySizeResponse_SplitLocation> {
        ::std::mem::replace(&mut self.locations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ComputeSplitPointsBySizeResponse {
    fn is_initialized(&self) -> bool {
        if self.consumed.is_none() {
            return false;
        }
        for v in &self.consumed {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schema {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.locations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumed)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.schema)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.split_points)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.consumed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.schema {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.split_points {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in &self.locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.consumed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.schema {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.split_points {
            os.write_bytes(3, &v)?;
        };
        for v in &self.locations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputeSplitPointsBySizeResponse {
        ComputeSplitPointsBySizeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConsumedCapacity>>(
                "consumed",
                |m: &ComputeSplitPointsBySizeResponse| { &m.consumed },
                |m: &mut ComputeSplitPointsBySizeResponse| { &mut m.consumed },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrimaryKeySchema>>(
                "schema",
                |m: &ComputeSplitPointsBySizeResponse| { &m.schema },
                |m: &mut ComputeSplitPointsBySizeResponse| { &mut m.schema },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "split_points",
                |m: &ComputeSplitPointsBySizeResponse| { &m.split_points },
                |m: &mut ComputeSplitPointsBySizeResponse| { &mut m.split_points },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComputeSplitPointsBySizeResponse_SplitLocation>>(
                "locations",
                |m: &ComputeSplitPointsBySizeResponse| { &m.locations },
                |m: &mut ComputeSplitPointsBySizeResponse| { &mut m.locations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputeSplitPointsBySizeResponse>(
                "ComputeSplitPointsBySizeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputeSplitPointsBySizeResponse {
        static instance: ::protobuf::rt::LazyV2<ComputeSplitPointsBySizeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputeSplitPointsBySizeResponse::new)
    }
}

impl ::protobuf::Clear for ComputeSplitPointsBySizeResponse {
    fn clear(&mut self) {
        self.consumed.clear();
        self.schema.clear();
        self.split_points.clear();
        self.locations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputeSplitPointsBySizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeSplitPointsBySizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputeSplitPointsBySizeResponse_SplitLocation {
    // message fields
    location: ::protobuf::SingularField<::std::string::String>,
    repeat: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputeSplitPointsBySizeResponse_SplitLocation {
    fn default() -> &'a ComputeSplitPointsBySizeResponse_SplitLocation {
        <ComputeSplitPointsBySizeResponse_SplitLocation as ::protobuf::Message>::default_instance()
    }
}

impl ComputeSplitPointsBySizeResponse_SplitLocation {
    pub fn new() -> ComputeSplitPointsBySizeResponse_SplitLocation {
        ::std::default::Default::default()
    }

    // required string location = 1;


    pub fn get_location(&self) -> &str {
        match self.location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required sint64 repeat = 2;


    pub fn get_repeat(&self) -> i64 {
        self.repeat.unwrap_or(0)
    }
    pub fn clear_repeat(&mut self) {
        self.repeat = ::std::option::Option::None;
    }

    pub fn has_repeat(&self) -> bool {
        self.repeat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeat(&mut self, v: i64) {
        self.repeat = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ComputeSplitPointsBySizeResponse_SplitLocation {
    fn is_initialized(&self) -> bool {
        if self.location.is_none() {
            return false;
        }
        if self.repeat.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.location)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint64()?;
                    self.repeat = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.location.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.repeat {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.location.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.repeat {
            os.write_sint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputeSplitPointsBySizeResponse_SplitLocation {
        ComputeSplitPointsBySizeResponse_SplitLocation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &ComputeSplitPointsBySizeResponse_SplitLocation| { &m.location },
                |m: &mut ComputeSplitPointsBySizeResponse_SplitLocation| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint64>(
                "repeat",
                |m: &ComputeSplitPointsBySizeResponse_SplitLocation| { &m.repeat },
                |m: &mut ComputeSplitPointsBySizeResponse_SplitLocation| { &mut m.repeat },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputeSplitPointsBySizeResponse_SplitLocation>(
                "ComputeSplitPointsBySizeResponse.SplitLocation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputeSplitPointsBySizeResponse_SplitLocation {
        static instance: ::protobuf::rt::LazyV2<ComputeSplitPointsBySizeResponse_SplitLocation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputeSplitPointsBySizeResponse_SplitLocation::new)
    }
}

impl ::protobuf::Clear for ComputeSplitPointsBySizeResponse_SplitLocation {
    fn clear(&mut self) {
        self.location.clear();
        self.repeat = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputeSplitPointsBySizeResponse_SplitLocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeSplitPointsBySizeResponse_SplitLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DefinedColumnSchema {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<DefinedColumnType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DefinedColumnSchema {
    fn default() -> &'a DefinedColumnSchema {
        <DefinedColumnSchema as ::protobuf::Message>::default_instance()
    }
}

impl DefinedColumnSchema {
    pub fn new() -> DefinedColumnSchema {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .proto.DefinedColumnType type = 2;


    pub fn get_field_type(&self) -> DefinedColumnType {
        self.field_type.unwrap_or(DefinedColumnType::DCT_INTEGER)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: DefinedColumnType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DefinedColumnSchema {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.field_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DefinedColumnSchema {
        DefinedColumnSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DefinedColumnSchema| { &m.name },
                |m: &mut DefinedColumnSchema| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DefinedColumnType>>(
                "type",
                |m: &DefinedColumnSchema| { &m.field_type },
                |m: &mut DefinedColumnSchema| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DefinedColumnSchema>(
                "DefinedColumnSchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DefinedColumnSchema {
        static instance: ::protobuf::rt::LazyV2<DefinedColumnSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DefinedColumnSchema::new)
    }
}

impl ::protobuf::Clear for DefinedColumnSchema {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DefinedColumnSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinedColumnSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IndexMeta {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub primary_key: ::protobuf::RepeatedField<::std::string::String>,
    pub defined_column: ::protobuf::RepeatedField<::std::string::String>,
    index_update_mode: ::std::option::Option<IndexUpdateMode>,
    index_type: ::std::option::Option<IndexType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IndexMeta {
    fn default() -> &'a IndexMeta {
        <IndexMeta as ::protobuf::Message>::default_instance()
    }
}

impl IndexMeta {
    pub fn new() -> IndexMeta {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string primary_key = 2;


    pub fn get_primary_key(&self) -> &[::std::string::String] {
        &self.primary_key
    }
    pub fn clear_primary_key(&mut self) {
        self.primary_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_key(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.primary_key = v;
    }

    // Mutable pointer to the field.
    pub fn mut_primary_key(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.primary_key
    }

    // Take field
    pub fn take_primary_key(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.primary_key, ::protobuf::RepeatedField::new())
    }

    // repeated string defined_column = 3;


    pub fn get_defined_column(&self) -> &[::std::string::String] {
        &self.defined_column
    }
    pub fn clear_defined_column(&mut self) {
        self.defined_column.clear();
    }

    // Param is passed by value, moved
    pub fn set_defined_column(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.defined_column = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defined_column(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.defined_column
    }

    // Take field
    pub fn take_defined_column(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.defined_column, ::protobuf::RepeatedField::new())
    }

    // required .proto.IndexUpdateMode index_update_mode = 4;


    pub fn get_index_update_mode(&self) -> IndexUpdateMode {
        self.index_update_mode.unwrap_or(IndexUpdateMode::IUM_ASYNC_INDEX)
    }
    pub fn clear_index_update_mode(&mut self) {
        self.index_update_mode = ::std::option::Option::None;
    }

    pub fn has_index_update_mode(&self) -> bool {
        self.index_update_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_update_mode(&mut self, v: IndexUpdateMode) {
        self.index_update_mode = ::std::option::Option::Some(v);
    }

    // required .proto.IndexType index_type = 5;


    pub fn get_index_type(&self) -> IndexType {
        self.index_type.unwrap_or(IndexType::IT_GLOBAL_INDEX)
    }
    pub fn clear_index_type(&mut self) {
        self.index_type = ::std::option::Option::None;
    }

    pub fn has_index_type(&self) -> bool {
        self.index_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_type(&mut self, v: IndexType) {
        self.index_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for IndexMeta {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.index_update_mode.is_none() {
            return false;
        }
        if self.index_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.primary_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.defined_column)?;
                },
                4 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.index_update_mode, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.index_type, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.primary_key {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.defined_column {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.index_update_mode {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.index_type {
            my_size += ::protobuf::rt::enum_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.primary_key {
            os.write_string(2, &v)?;
        };
        for v in &self.defined_column {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.index_update_mode {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.index_type {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IndexMeta {
        IndexMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &IndexMeta| { &m.name },
                |m: &mut IndexMeta| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "primary_key",
                |m: &IndexMeta| { &m.primary_key },
                |m: &mut IndexMeta| { &mut m.primary_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "defined_column",
                |m: &IndexMeta| { &m.defined_column },
                |m: &mut IndexMeta| { &mut m.defined_column },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IndexUpdateMode>>(
                "index_update_mode",
                |m: &IndexMeta| { &m.index_update_mode },
                |m: &mut IndexMeta| { &mut m.index_update_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<IndexType>>(
                "index_type",
                |m: &IndexMeta| { &m.index_type },
                |m: &mut IndexMeta| { &mut m.index_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IndexMeta>(
                "IndexMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IndexMeta {
        static instance: ::protobuf::rt::LazyV2<IndexMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IndexMeta::new)
    }
}

impl ::protobuf::Clear for IndexMeta {
    fn clear(&mut self) {
        self.name.clear();
        self.primary_key.clear();
        self.defined_column.clear();
        self.index_update_mode = ::std::option::Option::None;
        self.index_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IndexMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IndexMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateIndexRequest {
    // message fields
    main_table_name: ::protobuf::SingularField<::std::string::String>,
    pub index_meta: ::protobuf::SingularPtrField<IndexMeta>,
    include_base_data: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateIndexRequest {
    fn default() -> &'a CreateIndexRequest {
        <CreateIndexRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateIndexRequest {
    pub fn new() -> CreateIndexRequest {
        ::std::default::Default::default()
    }

    // required string main_table_name = 1;


    pub fn get_main_table_name(&self) -> &str {
        match self.main_table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_main_table_name(&mut self) {
        self.main_table_name.clear();
    }

    pub fn has_main_table_name(&self) -> bool {
        self.main_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_table_name(&mut self, v: ::std::string::String) {
        self.main_table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_table_name(&mut self) -> &mut ::std::string::String {
        if self.main_table_name.is_none() {
            self.main_table_name.set_default();
        }
        self.main_table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_table_name(&mut self) -> ::std::string::String {
        self.main_table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .proto.IndexMeta index_meta = 2;


    pub fn get_index_meta(&self) -> &IndexMeta {
        self.index_meta.as_ref().unwrap_or_else(|| <IndexMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_index_meta(&mut self) {
        self.index_meta.clear();
    }

    pub fn has_index_meta(&self) -> bool {
        self.index_meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_meta(&mut self, v: IndexMeta) {
        self.index_meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_meta(&mut self) -> &mut IndexMeta {
        if self.index_meta.is_none() {
            self.index_meta.set_default();
        }
        self.index_meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_meta(&mut self) -> IndexMeta {
        self.index_meta.take().unwrap_or_else(|| IndexMeta::new())
    }

    // optional bool include_base_data = 3;


    pub fn get_include_base_data(&self) -> bool {
        self.include_base_data.unwrap_or(false)
    }
    pub fn clear_include_base_data(&mut self) {
        self.include_base_data = ::std::option::Option::None;
    }

    pub fn has_include_base_data(&self) -> bool {
        self.include_base_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_base_data(&mut self, v: bool) {
        self.include_base_data = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CreateIndexRequest {
    fn is_initialized(&self) -> bool {
        if self.main_table_name.is_none() {
            return false;
        }
        if self.index_meta.is_none() {
            return false;
        }
        for v in &self.index_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.main_table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.index_meta)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_base_data = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.main_table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.index_meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.include_base_data {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.main_table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.index_meta.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.include_base_data {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateIndexRequest {
        CreateIndexRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "main_table_name",
                |m: &CreateIndexRequest| { &m.main_table_name },
                |m: &mut CreateIndexRequest| { &mut m.main_table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IndexMeta>>(
                "index_meta",
                |m: &CreateIndexRequest| { &m.index_meta },
                |m: &mut CreateIndexRequest| { &mut m.index_meta },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_base_data",
                |m: &CreateIndexRequest| { &m.include_base_data },
                |m: &mut CreateIndexRequest| { &mut m.include_base_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateIndexRequest>(
                "CreateIndexRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateIndexRequest {
        static instance: ::protobuf::rt::LazyV2<CreateIndexRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateIndexRequest::new)
    }
}

impl ::protobuf::Clear for CreateIndexRequest {
    fn clear(&mut self) {
        self.main_table_name.clear();
        self.index_meta.clear();
        self.include_base_data = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateIndexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIndexRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateIndexResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateIndexResponse {
    fn default() -> &'a CreateIndexResponse {
        <CreateIndexResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateIndexResponse {
    pub fn new() -> CreateIndexResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateIndexResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateIndexResponse {
        CreateIndexResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateIndexResponse>(
                "CreateIndexResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateIndexResponse {
        static instance: ::protobuf::rt::LazyV2<CreateIndexResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateIndexResponse::new)
    }
}

impl ::protobuf::Clear for CreateIndexResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateIndexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIndexResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DropIndexRequest {
    // message fields
    main_table_name: ::protobuf::SingularField<::std::string::String>,
    index_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DropIndexRequest {
    fn default() -> &'a DropIndexRequest {
        <DropIndexRequest as ::protobuf::Message>::default_instance()
    }
}

impl DropIndexRequest {
    pub fn new() -> DropIndexRequest {
        ::std::default::Default::default()
    }

    // required string main_table_name = 1;


    pub fn get_main_table_name(&self) -> &str {
        match self.main_table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_main_table_name(&mut self) {
        self.main_table_name.clear();
    }

    pub fn has_main_table_name(&self) -> bool {
        self.main_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_table_name(&mut self, v: ::std::string::String) {
        self.main_table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_table_name(&mut self) -> &mut ::std::string::String {
        if self.main_table_name.is_none() {
            self.main_table_name.set_default();
        }
        self.main_table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_table_name(&mut self) -> ::std::string::String {
        self.main_table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string index_name = 2;


    pub fn get_index_name(&self) -> &str {
        match self.index_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_index_name(&mut self) {
        self.index_name.clear();
    }

    pub fn has_index_name(&self) -> bool {
        self.index_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_name(&mut self, v: ::std::string::String) {
        self.index_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_name(&mut self) -> &mut ::std::string::String {
        if self.index_name.is_none() {
            self.index_name.set_default();
        }
        self.index_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_name(&mut self) -> ::std::string::String {
        self.index_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DropIndexRequest {
    fn is_initialized(&self) -> bool {
        if self.main_table_name.is_none() {
            return false;
        }
        if self.index_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.main_table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.index_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.main_table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.index_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.main_table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.index_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DropIndexRequest {
        DropIndexRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "main_table_name",
                |m: &DropIndexRequest| { &m.main_table_name },
                |m: &mut DropIndexRequest| { &mut m.main_table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "index_name",
                |m: &DropIndexRequest| { &m.index_name },
                |m: &mut DropIndexRequest| { &mut m.index_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DropIndexRequest>(
                "DropIndexRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DropIndexRequest {
        static instance: ::protobuf::rt::LazyV2<DropIndexRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DropIndexRequest::new)
    }
}

impl ::protobuf::Clear for DropIndexRequest {
    fn clear(&mut self) {
        self.main_table_name.clear();
        self.index_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DropIndexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropIndexRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DropIndexResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DropIndexResponse {
    fn default() -> &'a DropIndexResponse {
        <DropIndexResponse as ::protobuf::Message>::default_instance()
    }
}

impl DropIndexResponse {
    pub fn new() -> DropIndexResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DropIndexResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DropIndexResponse {
        DropIndexResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DropIndexResponse>(
                "DropIndexResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DropIndexResponse {
        static instance: ::protobuf::rt::LazyV2<DropIndexResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DropIndexResponse::new)
    }
}

impl ::protobuf::Clear for DropIndexResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DropIndexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DropIndexResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddDefinedColumnRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub columns: ::protobuf::RepeatedField<DefinedColumnSchema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddDefinedColumnRequest {
    fn default() -> &'a AddDefinedColumnRequest {
        <AddDefinedColumnRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddDefinedColumnRequest {
    pub fn new() -> AddDefinedColumnRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .proto.DefinedColumnSchema columns = 2;


    pub fn get_columns(&self) -> &[DefinedColumnSchema] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<DefinedColumnSchema>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<DefinedColumnSchema> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<DefinedColumnSchema> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddDefinedColumnRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        for v in &self.columns {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.columns)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.columns {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.columns {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddDefinedColumnRequest {
        AddDefinedColumnRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &AddDefinedColumnRequest| { &m.table_name },
                |m: &mut AddDefinedColumnRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DefinedColumnSchema>>(
                "columns",
                |m: &AddDefinedColumnRequest| { &m.columns },
                |m: &mut AddDefinedColumnRequest| { &mut m.columns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddDefinedColumnRequest>(
                "AddDefinedColumnRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddDefinedColumnRequest {
        static instance: ::protobuf::rt::LazyV2<AddDefinedColumnRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddDefinedColumnRequest::new)
    }
}

impl ::protobuf::Clear for AddDefinedColumnRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.columns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddDefinedColumnRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddDefinedColumnRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddDefinedColumnResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddDefinedColumnResponse {
    fn default() -> &'a AddDefinedColumnResponse {
        <AddDefinedColumnResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddDefinedColumnResponse {
    pub fn new() -> AddDefinedColumnResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddDefinedColumnResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddDefinedColumnResponse {
        AddDefinedColumnResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddDefinedColumnResponse>(
                "AddDefinedColumnResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddDefinedColumnResponse {
        static instance: ::protobuf::rt::LazyV2<AddDefinedColumnResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddDefinedColumnResponse::new)
    }
}

impl ::protobuf::Clear for AddDefinedColumnResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddDefinedColumnResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddDefinedColumnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteDefinedColumnRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub columns: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteDefinedColumnRequest {
    fn default() -> &'a DeleteDefinedColumnRequest {
        <DeleteDefinedColumnRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDefinedColumnRequest {
    pub fn new() -> DeleteDefinedColumnRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string columns = 2;


    pub fn get_columns(&self) -> &[::std::string::String] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteDefinedColumnRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.columns)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.columns {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.columns {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteDefinedColumnRequest {
        DeleteDefinedColumnRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &DeleteDefinedColumnRequest| { &m.table_name },
                |m: &mut DeleteDefinedColumnRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columns",
                |m: &DeleteDefinedColumnRequest| { &m.columns },
                |m: &mut DeleteDefinedColumnRequest| { &mut m.columns },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteDefinedColumnRequest>(
                "DeleteDefinedColumnRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteDefinedColumnRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteDefinedColumnRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteDefinedColumnRequest::new)
    }
}

impl ::protobuf::Clear for DeleteDefinedColumnRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.columns.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteDefinedColumnRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDefinedColumnRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteDefinedColumnResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteDefinedColumnResponse {
    fn default() -> &'a DeleteDefinedColumnResponse {
        <DeleteDefinedColumnResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteDefinedColumnResponse {
    pub fn new() -> DeleteDefinedColumnResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteDefinedColumnResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteDefinedColumnResponse {
        DeleteDefinedColumnResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteDefinedColumnResponse>(
                "DeleteDefinedColumnResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteDefinedColumnResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteDefinedColumnResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteDefinedColumnResponse::new)
    }
}

impl ::protobuf::Clear for DeleteDefinedColumnResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteDefinedColumnResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDefinedColumnResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartLocalTransactionRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartLocalTransactionRequest {
    fn default() -> &'a StartLocalTransactionRequest {
        <StartLocalTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartLocalTransactionRequest {
    pub fn new() -> StartLocalTransactionRequest {
        ::std::default::Default::default()
    }

    // required string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        match self.key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        self.key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StartLocalTransactionRequest {
    fn is_initialized(&self) -> bool {
        if self.table_name.is_none() {
            return false;
        }
        if self.key.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartLocalTransactionRequest {
        StartLocalTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &StartLocalTransactionRequest| { &m.table_name },
                |m: &mut StartLocalTransactionRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "key",
                |m: &StartLocalTransactionRequest| { &m.key },
                |m: &mut StartLocalTransactionRequest| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartLocalTransactionRequest>(
                "StartLocalTransactionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartLocalTransactionRequest {
        static instance: ::protobuf::rt::LazyV2<StartLocalTransactionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartLocalTransactionRequest::new)
    }
}

impl ::protobuf::Clear for StartLocalTransactionRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartLocalTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartLocalTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartLocalTransactionResponse {
    // message fields
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartLocalTransactionResponse {
    fn default() -> &'a StartLocalTransactionResponse {
        <StartLocalTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartLocalTransactionResponse {
    pub fn new() -> StartLocalTransactionResponse {
        ::std::default::Default::default()
    }

    // required string transaction_id = 1;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StartLocalTransactionResponse {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartLocalTransactionResponse {
        StartLocalTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &StartLocalTransactionResponse| { &m.transaction_id },
                |m: &mut StartLocalTransactionResponse| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartLocalTransactionResponse>(
                "StartLocalTransactionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartLocalTransactionResponse {
        static instance: ::protobuf::rt::LazyV2<StartLocalTransactionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartLocalTransactionResponse::new)
    }
}

impl ::protobuf::Clear for StartLocalTransactionResponse {
    fn clear(&mut self) {
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartLocalTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartLocalTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitTransactionRequest {
    // message fields
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitTransactionRequest {
    fn default() -> &'a CommitTransactionRequest {
        <CommitTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CommitTransactionRequest {
    pub fn new() -> CommitTransactionRequest {
        ::std::default::Default::default()
    }

    // required string transaction_id = 1;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CommitTransactionRequest {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitTransactionRequest {
        CommitTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &CommitTransactionRequest| { &m.transaction_id },
                |m: &mut CommitTransactionRequest| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitTransactionRequest>(
                "CommitTransactionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitTransactionRequest {
        static instance: ::protobuf::rt::LazyV2<CommitTransactionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitTransactionRequest::new)
    }
}

impl ::protobuf::Clear for CommitTransactionRequest {
    fn clear(&mut self) {
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitTransactionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommitTransactionResponse {
    fn default() -> &'a CommitTransactionResponse {
        <CommitTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommitTransactionResponse {
    pub fn new() -> CommitTransactionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommitTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitTransactionResponse {
        CommitTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommitTransactionResponse>(
                "CommitTransactionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommitTransactionResponse {
        static instance: ::protobuf::rt::LazyV2<CommitTransactionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommitTransactionResponse::new)
    }
}

impl ::protobuf::Clear for CommitTransactionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbortTransactionRequest {
    // message fields
    transaction_id: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbortTransactionRequest {
    fn default() -> &'a AbortTransactionRequest {
        <AbortTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AbortTransactionRequest {
    pub fn new() -> AbortTransactionRequest {
        ::std::default::Default::default()
    }

    // required string transaction_id = 1;


    pub fn get_transaction_id(&self) -> &str {
        match self.transaction_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_transaction_id(&mut self) {
        self.transaction_id.clear();
    }

    pub fn has_transaction_id(&self) -> bool {
        self.transaction_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction_id(&mut self, v: ::std::string::String) {
        self.transaction_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction_id(&mut self) -> &mut ::std::string::String {
        if self.transaction_id.is_none() {
            self.transaction_id.set_default();
        }
        self.transaction_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction_id(&mut self) -> ::std::string::String {
        self.transaction_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AbortTransactionRequest {
    fn is_initialized(&self) -> bool {
        if self.transaction_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.transaction_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction_id.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbortTransactionRequest {
        AbortTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "transaction_id",
                |m: &AbortTransactionRequest| { &m.transaction_id },
                |m: &mut AbortTransactionRequest| { &mut m.transaction_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AbortTransactionRequest>(
                "AbortTransactionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AbortTransactionRequest {
        static instance: ::protobuf::rt::LazyV2<AbortTransactionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AbortTransactionRequest::new)
    }
}

impl ::protobuf::Clear for AbortTransactionRequest {
    fn clear(&mut self) {
        self.transaction_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbortTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbortTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AbortTransactionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AbortTransactionResponse {
    fn default() -> &'a AbortTransactionResponse {
        <AbortTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AbortTransactionResponse {
    pub fn new() -> AbortTransactionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AbortTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AbortTransactionResponse {
        AbortTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AbortTransactionResponse>(
                "AbortTransactionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AbortTransactionResponse {
        static instance: ::protobuf::rt::LazyV2<AbortTransactionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AbortTransactionResponse::new)
    }
}

impl ::protobuf::Clear for AbortTransactionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AbortTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AbortTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputeSplitsRequest {
    // message fields
    table_name: ::protobuf::SingularField<::std::string::String>,
    pub search_index_splits_options: ::protobuf::SingularPtrField<SearchIndexSplitsOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputeSplitsRequest {
    fn default() -> &'a ComputeSplitsRequest {
        <ComputeSplitsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ComputeSplitsRequest {
    pub fn new() -> ComputeSplitsRequest {
        ::std::default::Default::default()
    }

    // optional string table_name = 1;


    pub fn get_table_name(&self) -> &str {
        match self.table_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    pub fn has_table_name(&self) -> bool {
        self.table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        if self.table_name.is_none() {
            self.table_name.set_default();
        }
        self.table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .proto.SearchIndexSplitsOptions search_index_splits_options = 2;


    pub fn get_search_index_splits_options(&self) -> &SearchIndexSplitsOptions {
        self.search_index_splits_options.as_ref().unwrap_or_else(|| <SearchIndexSplitsOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_search_index_splits_options(&mut self) {
        self.search_index_splits_options.clear();
    }

    pub fn has_search_index_splits_options(&self) -> bool {
        self.search_index_splits_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_index_splits_options(&mut self, v: SearchIndexSplitsOptions) {
        self.search_index_splits_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_index_splits_options(&mut self) -> &mut SearchIndexSplitsOptions {
        if self.search_index_splits_options.is_none() {
            self.search_index_splits_options.set_default();
        }
        self.search_index_splits_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_index_splits_options(&mut self) -> SearchIndexSplitsOptions {
        self.search_index_splits_options.take().unwrap_or_else(|| SearchIndexSplitsOptions::new())
    }
}

impl ::protobuf::Message for ComputeSplitsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.search_index_splits_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.table_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.search_index_splits_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.search_index_splits_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.table_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.search_index_splits_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputeSplitsRequest {
        ComputeSplitsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "table_name",
                |m: &ComputeSplitsRequest| { &m.table_name },
                |m: &mut ComputeSplitsRequest| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SearchIndexSplitsOptions>>(
                "search_index_splits_options",
                |m: &ComputeSplitsRequest| { &m.search_index_splits_options },
                |m: &mut ComputeSplitsRequest| { &mut m.search_index_splits_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputeSplitsRequest>(
                "ComputeSplitsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputeSplitsRequest {
        static instance: ::protobuf::rt::LazyV2<ComputeSplitsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputeSplitsRequest::new)
    }
}

impl ::protobuf::Clear for ComputeSplitsRequest {
    fn clear(&mut self) {
        self.table_name.clear();
        self.search_index_splits_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputeSplitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeSplitsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchIndexSplitsOptions {
    // message fields
    index_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchIndexSplitsOptions {
    fn default() -> &'a SearchIndexSplitsOptions {
        <SearchIndexSplitsOptions as ::protobuf::Message>::default_instance()
    }
}

impl SearchIndexSplitsOptions {
    pub fn new() -> SearchIndexSplitsOptions {
        ::std::default::Default::default()
    }

    // optional string index_name = 1;


    pub fn get_index_name(&self) -> &str {
        match self.index_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_index_name(&mut self) {
        self.index_name.clear();
    }

    pub fn has_index_name(&self) -> bool {
        self.index_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index_name(&mut self, v: ::std::string::String) {
        self.index_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_index_name(&mut self) -> &mut ::std::string::String {
        if self.index_name.is_none() {
            self.index_name.set_default();
        }
        self.index_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_index_name(&mut self) -> ::std::string::String {
        self.index_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchIndexSplitsOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.index_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.index_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.index_name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchIndexSplitsOptions {
        SearchIndexSplitsOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "index_name",
                |m: &SearchIndexSplitsOptions| { &m.index_name },
                |m: &mut SearchIndexSplitsOptions| { &mut m.index_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchIndexSplitsOptions>(
                "SearchIndexSplitsOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchIndexSplitsOptions {
        static instance: ::protobuf::rt::LazyV2<SearchIndexSplitsOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchIndexSplitsOptions::new)
    }
}

impl ::protobuf::Clear for SearchIndexSplitsOptions {
    fn clear(&mut self) {
        self.index_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchIndexSplitsOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchIndexSplitsOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputeSplitsResponse {
    // message fields
    session_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    splits_size: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputeSplitsResponse {
    fn default() -> &'a ComputeSplitsResponse {
        <ComputeSplitsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComputeSplitsResponse {
    pub fn new() -> ComputeSplitsResponse {
        ::std::default::Default::default()
    }

    // optional bytes session_id = 1;


    pub fn get_session_id(&self) -> &[u8] {
        match self.session_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_session_id(&mut self) {
        self.session_id.clear();
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.session_id.is_none() {
            self.session_id.set_default();
        }
        self.session_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_id(&mut self) -> ::std::vec::Vec<u8> {
        self.session_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 splits_size = 2;


    pub fn get_splits_size(&self) -> i32 {
        self.splits_size.unwrap_or(0)
    }
    pub fn clear_splits_size(&mut self) {
        self.splits_size = ::std::option::Option::None;
    }

    pub fn has_splits_size(&self) -> bool {
        self.splits_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_splits_size(&mut self, v: i32) {
        self.splits_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ComputeSplitsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.session_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.splits_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.session_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.splits_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.session_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.splits_size {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputeSplitsResponse {
        ComputeSplitsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "session_id",
                |m: &ComputeSplitsResponse| { &m.session_id },
                |m: &mut ComputeSplitsResponse| { &mut m.session_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "splits_size",
                |m: &ComputeSplitsResponse| { &m.splits_size },
                |m: &mut ComputeSplitsResponse| { &mut m.splits_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputeSplitsResponse>(
                "ComputeSplitsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputeSplitsResponse {
        static instance: ::protobuf::rt::LazyV2<ComputeSplitsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputeSplitsResponse::new)
    }
}

impl ::protobuf::Clear for ComputeSplitsResponse {
    fn clear(&mut self) {
        self.session_id.clear();
        self.splits_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputeSplitsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeSplitsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrimaryKeyType {
    INTEGER = 1,
    STRING = 2,
    BINARY = 3,
}

impl ::protobuf::ProtobufEnum for PrimaryKeyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrimaryKeyType> {
        match value {
            1 => ::std::option::Option::Some(PrimaryKeyType::INTEGER),
            2 => ::std::option::Option::Some(PrimaryKeyType::STRING),
            3 => ::std::option::Option::Some(PrimaryKeyType::BINARY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrimaryKeyType] = &[
            PrimaryKeyType::INTEGER,
            PrimaryKeyType::STRING,
            PrimaryKeyType::BINARY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PrimaryKeyType>("PrimaryKeyType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PrimaryKeyType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PrimaryKeyType {
    fn default() -> Self {
        PrimaryKeyType::INTEGER
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimaryKeyType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrimaryKeyOption {
    AUTO_INCREMENT = 1,
}

impl ::protobuf::ProtobufEnum for PrimaryKeyOption {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrimaryKeyOption> {
        match value {
            1 => ::std::option::Option::Some(PrimaryKeyOption::AUTO_INCREMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrimaryKeyOption] = &[
            PrimaryKeyOption::AUTO_INCREMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PrimaryKeyOption>("PrimaryKeyOption", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PrimaryKeyOption {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PrimaryKeyOption {
    fn default() -> Self {
        PrimaryKeyOption::AUTO_INCREMENT
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimaryKeyOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BloomFilterType {
    NONE = 1,
    CELL = 2,
    ROW = 3,
}

impl ::protobuf::ProtobufEnum for BloomFilterType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BloomFilterType> {
        match value {
            1 => ::std::option::Option::Some(BloomFilterType::NONE),
            2 => ::std::option::Option::Some(BloomFilterType::CELL),
            3 => ::std::option::Option::Some(BloomFilterType::ROW),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BloomFilterType] = &[
            BloomFilterType::NONE,
            BloomFilterType::CELL,
            BloomFilterType::ROW,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BloomFilterType>("BloomFilterType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BloomFilterType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for BloomFilterType {
    fn default() -> Self {
        BloomFilterType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for BloomFilterType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TableStatus {
    ACTIVE = 1,
    INACTIVE = 2,
    LOADING = 3,
    UNLOADING = 4,
    UPDATING = 5,
}

impl ::protobuf::ProtobufEnum for TableStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TableStatus> {
        match value {
            1 => ::std::option::Option::Some(TableStatus::ACTIVE),
            2 => ::std::option::Option::Some(TableStatus::INACTIVE),
            3 => ::std::option::Option::Some(TableStatus::LOADING),
            4 => ::std::option::Option::Some(TableStatus::UNLOADING),
            5 => ::std::option::Option::Some(TableStatus::UPDATING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TableStatus] = &[
            TableStatus::ACTIVE,
            TableStatus::INACTIVE,
            TableStatus::LOADING,
            TableStatus::UNLOADING,
            TableStatus::UPDATING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TableStatus>("TableStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TableStatus {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TableStatus {
    fn default() -> Self {
        TableStatus::ACTIVE
    }
}

impl ::protobuf::reflect::ProtobufValue for TableStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RowExistenceExpectation {
    IGNORE = 0,
    EXPECT_EXIST = 1,
    EXPECT_NOT_EXIST = 2,
}

impl ::protobuf::ProtobufEnum for RowExistenceExpectation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RowExistenceExpectation> {
        match value {
            0 => ::std::option::Option::Some(RowExistenceExpectation::IGNORE),
            1 => ::std::option::Option::Some(RowExistenceExpectation::EXPECT_EXIST),
            2 => ::std::option::Option::Some(RowExistenceExpectation::EXPECT_NOT_EXIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RowExistenceExpectation] = &[
            RowExistenceExpectation::IGNORE,
            RowExistenceExpectation::EXPECT_EXIST,
            RowExistenceExpectation::EXPECT_NOT_EXIST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RowExistenceExpectation>("RowExistenceExpectation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RowExistenceExpectation {
}

impl ::std::default::Default for RowExistenceExpectation {
    fn default() -> Self {
        RowExistenceExpectation::IGNORE
    }
}

impl ::protobuf::reflect::ProtobufValue for RowExistenceExpectation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ReturnType {
    RT_NONE = 0,
    RT_PK = 1,
    RT_AFTER_MODIFY = 2,
}

impl ::protobuf::ProtobufEnum for ReturnType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReturnType> {
        match value {
            0 => ::std::option::Option::Some(ReturnType::RT_NONE),
            1 => ::std::option::Option::Some(ReturnType::RT_PK),
            2 => ::std::option::Option::Some(ReturnType::RT_AFTER_MODIFY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ReturnType] = &[
            ReturnType::RT_NONE,
            ReturnType::RT_PK,
            ReturnType::RT_AFTER_MODIFY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ReturnType>("ReturnType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ReturnType {
}

impl ::std::default::Default for ReturnType {
    fn default() -> Self {
        ReturnType::RT_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ReturnType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperationType {
    PUT = 1,
    UPDATE = 2,
    DELETE = 3,
}

impl ::protobuf::ProtobufEnum for OperationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperationType> {
        match value {
            1 => ::std::option::Option::Some(OperationType::PUT),
            2 => ::std::option::Option::Some(OperationType::UPDATE),
            3 => ::std::option::Option::Some(OperationType::DELETE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperationType] = &[
            OperationType::PUT,
            OperationType::UPDATE,
            OperationType::DELETE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OperationType>("OperationType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OperationType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for OperationType {
    fn default() -> Self {
        OperationType::PUT
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Direction {
    FORWARD = 0,
    BACKWARD = 1,
}

impl ::protobuf::ProtobufEnum for Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            0 => ::std::option::Option::Some(Direction::FORWARD),
            1 => ::std::option::Option::Some(Direction::BACKWARD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Direction] = &[
            Direction::FORWARD,
            Direction::BACKWARD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Direction>("Direction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Direction {
}

impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::FORWARD
    }
}

impl ::protobuf::reflect::ProtobufValue for Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StreamStatus {
    STREAM_ENABLING = 1,
    STREAM_ACTIVE = 2,
}

impl ::protobuf::ProtobufEnum for StreamStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StreamStatus> {
        match value {
            1 => ::std::option::Option::Some(StreamStatus::STREAM_ENABLING),
            2 => ::std::option::Option::Some(StreamStatus::STREAM_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StreamStatus] = &[
            StreamStatus::STREAM_ENABLING,
            StreamStatus::STREAM_ACTIVE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StreamStatus>("StreamStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StreamStatus {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for StreamStatus {
    fn default() -> Self {
        StreamStatus::STREAM_ENABLING
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ActionType {
    PUT_ROW = 1,
    UPDATE_ROW = 2,
    DELETE_ROW = 3,
}

impl ::protobuf::ProtobufEnum for ActionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActionType> {
        match value {
            1 => ::std::option::Option::Some(ActionType::PUT_ROW),
            2 => ::std::option::Option::Some(ActionType::UPDATE_ROW),
            3 => ::std::option::Option::Some(ActionType::DELETE_ROW),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ActionType] = &[
            ActionType::PUT_ROW,
            ActionType::UPDATE_ROW,
            ActionType::DELETE_ROW,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ActionType>("ActionType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ActionType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ActionType {
    fn default() -> Self {
        ActionType::PUT_ROW
    }
}

impl ::protobuf::reflect::ProtobufValue for ActionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DefinedColumnType {
    DCT_INTEGER = 1,
    DCT_DOUBLE = 2,
    DCT_BOOLEAN = 3,
    DCT_STRING = 4,
    DCT_BLOB = 7,
}

impl ::protobuf::ProtobufEnum for DefinedColumnType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DefinedColumnType> {
        match value {
            1 => ::std::option::Option::Some(DefinedColumnType::DCT_INTEGER),
            2 => ::std::option::Option::Some(DefinedColumnType::DCT_DOUBLE),
            3 => ::std::option::Option::Some(DefinedColumnType::DCT_BOOLEAN),
            4 => ::std::option::Option::Some(DefinedColumnType::DCT_STRING),
            7 => ::std::option::Option::Some(DefinedColumnType::DCT_BLOB),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DefinedColumnType] = &[
            DefinedColumnType::DCT_INTEGER,
            DefinedColumnType::DCT_DOUBLE,
            DefinedColumnType::DCT_BOOLEAN,
            DefinedColumnType::DCT_STRING,
            DefinedColumnType::DCT_BLOB,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DefinedColumnType>("DefinedColumnType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DefinedColumnType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for DefinedColumnType {
    fn default() -> Self {
        DefinedColumnType::DCT_INTEGER
    }
}

impl ::protobuf::reflect::ProtobufValue for DefinedColumnType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IndexUpdateMode {
    IUM_ASYNC_INDEX = 0,
    IUM_SYNC_INDEX = 1,
}

impl ::protobuf::ProtobufEnum for IndexUpdateMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IndexUpdateMode> {
        match value {
            0 => ::std::option::Option::Some(IndexUpdateMode::IUM_ASYNC_INDEX),
            1 => ::std::option::Option::Some(IndexUpdateMode::IUM_SYNC_INDEX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IndexUpdateMode] = &[
            IndexUpdateMode::IUM_ASYNC_INDEX,
            IndexUpdateMode::IUM_SYNC_INDEX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<IndexUpdateMode>("IndexUpdateMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for IndexUpdateMode {
}

impl ::std::default::Default for IndexUpdateMode {
    fn default() -> Self {
        IndexUpdateMode::IUM_ASYNC_INDEX
    }
}

impl ::protobuf::reflect::ProtobufValue for IndexUpdateMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum IndexType {
    IT_GLOBAL_INDEX = 0,
    IT_LOCAL_INDEX = 1,
}

impl ::protobuf::ProtobufEnum for IndexType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<IndexType> {
        match value {
            0 => ::std::option::Option::Some(IndexType::IT_GLOBAL_INDEX),
            1 => ::std::option::Option::Some(IndexType::IT_LOCAL_INDEX),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [IndexType] = &[
            IndexType::IT_GLOBAL_INDEX,
            IndexType::IT_LOCAL_INDEX,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<IndexType>("IndexType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for IndexType {
}

impl ::std::default::Default for IndexType {
    fn default() -> Self {
        IndexType::IT_GLOBAL_INDEX
    }
}

impl ::protobuf::reflect::ProtobufValue for IndexType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11table_store.proto\x12\x05proto\"5\n\x05Error\x12\x12\n\x04code\x18\
    \x01\x20\x02(\tR\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07mes\
    sage\"\x82\x01\n\x10PrimaryKeySchema\x12\x12\n\x04name\x18\x01\x20\x02(\
    \tR\x04name\x12)\n\x04type\x18\x02\x20\x02(\x0e2\x15.proto.PrimaryKeyTyp\
    eR\x04type\x12/\n\x06option\x18\x03\x20\x01(\x0e2\x17.proto.PrimaryKeyOp\
    tionR\x06option\"8\n\x0ePartitionRange\x12\x14\n\x05begin\x18\x01\x20\
    \x02(\x0cR\x05begin\x12\x10\n\x03end\x18\x02\x20\x02(\x0cR\x03end\"\xf8\
    \x01\n\x0cTableOptions\x12\x20\n\x0ctime_to_live\x18\x01\x20\x01(\x05R\n\
    timeToLive\x12!\n\x0cmax_versions\x18\x02\x20\x01(\x05R\x0bmaxVersions\
    \x12B\n\x11bloom_filter_type\x18\x03\x20\x01(\x0e2\x16.proto.BloomFilter\
    TypeR\x0fbloomFilterType\x12\x1d\n\nblock_size\x18\x04\x20\x01(\x05R\tbl\
    ockSize\x12@\n\x1ddeviation_cell_version_in_sec\x18\x05\x20\x01(\x03R\
    \x19deviationCellVersionInSec\"\xd8\x01\n\tTableMeta\x12\x1d\n\ntable_na\
    me\x18\x01\x20\x02(\tR\ttableName\x128\n\x0bprimary_key\x18\x02\x20\x03(\
    \x0b2\x17.proto.PrimaryKeySchemaR\nprimaryKey\x12A\n\x0edefined_column\
    \x18\x03\x20\x03(\x0b2\x1a.proto.DefinedColumnSchemaR\rdefinedColumn\x12\
    /\n\nindex_meta\x18\x04\x20\x03(\x0b2\x10.proto.IndexMetaR\tindexMeta\"{\
    \n\tCondition\x12C\n\rrow_existence\x18\x01\x20\x02(\x0e2\x1e.proto.RowE\
    xistenceExpectationR\x0crowExistence\x12)\n\x10column_condition\x18\x02\
    \x20\x01(\x0cR\x0fcolumnCondition\"8\n\x0cCapacityUnit\x12\x12\n\x04read\
    \x18\x01\x20\x01(\x05R\x04read\x12\x14\n\x05write\x18\x02\x20\x01(\x05R\
    \x05write\"\xb1\x01\n\x19ReservedThroughputDetails\x128\n\rcapacity_unit\
    \x18\x01\x20\x02(\x0b2\x13.proto.CapacityUnitR\x0ccapacityUnit\x12,\n\
    \x12last_increase_time\x18\x02\x20\x02(\x03R\x10lastIncreaseTime\x12,\n\
    \x12last_decrease_time\x18\x03\x20\x01(\x03R\x10lastDecreaseTime\"N\n\
    \x12ReservedThroughput\x128\n\rcapacity_unit\x18\x01\x20\x02(\x0b2\x13.p\
    roto.CapacityUnitR\x0ccapacityUnit\"L\n\x10ConsumedCapacity\x128\n\rcapa\
    city_unit\x18\x01\x20\x02(\x0b2\x13.proto.CapacityUnitR\x0ccapacityUnit\
    \"c\n\x13StreamSpecification\x12#\n\renable_stream\x18\x01\x20\x02(\x08R\
    \x0cenableStream\x12'\n\x0fexpiration_time\x18\x02\x20\x01(\x05R\x0eexpi\
    rationTime\"\xa4\x01\n\rStreamDetails\x12#\n\renable_stream\x18\x01\x20\
    \x02(\x08R\x0cenableStream\x12\x1b\n\tstream_id\x18\x02\x20\x01(\tR\x08s\
    treamId\x12'\n\x0fexpiration_time\x18\x03\x20\x01(\x05R\x0eexpirationTim\
    e\x12(\n\x10last_enable_time\x18\x04\x20\x01(\x03R\x0elastEnableTime\"\
    \xf2\x02\n\x12CreateTableRequest\x12/\n\ntable_meta\x18\x01\x20\x02(\x0b\
    2\x10.proto.TableMetaR\ttableMeta\x12J\n\x13reserved_throughput\x18\x02\
    \x20\x02(\x0b2\x19.proto.ReservedThroughputR\x12reservedThroughput\x128\
    \n\rtable_options\x18\x03\x20\x01(\x0b2\x13.proto.TableOptionsR\x0ctable\
    Options\x125\n\npartitions\x18\x04\x20\x03(\x0b2\x15.proto.PartitionRang\
    eR\npartitions\x12;\n\x0bstream_spec\x18\x05\x20\x01(\x0b2\x1a.proto.Str\
    eamSpecificationR\nstreamSpec\x121\n\x0bindex_metas\x18\x07\x20\x03(\x0b\
    2\x10.proto.IndexMetaR\nindexMetas\"\x15\n\x13CreateTableResponse\"\xf6\
    \x01\n\x12UpdateTableRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\t\
    tableName\x12J\n\x13reserved_throughput\x18\x02\x20\x01(\x0b2\x19.proto.\
    ReservedThroughputR\x12reservedThroughput\x128\n\rtable_options\x18\x03\
    \x20\x01(\x0b2\x13.proto.TableOptionsR\x0ctableOptions\x12;\n\x0bstream_\
    spec\x18\x04\x20\x01(\x0b2\x1a.proto.StreamSpecificationR\nstreamSpec\"\
    \xee\x01\n\x13UpdateTableResponse\x12`\n\x1breserved_throughput_details\
    \x18\x01\x20\x02(\x0b2\x20.proto.ReservedThroughputDetailsR\x19reservedT\
    hroughputDetails\x128\n\rtable_options\x18\x02\x20\x02(\x0b2\x13.proto.T\
    ableOptionsR\x0ctableOptions\x12;\n\x0estream_details\x18\x03\x20\x01(\
    \x0b2\x14.proto.StreamDetailsR\rstreamDetails\"5\n\x14DescribeTableReque\
    st\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\ttableName\"\xae\x03\n\x15D\
    escribeTableResponse\x12/\n\ntable_meta\x18\x01\x20\x02(\x0b2\x10.proto.\
    TableMetaR\ttableMeta\x12`\n\x1breserved_throughput_details\x18\x02\x20\
    \x02(\x0b2\x20.proto.ReservedThroughputDetailsR\x19reservedThroughputDet\
    ails\x128\n\rtable_options\x18\x03\x20\x02(\x0b2\x13.proto.TableOptionsR\
    \x0ctableOptions\x125\n\x0ctable_status\x18\x04\x20\x02(\x0e2\x12.proto.\
    TableStatusR\x0btableStatus\x12;\n\x0estream_details\x18\x05\x20\x01(\
    \x0b2\x14.proto.StreamDetailsR\rstreamDetails\x12!\n\x0cshard_splits\x18\
    \x06\x20\x03(\x0cR\x0bshardSplits\x121\n\x0bindex_metas\x18\x08\x20\x03(\
    \x0b2\x10.proto.IndexMetaR\nindexMetas\"\x12\n\x10ListTableRequest\"4\n\
    \x11ListTableResponse\x12\x1f\n\x0btable_names\x18\x01\x20\x03(\tR\ntabl\
    eNames\"3\n\x12DeleteTableRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\
    \tR\ttableName\"\x15\n\x13DeleteTableResponse\"1\n\x10LoadTableRequest\
    \x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\ttableName\"\x13\n\x11LoadTab\
    leResponse\"3\n\x12UnloadTableRequest\x12\x1d\n\ntable_name\x18\x01\x20\
    \x02(\tR\ttableName\"\x15\n\x13UnloadTableResponse\"j\n\tTimeRange\x12\
    \x1d\n\nstart_time\x18\x01\x20\x01(\x03R\tstartTime\x12\x19\n\x08end_tim\
    e\x18\x02\x20\x01(\x03R\x07endTime\x12#\n\rspecific_time\x18\x03\x20\x01\
    (\x03R\x0cspecificTime\"s\n\rReturnContent\x122\n\x0breturn_type\x18\x01\
    \x20\x01(\x0e2\x11.proto.ReturnTypeR\nreturnType\x12.\n\x13return_column\
    _names\x18\x02\x20\x03(\tR\x11returnColumnNames\"\x89\x03\n\rGetRowReque\
    st\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\ttableName\x12\x1f\n\x0bpri\
    mary_key\x18\x02\x20\x02(\x0cR\nprimaryKey\x12$\n\x0ecolumns_to_get\x18\
    \x03\x20\x03(\tR\x0ccolumnsToGet\x12/\n\ntime_range\x18\x04\x20\x01(\x0b\
    2\x10.proto.TimeRangeR\ttimeRange\x12!\n\x0cmax_versions\x18\x05\x20\x01\
    (\x05R\x0bmaxVersions\x12'\n\x0ccache_blocks\x18\x06\x20\x01(\x08:\x04tr\
    ueR\x0bcacheBlocks\x12\x16\n\x06filter\x18\x07\x20\x01(\x0cR\x06filter\
    \x12!\n\x0cstart_column\x18\x08\x20\x01(\tR\x0bstartColumn\x12\x1d\n\nen\
    d_column\x18\t\x20\x01(\tR\tendColumn\x12\x14\n\x05token\x18\n\x20\x01(\
    \x0cR\x05token\x12%\n\x0etransaction_id\x18\x0b\x20\x01(\tR\rtransaction\
    Id\"v\n\x0eGetRowResponse\x123\n\x08consumed\x18\x01\x20\x02(\x0b2\x17.p\
    roto.ConsumedCapacityR\x08consumed\x12\x10\n\x03row\x18\x02\x20\x02(\x0c\
    R\x03row\x12\x1d\n\nnext_token\x18\x03\x20\x01(\x0cR\tnextToken\"\xe4\
    \x01\n\x10UpdateRowRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\tta\
    bleName\x12\x1d\n\nrow_change\x18\x02\x20\x02(\x0cR\trowChange\x12.\n\tc\
    ondition\x18\x03\x20\x02(\x0b2\x10.proto.ConditionR\tcondition\x12;\n\
    \x0ereturn_content\x18\x04\x20\x01(\x0b2\x14.proto.ReturnContentR\rretur\
    nContent\x12%\n\x0etransaction_id\x18\x05\x20\x01(\tR\rtransactionId\"Z\
    \n\x11UpdateRowResponse\x123\n\x08consumed\x18\x01\x20\x02(\x0b2\x17.pro\
    to.ConsumedCapacityR\x08consumed\x12\x10\n\x03row\x18\x02\x20\x01(\x0cR\
    \x03row\"\xd4\x01\n\rPutRowRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02\
    (\tR\ttableName\x12\x10\n\x03row\x18\x02\x20\x02(\x0cR\x03row\x12.\n\tco\
    ndition\x18\x03\x20\x02(\x0b2\x10.proto.ConditionR\tcondition\x12;\n\x0e\
    return_content\x18\x04\x20\x01(\x0b2\x14.proto.ReturnContentR\rreturnCon\
    tent\x12%\n\x0etransaction_id\x18\x05\x20\x01(\tR\rtransactionId\"W\n\
    \x0ePutRowResponse\x123\n\x08consumed\x18\x01\x20\x02(\x0b2\x17.proto.Co\
    nsumedCapacityR\x08consumed\x12\x10\n\x03row\x18\x02\x20\x01(\x0cR\x03ro\
    w\"\xe6\x01\n\x10DeleteRowRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\
    \tR\ttableName\x12\x1f\n\x0bprimary_key\x18\x02\x20\x02(\x0cR\nprimaryKe\
    y\x12.\n\tcondition\x18\x03\x20\x02(\x0b2\x10.proto.ConditionR\tconditio\
    n\x12;\n\x0ereturn_content\x18\x04\x20\x01(\x0b2\x14.proto.ReturnContent\
    R\rreturnContent\x12%\n\x0etransaction_id\x18\x05\x20\x01(\tR\rtransacti\
    onId\"Z\n\x11DeleteRowResponse\x123\n\x08consumed\x18\x01\x20\x02(\x0b2\
    \x17.proto.ConsumedCapacityR\x08consumed\x12\x10\n\x03row\x18\x02\x20\
    \x01(\x0cR\x03row\"\xee\x02\n\x19TableInBatchGetRowRequest\x12\x1d\n\nta\
    ble_name\x18\x01\x20\x02(\tR\ttableName\x12\x1f\n\x0bprimary_key\x18\x02\
    \x20\x03(\x0cR\nprimaryKey\x12\x14\n\x05token\x18\x03\x20\x03(\x0cR\x05t\
    oken\x12$\n\x0ecolumns_to_get\x18\x04\x20\x03(\tR\x0ccolumnsToGet\x12/\n\
    \ntime_range\x18\x05\x20\x01(\x0b2\x10.proto.TimeRangeR\ttimeRange\x12!\
    \n\x0cmax_versions\x18\x06\x20\x01(\x05R\x0bmaxVersions\x12'\n\x0ccache_\
    blocks\x18\x07\x20\x01(\x08:\x04trueR\x0bcacheBlocks\x12\x16\n\x06filter\
    \x18\x08\x20\x01(\x0cR\x06filter\x12!\n\x0cstart_column\x18\t\x20\x01(\t\
    R\x0bstartColumn\x12\x1d\n\nend_column\x18\n\x20\x01(\tR\tendColumn\"N\n\
    \x12BatchGetRowRequest\x128\n\x06tables\x18\x01\x20\x03(\x0b2\x20.proto.\
    TableInBatchGetRowRequestR\x06tables\"\xb9\x01\n\x18RowInBatchGetRowResp\
    onse\x12\x13\n\x05is_ok\x18\x01\x20\x02(\x08R\x04isOk\x12\"\n\x05error\
    \x18\x02\x20\x01(\x0b2\x0c.proto.ErrorR\x05error\x123\n\x08consumed\x18\
    \x03\x20\x01(\x0b2\x17.proto.ConsumedCapacityR\x08consumed\x12\x10\n\x03\
    row\x18\x04\x20\x01(\x0cR\x03row\x12\x1d\n\nnext_token\x18\x05\x20\x01(\
    \x0cR\tnextToken\"p\n\x1aTableInBatchGetRowResponse\x12\x1d\n\ntable_nam\
    e\x18\x01\x20\x02(\tR\ttableName\x123\n\x04rows\x18\x02\x20\x03(\x0b2\
    \x1f.proto.RowInBatchGetRowResponseR\x04rows\"P\n\x13BatchGetRowResponse\
    \x129\n\x06tables\x18\x01\x20\x03(\x0b2!.proto.TableInBatchGetRowRespons\
    eR\x06tables\"\xd1\x01\n\x19RowInBatchWriteRowRequest\x12(\n\x04type\x18\
    \x01\x20\x02(\x0e2\x14.proto.OperationTypeR\x04type\x12\x1d\n\nrow_chang\
    e\x18\x02\x20\x02(\x0cR\trowChange\x12.\n\tcondition\x18\x03\x20\x02(\
    \x0b2\x10.proto.ConditionR\tcondition\x12;\n\x0ereturn_content\x18\x04\
    \x20\x01(\x0b2\x14.proto.ReturnContentR\rreturnContent\"r\n\x1bTableInBa\
    tchWriteRowRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\ttableName\
    \x124\n\x04rows\x18\x02\x20\x03(\x0b2\x20.proto.RowInBatchWriteRowReques\
    tR\x04rows\"\x96\x01\n\x14BatchWriteRowRequest\x12:\n\x06tables\x18\x01\
    \x20\x03(\x0b2\".proto.TableInBatchWriteRowRequestR\x06tables\x12%\n\x0e\
    transaction_id\x18\x02\x20\x01(\tR\rtransactionId\x12\x1b\n\tis_atomic\
    \x18\x03\x20\x01(\x08R\x08isAtomic\"\x9c\x01\n\x1aRowInBatchWriteRowResp\
    onse\x12\x13\n\x05is_ok\x18\x01\x20\x02(\x08R\x04isOk\x12\"\n\x05error\
    \x18\x02\x20\x01(\x0b2\x0c.proto.ErrorR\x05error\x123\n\x08consumed\x18\
    \x03\x20\x01(\x0b2\x17.proto.ConsumedCapacityR\x08consumed\x12\x10\n\x03\
    row\x18\x04\x20\x01(\x0cR\x03row\"t\n\x1cTableInBatchWriteRowResponse\
    \x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\ttableName\x125\n\x04rows\x18\
    \x02\x20\x03(\x0b2!.proto.RowInBatchWriteRowResponseR\x04rows\"T\n\x15Ba\
    tchWriteRowResponse\x12;\n\x06tables\x18\x01\x20\x03(\x0b2#.proto.TableI\
    nBatchWriteRowResponseR\x06tables\"\xaa\x04\n\x0fGetRangeRequest\x12\x1d\
    \n\ntable_name\x18\x01\x20\x02(\tR\ttableName\x12.\n\tdirection\x18\x02\
    \x20\x02(\x0e2\x10.proto.DirectionR\tdirection\x12$\n\x0ecolumns_to_get\
    \x18\x03\x20\x03(\tR\x0ccolumnsToGet\x12/\n\ntime_range\x18\x04\x20\x01(\
    \x0b2\x10.proto.TimeRangeR\ttimeRange\x12!\n\x0cmax_versions\x18\x05\x20\
    \x01(\x05R\x0bmaxVersions\x12\x14\n\x05limit\x18\x06\x20\x01(\x05R\x05li\
    mit\x12=\n\x1binclusive_start_primary_key\x18\x07\x20\x02(\x0cR\x18inclu\
    siveStartPrimaryKey\x129\n\x19exclusive_end_primary_key\x18\x08\x20\x02(\
    \x0cR\x16exclusiveEndPrimaryKey\x12'\n\x0ccache_blocks\x18\t\x20\x01(\
    \x08:\x04trueR\x0bcacheBlocks\x12\x16\n\x06filter\x18\n\x20\x01(\x0cR\
    \x06filter\x12!\n\x0cstart_column\x18\x0b\x20\x01(\tR\x0bstartColumn\x12\
    \x1d\n\nend_column\x18\x0c\x20\x01(\tR\tendColumn\x12\x14\n\x05token\x18\
    \r\x20\x01(\x0cR\x05token\x12%\n\x0etransaction_id\x18\x0e\x20\x01(\tR\r\
    transactionId\"\xaf\x01\n\x10GetRangeResponse\x123\n\x08consumed\x18\x01\
    \x20\x02(\x0b2\x17.proto.ConsumedCapacityR\x08consumed\x12\x12\n\x04rows\
    \x18\x02\x20\x02(\x0cR\x04rows\x123\n\x16next_start_primary_key\x18\x03\
    \x20\x01(\x0cR\x13nextStartPrimaryKey\x12\x1d\n\nnext_token\x18\x04\x20\
    \x01(\x0cR\tnextToken\"2\n\x11ListStreamRequest\x12\x1d\n\ntable_name\
    \x18\x01\x20\x01(\tR\ttableName\"i\n\x06Stream\x12\x1b\n\tstream_id\x18\
    \x01\x20\x02(\tR\x08streamId\x12\x1d\n\ntable_name\x18\x02\x20\x02(\tR\t\
    tableName\x12#\n\rcreation_time\x18\x03\x20\x02(\x03R\x0ccreationTime\"=\
    \n\x12ListStreamResponse\x12'\n\x07streams\x18\x01\x20\x03(\x0b2\r.proto\
    .StreamR\x07streams\"q\n\x0bStreamShard\x12\x19\n\x08shard_id\x18\x01\
    \x20\x02(\tR\x07shardId\x12\x1b\n\tparent_id\x18\x02\x20\x01(\tR\x08pare\
    ntId\x12*\n\x11parent_sibling_id\x18\x03\x20\x01(\tR\x0fparentSiblingId\
    \"\x8e\x01\n\x15DescribeStreamRequest\x12\x1b\n\tstream_id\x18\x01\x20\
    \x02(\tR\x08streamId\x127\n\x18inclusive_start_shard_id\x18\x02\x20\x01(\
    \tR\x15inclusiveStartShardId\x12\x1f\n\x0bshard_limit\x18\x03\x20\x01(\
    \x05R\nshardLimit\"\xac\x02\n\x16DescribeStreamResponse\x12\x1b\n\tstrea\
    m_id\x18\x01\x20\x02(\tR\x08streamId\x12'\n\x0fexpiration_time\x18\x02\
    \x20\x02(\x05R\x0eexpirationTime\x12\x1d\n\ntable_name\x18\x03\x20\x02(\
    \tR\ttableName\x12#\n\rcreation_time\x18\x04\x20\x02(\x03R\x0ccreationTi\
    me\x128\n\rstream_status\x18\x05\x20\x02(\x0e2\x13.proto.StreamStatusR\
    \x0cstreamStatus\x12*\n\x06shards\x18\x06\x20\x03(\x0b2\x12.proto.Stream\
    ShardR\x06shards\x12\"\n\rnext_shard_id\x18\x07\x20\x01(\tR\x0bnextShard\
    Id\"\x85\x01\n\x17GetShardIteratorRequest\x12\x1b\n\tstream_id\x18\x01\
    \x20\x02(\tR\x08streamId\x12\x19\n\x08shard_id\x18\x02\x20\x02(\tR\x07sh\
    ardId\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\x03R\ttimestamp\x12\x14\n\
    \x05token\x18\x04\x20\x01(\tR\x05token\"`\n\x18GetShardIteratorResponse\
    \x12%\n\x0eshard_iterator\x18\x01\x20\x02(\tR\rshardIterator\x12\x1d\n\n\
    next_token\x18\x02\x20\x01(\tR\tnextToken\"U\n\x16GetStreamRecordRequest\
    \x12%\n\x0eshard_iterator\x18\x01\x20\x02(\tR\rshardIterator\x12\x14\n\
    \x05limit\x18\x02\x20\x01(\x05R\x05limit\"\xf9\x01\n\x17GetStreamRecordR\
    esponse\x12R\n\x0estream_records\x18\x01\x20\x03(\x0b2+.proto.GetStreamR\
    ecordResponse.StreamRecordR\rstreamRecords\x12.\n\x13next_shard_iterator\
    \x18\x02\x20\x01(\tR\x11nextShardIterator\x1aZ\n\x0cStreamRecord\x122\n\
    \x0baction_type\x18\x01\x20\x02(\x0e2\x11.proto.ActionTypeR\nactionType\
    \x12\x16\n\x06record\x18\x02\x20\x02(\x0cR\x06record\"_\n\x1fComputeSpli\
    tPointsBySizeRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\ttableNam\
    e\x12\x1d\n\nsplit_size\x18\x02\x20\x02(\x03R\tsplitSize\"\xc5\x02\n\x20\
    ComputeSplitPointsBySizeResponse\x123\n\x08consumed\x18\x01\x20\x02(\x0b\
    2\x17.proto.ConsumedCapacityR\x08consumed\x12/\n\x06schema\x18\x02\x20\
    \x03(\x0b2\x17.proto.PrimaryKeySchemaR\x06schema\x12!\n\x0csplit_points\
    \x18\x03\x20\x03(\x0cR\x0bsplitPoints\x12S\n\tlocations\x18\x04\x20\x03(\
    \x0b25.proto.ComputeSplitPointsBySizeResponse.SplitLocationR\tlocations\
    \x1aC\n\rSplitLocation\x12\x1a\n\x08location\x18\x01\x20\x02(\tR\x08loca\
    tion\x12\x16\n\x06repeat\x18\x02\x20\x02(\x12R\x06repeat\"W\n\x13Defined\
    ColumnSchema\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12,\n\x04typ\
    e\x18\x02\x20\x02(\x0e2\x18.proto.DefinedColumnTypeR\x04type\"\xdc\x01\n\
    \tIndexMeta\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x1f\n\x0bp\
    rimary_key\x18\x02\x20\x03(\tR\nprimaryKey\x12%\n\x0edefined_column\x18\
    \x03\x20\x03(\tR\rdefinedColumn\x12B\n\x11index_update_mode\x18\x04\x20\
    \x02(\x0e2\x16.proto.IndexUpdateModeR\x0findexUpdateMode\x12/\n\nindex_t\
    ype\x18\x05\x20\x02(\x0e2\x10.proto.IndexTypeR\tindexType\"\x99\x01\n\
    \x12CreateIndexRequest\x12&\n\x0fmain_table_name\x18\x01\x20\x02(\tR\rma\
    inTableName\x12/\n\nindex_meta\x18\x02\x20\x02(\x0b2\x10.proto.IndexMeta\
    R\tindexMeta\x12*\n\x11include_base_data\x18\x03\x20\x01(\x08R\x0finclud\
    eBaseData\"\x15\n\x13CreateIndexResponse\"Y\n\x10DropIndexRequest\x12&\n\
    \x0fmain_table_name\x18\x01\x20\x02(\tR\rmainTableName\x12\x1d\n\nindex_\
    name\x18\x02\x20\x02(\tR\tindexName\"\x13\n\x11DropIndexResponse\"n\n\
    \x17AddDefinedColumnRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\tt\
    ableName\x124\n\x07columns\x18\x02\x20\x03(\x0b2\x1a.proto.DefinedColumn\
    SchemaR\x07columns\"\x1a\n\x18AddDefinedColumnResponse\"U\n\x1aDeleteDef\
    inedColumnRequest\x12\x1d\n\ntable_name\x18\x01\x20\x02(\tR\ttableName\
    \x12\x18\n\x07columns\x18\x02\x20\x03(\tR\x07columns\"\x1d\n\x1bDeleteDe\
    finedColumnResponse\"O\n\x1cStartLocalTransactionRequest\x12\x1d\n\ntabl\
    e_name\x18\x01\x20\x02(\tR\ttableName\x12\x10\n\x03key\x18\x02\x20\x02(\
    \x0cR\x03key\"F\n\x1dStartLocalTransactionResponse\x12%\n\x0etransaction\
    _id\x18\x01\x20\x02(\tR\rtransactionId\"A\n\x18CommitTransactionRequest\
    \x12%\n\x0etransaction_id\x18\x01\x20\x02(\tR\rtransactionId\"\x1b\n\x19\
    CommitTransactionResponse\"@\n\x17AbortTransactionRequest\x12%\n\x0etran\
    saction_id\x18\x01\x20\x02(\tR\rtransactionId\"\x1a\n\x18AbortTransactio\
    nResponse\"\x95\x01\n\x14ComputeSplitsRequest\x12\x1d\n\ntable_name\x18\
    \x01\x20\x01(\tR\ttableName\x12^\n\x1bsearch_index_splits_options\x18\
    \x02\x20\x01(\x0b2\x1f.proto.SearchIndexSplitsOptionsR\x18searchIndexSpl\
    itsOptions\"9\n\x18SearchIndexSplitsOptions\x12\x1d\n\nindex_name\x18\
    \x01\x20\x01(\tR\tindexName\"W\n\x15ComputeSplitsResponse\x12\x1d\n\nses\
    sion_id\x18\x01\x20\x01(\x0cR\tsessionId\x12\x1f\n\x0bsplits_size\x18\
    \x02\x20\x01(\x05R\nsplitsSize*5\n\x0ePrimaryKeyType\x12\x0b\n\x07INTEGE\
    R\x10\x01\x12\n\n\x06STRING\x10\x02\x12\n\n\x06BINARY\x10\x03*&\n\x10Pri\
    maryKeyOption\x12\x12\n\x0eAUTO_INCREMENT\x10\x01*.\n\x0fBloomFilterType\
    \x12\x08\n\x04NONE\x10\x01\x12\x08\n\x04CELL\x10\x02\x12\x07\n\x03ROW\
    \x10\x03*Q\n\x0bTableStatus\x12\n\n\x06ACTIVE\x10\x01\x12\x0c\n\x08INACT\
    IVE\x10\x02\x12\x0b\n\x07LOADING\x10\x03\x12\r\n\tUNLOADING\x10\x04\x12\
    \x0c\n\x08UPDATING\x10\x05*M\n\x17RowExistenceExpectation\x12\n\n\x06IGN\
    ORE\x10\0\x12\x10\n\x0cEXPECT_EXIST\x10\x01\x12\x14\n\x10EXPECT_NOT_EXIS\
    T\x10\x02*9\n\nReturnType\x12\x0b\n\x07RT_NONE\x10\0\x12\t\n\x05RT_PK\
    \x10\x01\x12\x13\n\x0fRT_AFTER_MODIFY\x10\x02*0\n\rOperationType\x12\x07\
    \n\x03PUT\x10\x01\x12\n\n\x06UPDATE\x10\x02\x12\n\n\x06DELETE\x10\x03*&\
    \n\tDirection\x12\x0b\n\x07FORWARD\x10\0\x12\x0c\n\x08BACKWARD\x10\x01*6\
    \n\x0cStreamStatus\x12\x13\n\x0fSTREAM_ENABLING\x10\x01\x12\x11\n\rSTREA\
    M_ACTIVE\x10\x02*9\n\nActionType\x12\x0b\n\x07PUT_ROW\x10\x01\x12\x0e\n\
    \nUPDATE_ROW\x10\x02\x12\x0e\n\nDELETE_ROW\x10\x03*c\n\x11DefinedColumnT\
    ype\x12\x0f\n\x0bDCT_INTEGER\x10\x01\x12\x0e\n\nDCT_DOUBLE\x10\x02\x12\
    \x0f\n\x0bDCT_BOOLEAN\x10\x03\x12\x0e\n\nDCT_STRING\x10\x04\x12\x0c\n\
    \x08DCT_BLOB\x10\x07*:\n\x0fIndexUpdateMode\x12\x13\n\x0fIUM_ASYNC_INDEX\
    \x10\0\x12\x12\n\x0eIUM_SYNC_INDEX\x10\x01*4\n\tIndexType\x12\x13\n\x0fI\
    T_GLOBAL_INDEX\x10\0\x12\x12\n\x0eIT_LOCAL_INDEX\x10\x01J\xfa\xd2\x01\n\
    \x07\x12\x05\0\0\x86\x05\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\
    \x02\x12\x03\x01\0\x0e\n\n\n\x02\x04\0\x12\x04\x03\0\x06\x01\n\n\n\x03\
    \x04\0\x01\x12\x03\x03\x08\r\n\x0b\n\x04\x04\0\x02\0\x12\x03\x04\x04\x1d\
    \n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x04\x04\x0c\n\x0c\n\x05\x04\0\x02\0\
    \x05\x12\x03\x04\r\x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x04\x14\x18\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03\x04\x1b\x1c\n\x0b\n\x04\x04\0\x02\x01\
    \x12\x03\x05\x04\x20\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x05\x04\x0c\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x05\r\x13\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03\x05\x14\x1b\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x05\x1e\
    \x1f\n\n\n\x02\x05\0\x12\x04\x08\0\x0c\x01\n\n\n\x03\x05\0\x01\x12\x03\
    \x08\x05\x13\n\x0b\n\x04\x05\0\x02\0\x12\x03\t\x04\x10\n\x0c\n\x05\x05\0\
    \x02\0\x01\x12\x03\t\x04\x0b\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\t\x0e\
    \x0f\n\x0b\n\x04\x05\0\x02\x01\x12\x03\n\x04\x0f\n\x0c\n\x05\x05\0\x02\
    \x01\x01\x12\x03\n\x04\n\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\n\r\x0e\n\
    \x0b\n\x04\x05\0\x02\x02\x12\x03\x0b\x04\x0f\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03\x0b\x04\n\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0b\r\x0e\n\
    \n\n\x02\x05\x01\x12\x04\x0e\0\x10\x01\n\n\n\x03\x05\x01\x01\x12\x03\x0e\
    \x05\x15\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x0f\x04\x17\n\x0c\n\x05\x05\
    \x01\x02\0\x01\x12\x03\x0f\x04\x12\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\
    \x0f\x15\x16\n\n\n\x02\x04\x01\x12\x04\x12\0\x16\x01\n\n\n\x03\x04\x01\
    \x01\x12\x03\x12\x08\x18\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x13\x04\x1d\n\
    \x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\x01\x02\
    \0\x05\x12\x03\x13\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x13\x14\
    \x18\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x13\x1b\x1c\n\x0b\n\x04\x04\
    \x01\x02\x01\x12\x03\x14\x04%\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\
    \x14\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03\x14\r\x1b\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03\x14\x1c\x20\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03\x14#$\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\x15\x04)\n\x0c\n\
    \x05\x04\x01\x02\x02\x04\x12\x03\x15\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\
    \x06\x12\x03\x15\r\x1d\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\x15\x1e$\
    \n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\x15'(\n\n\n\x02\x04\x02\x12\x04\
    \x18\0\x1b\x01\n\n\n\x03\x04\x02\x01\x12\x03\x18\x08\x16\n$\n\x04\x04\
    \x02\x02\0\x12\x03\x19\x04\x1d\"\x17\x20encoded\x20as\x20SQLVariant\n\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x03\x19\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \0\x05\x12\x03\x19\r\x12\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x19\x13\
    \x18\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03\x19\x1b\x1c\n$\n\x04\x04\x02\
    \x02\x01\x12\x03\x1a\x04\x1b\"\x17\x20encoded\x20as\x20SQLVariant\n\n\
    \x0c\n\x05\x04\x02\x02\x01\x04\x12\x03\x1a\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x01\x05\x12\x03\x1a\r\x12\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\
    \x1a\x13\x16\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x1a\x19\x1a\n\n\n\
    \x02\x05\x02\x12\x04\x1d\0!\x01\n\n\n\x03\x05\x02\x01\x12\x03\x1d\x05\
    \x14\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x1e\x04\r\n\x0c\n\x05\x05\x02\x02\
    \0\x01\x12\x03\x1e\x04\x08\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x1e\x0b\
    \x0c\n\x0b\n\x04\x05\x02\x02\x01\x12\x03\x1f\x04\r\n\x0c\n\x05\x05\x02\
    \x02\x01\x01\x12\x03\x1f\x04\x08\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03\
    \x1f\x0b\x0c\n\x0b\n\x04\x05\x02\x02\x02\x12\x03\x20\x04\x0c\n\x0c\n\x05\
    \x05\x02\x02\x02\x01\x12\x03\x20\x04\x07\n\x0c\n\x05\x05\x02\x02\x02\x02\
    \x12\x03\x20\n\x0b\n\n\n\x02\x04\x03\x12\x04#\0)\x01\n\n\n\x03\x04\x03\
    \x01\x12\x03#\x08\x14\n!\n\x04\x04\x03\x02\0\x12\x03$\x04$\"\x14\x20\xe5\
    \x8f\xaf\xe4\xbb\xa5\xe5\x8a\xa8\xe6\x80\x81\xe6\x9b\xb4\xe6\x94\xb9\n\n\
    \x0c\n\x05\x04\x03\x02\0\x04\x12\x03$\x04\x0c\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x03$\r\x12\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03$\x13\x1f\n\x0c\
    \n\x05\x04\x03\x02\0\x03\x12\x03$\"#\n!\n\x04\x04\x03\x02\x01\x12\x03%\
    \x04$\"\x14\x20\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x8a\xa8\xe6\x80\x81\xe6\x9b\
    \xb4\xe6\x94\xb9\n\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03%\x04\x0c\n\
    \x0c\n\x05\x04\x03\x02\x01\x05\x12\x03%\r\x12\n\x0c\n\x05\x04\x03\x02\
    \x01\x01\x12\x03%\x13\x1f\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03%\"#\n!\
    \n\x04\x04\x03\x02\x02\x12\x03&\x043\"\x14\x20\xe5\x8f\xaf\xe4\xbb\xa5\
    \xe5\x8a\xa8\xe6\x80\x81\xe6\x9b\xb4\xe6\x94\xb9\n\n\x0c\n\x05\x04\x03\
    \x02\x02\x04\x12\x03&\x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03&\r\
    \x1c\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03&\x1d.\n\x0c\n\x05\x04\x03\
    \x02\x02\x03\x12\x03&12\n!\n\x04\x04\x03\x02\x03\x12\x03'\x04\"\"\x14\
    \x20\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x8a\xa8\xe6\x80\x81\xe6\x9b\xb4\xe6\x94\
    \xb9\n\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03'\x04\x0c\n\x0c\n\x05\x04\
    \x03\x02\x03\x05\x12\x03'\r\x12\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03'\
    \x13\x1d\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03'\x20!\n!\n\x04\x04\x03\
    \x02\x04\x12\x03(\x045\"\x14\x20\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x8a\xa8\xe6\
    \x80\x81\xe4\xbf\xae\xe6\x94\xb9\n\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\
    \x03(\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03(\r\x12\n\x0c\n\x05\
    \x04\x03\x02\x04\x01\x12\x03(\x130\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\
    \x03(34\n\n\n\x02\x04\x04\x12\x04+\00\x01\n\n\n\x03\x04\x04\x01\x12\x03+\
    \x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03,\x04#\n\x0c\n\x05\x04\x04\x02\
    \0\x04\x12\x03,\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03,\r\x13\n\
    \x0c\n\x05\x04\x04\x02\0\x01\x12\x03,\x14\x1e\n\x0c\n\x05\x04\x04\x02\0\
    \x03\x12\x03,!\"\n\x0b\n\x04\x04\x04\x02\x01\x12\x03-\x04.\n\x0c\n\x05\
    \x04\x04\x02\x01\x04\x12\x03-\x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x06\
    \x12\x03-\r\x1d\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03-\x1e)\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03-,-\n\x0b\n\x04\x04\x04\x02\x02\x12\x03.\
    \x044\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03.\x04\x0c\n\x0c\n\x05\x04\
    \x04\x02\x02\x06\x12\x03.\r\x20\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03.\
    !/\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03.23\n\x0b\n\x04\x04\x04\x02\
    \x03\x12\x03/\x04&\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03/\x04\x0c\n\
    \x0c\n\x05\x04\x04\x02\x03\x06\x12\x03/\r\x16\n\x0c\n\x05\x04\x04\x02\
    \x03\x01\x12\x03/\x17!\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03/$%\n\xaf\
    \x05\n\x02\x05\x03\x12\x049\0?\x01\x1a\xa2\x05*\n\x20\xe8\xa1\xa8\xe7\
    \x9a\x84\xe7\x8a\xb6\xe6\x80\x81\xe5\x8f\x98\xe6\x9b\xb4\xe5\x8f\xaa\xe4\
    \xb8\x8e\xe7\x94\xa8\xe6\x88\xb7\xe7\x9a\x84\xe6\x93\x8d\xe4\xbd\x9c\xe5\
    \xaf\xb9\xe5\xba\x94\xef\xbc\x8c\xe5\x86\x85\xe9\x83\xa8\xe7\x9a\x84\xe6\
    \x9c\xba\xe5\x99\xa8failover\xe7\xad\x89\xe7\x8a\xb6\xe5\x86\xb5\xe4\xb8\
    \x8d\xe5\xaf\xb9\xe5\xba\x94\xe8\xa1\xa8\xe7\x9a\x84\xe7\x8a\xb6\xe6\x80\
    \x81\xe5\x8f\x98\xe6\x9b\xb4\xe3\x80\x82\n\x20\xe6\x9c\x89\xe4\xb8\x89\
    \xe4\xb8\xaa\xe8\x80\x83\xe8\x99\x91\xef\xbc\x9a\n\x20\x20\x20\x20\x20\
    \xe4\xb8\x80\xe6\x98\xaf\xe4\xb8\x80\xe8\x88\xac\xe5\x9c\xba\xe6\x99\xaf\
    \xe4\xb8\x8b\xe7\x94\xa8\xe6\x88\xb7\xe5\x8f\xaa\xe4\xbc\x9a\xe5\x9c\xa8\
    \xe5\x81\x9a\xe4\xba\x86\xe5\xaf\xb9\xe8\xa1\xa8\xe7\x9a\x84\xe4\xbf\xae\
    \xe6\x94\xb9\xe6\x93\x8d\xe4\xbd\x9c\xe5\x90\x8e\xe6\x89\x8d\xe4\xbc\x9a\
    \xe5\x8e\xbb\xe6\xa3\x80\xe6\x9f\xa5\xe8\xa1\xa8\xe7\x9a\x84\xe7\x8a\xb6\
    \xe6\x80\x81\xef\xbc\x9b\n\x20\x20\x20\x20\x20\xe4\xba\x8c\xe6\x98\xaf\
    \xe5\x86\x85\xe9\x83\xa8\xe6\x9c\xba\xe5\x99\xa8failover\xe5\xaf\xbc\xe8\
    \x87\xb4\xe8\xae\xbf\xe9\x97\xae\xe5\xbc\x82\xe5\xb8\xb8\xe5\x88\xb0\xe7\
    \x94\xa8\xe6\x88\xb7\xe8\x83\xbd\xe5\xa4\x9f\xe6\x9f\xa5\xe7\x9c\x8b\xe5\
    \x88\xb0\xe8\xa1\xa8\xe7\x9a\x84\xe7\x8a\xb6\xe6\x80\x81\xe5\x8f\x98\xe6\
    \x9b\xb4\xe8\xbf\x99\xe4\xb8\xa4\xe4\xb8\xaa\xe6\x97\xb6\xe5\x88\xbb\xe4\
    \xb9\x8b\xe9\x97\xb4\xe4\xbc\x9a\xe6\x9c\x89\xe4\xb8\x80\xe6\xae\xb5\xe5\
    \xbb\xb6\xe8\xbf\x9f\xef\xbc\x8c\xe6\x97\xa0\xe6\xb3\x95\xe5\xb0\x86\xe8\
    \xa1\xa8\xe7\x9a\x84\xe4\xb8\x8d\xe5\x8f\xaf\xe6\x9c\x8d\xe5\x8a\xa1\xe7\
    \x8a\xb6\xe6\x80\x81\xe4\xb8\x8e\xe7\x94\xa8\xe6\x88\xb7\xe6\x9f\xa5\xe7\
    \x9c\x8b\xe5\x88\xb0\xe7\x9a\x84\xe8\xa1\xa8\xe7\x9a\x84\xe7\x8a\xb6\xe6\
    \x80\x81\xe5\xae\x8c\xe5\x85\xa8\xe5\x8c\xb9\xe9\x85\x8d\xe4\xb8\x8a\xe3\
    \x80\x82\n\x20\x20\x20\x20\x20\xe4\xb8\x89\xe6\x98\xaf\xe5\x86\x85\xe9\
    \x83\xa8\xe6\x9c\xba\xe5\x99\xa8failover\xe5\x90\x8e\xe4\xb8\x8d\xe8\x83\
    \xbd\xe8\xaf\xb4\xe6\x98\xaf\xe8\xa1\xa8\xe7\x9a\x84\xe6\x95\xb4\xe4\xb8\
    \xaa\xe7\x8a\xb6\xe6\x80\x81\xe5\x8f\x98\xe6\x9b\xb4\xef\xbc\x8c\xe8\x80\
    \x8c\xe5\xba\x94\xe8\xaf\xa5\xe6\x98\xafpartition\xe7\x9a\x84\xe7\x8a\
    \xb6\xe6\x80\x81\xe5\x8f\x98\xe6\x9b\xb4\xef\xbc\x8c\xe5\xaf\xb9\xe5\xba\
    \x94\xe8\xa1\xa8\xe7\x9a\x84\xe7\x8a\xb6\xe6\x80\x81\xe5\xb0\xb1\xe6\x98\
    \xafPARTIAL_FAILOVER\xef\xbc\x8c\xe8\xbf\x99\xe4\xb8\xaapartial\xe7\x9a\
    \x84\xe7\xb2\x92\xe5\xba\xa6\xe6\x97\xa0\xe6\xb3\x95\xe4\xbd\x93\xe7\x8e\
    \xb0\xef\xbc\x8c\xe4\xbc\x9a\xe8\xae\xa9\xe7\x94\xa8\xe6\x88\xb7\xe6\x9b\
    \xb4\xe5\x8a\xa0\xe5\x9b\xb0\xe6\x83\x91\xe3\x80\x82\n\n\n\n\x03\x05\x03\
    \x01\x12\x039\x05\x10\n*\n\x04\x05\x03\x02\0\x12\x03:\x04\x0f\"\x1d\x20\
    \xe8\xa1\xa8\xe5\xa4\x84\xe4\xba\x8e\xe5\x8f\xaf\xe6\x9c\x8d\xe5\x8a\xa1\
    \xe7\x8a\xb6\xe6\x80\x81\xe3\x80\x82\n\n\x0c\n\x05\x05\x03\x02\0\x01\x12\
    \x03:\x04\n\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03:\r\x0e\n5\n\x04\x05\
    \x03\x02\x01\x12\x03;\x04\x11\"(\x20\xe7\x94\xa8\xe6\x88\xb7\xe9\x80\x9a\
    \xe8\xbf\x87UnloadTable\xe5\xb0\x86\xe8\xa1\xa8\xe7\xa6\x81\xe7\x94\xa8\
    \xe3\x80\x82\n\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\x03;\x04\x0c\n\x0c\n\
    \x05\x05\x03\x02\x01\x02\x12\x03;\x0f\x10\nq\n\x04\x05\x03\x02\x02\x12\
    \x03<\x04\x10\"d\x20\xe8\xa1\xa8\xe6\xad\xa3\xe5\x9c\xa8\xe8\xa2\xab\xe5\
    \x88\x9b\xe5\xbb\xba\xef\xbc\x8cpartition\xe8\xbf\x98\xe6\x9c\xaa\xe5\
    \x85\xa8\xe9\x83\xa8\xe5\x8a\xa0\xe8\xbd\xbd\xe5\xae\x8c\xe6\xaf\x95\xef\
    \xbc\x9b\xe6\x88\x96\xe8\x80\x85\xe8\xa1\xa8\xe5\x88\x9a\xe4\xbb\x8eINAC\
    TIVE\xe7\x8a\xb6\xe6\x80\x81\xe8\xa2\xabEnable\xe3\x80\x82\n\n\x0c\n\x05\
    \x05\x03\x02\x02\x01\x12\x03<\x04\x0b\n\x0c\n\x05\x05\x03\x02\x02\x02\
    \x12\x03<\x0e\x0f\n\x81\x01\n\x04\x05\x03\x02\x03\x12\x03=\x04\x12\"t\
    \x20\xe8\xa1\xa8\xe6\xad\xa3\xe5\x9c\xa8\xe8\xa2\xab\xe5\x88\xa0\xe9\x99\
    \xa4\xef\xbc\x88\xe4\xbb\x8edelete\x20table\xe5\x88\xb0partition\xe5\xae\
    \x8c\xe5\x85\xa8unload\xe7\x9a\x84\xe8\xbf\x99\xe6\xae\xb5\xe6\x9c\x9f\
    \xe9\x97\xb4\xef\xbc\x89\xe6\x88\x96\xe8\x80\x85\xe8\xa1\xa8\xe4\xbb\x8e\
    ACTIVE\xe7\x8a\xb6\xe6\x80\x81\xe8\xa2\xabUnload\xe3\x80\x82\n\n\x0c\n\
    \x05\x05\x03\x02\x03\x01\x12\x03=\x04\r\n\x0c\n\x05\x05\x03\x02\x03\x02\
    \x12\x03=\x10\x11\nS\n\x04\x05\x03\x02\x04\x12\x03>\x04\x11\"F\x20\xe8\
    \xa1\xa8\xe6\xad\xa3\xe5\x9c\xa8\xe8\xa2\xab\xe6\x9b\xb4\xe6\x96\xb0\xef\
    \xbc\x88table\xe5\xb1\x9e\xe6\x80\xa7\xe5\x8f\x98\xe6\x9b\xb4\xe3\x80\
    \x81\xe9\xa2\x84\xe7\x95\x99\xe5\x90\x9e\xe5\x90\x90\xe9\x87\x8f\xe5\x8f\
    \x98\xe6\x9b\xb4\xef\xbc\x89\xe3\x80\x82\n\n\x0c\n\x05\x05\x03\x02\x04\
    \x01\x12\x03>\x04\x0c\n\x0c\n\x05\x05\x03\x02\x04\x02\x12\x03>\x0f\x10\n\
    \n\n\x02\x05\x04\x12\x04A\0E\x01\n\n\n\x03\x05\x04\x01\x12\x03A\x05\x1c\
    \n\x0b\n\x04\x05\x04\x02\0\x12\x03B\x04\x0f\n\x0c\n\x05\x05\x04\x02\0\
    \x01\x12\x03B\x04\n\n\x0c\n\x05\x05\x04\x02\0\x02\x12\x03B\r\x0e\n\x0b\n\
    \x04\x05\x04\x02\x01\x12\x03C\x04\x15\n\x0c\n\x05\x05\x04\x02\x01\x01\
    \x12\x03C\x04\x10\n\x0c\n\x05\x05\x04\x02\x01\x02\x12\x03C\x13\x14\n\x0b\
    \n\x04\x05\x04\x02\x02\x12\x03D\x04\x19\n\x0c\n\x05\x05\x04\x02\x02\x01\
    \x12\x03D\x04\x14\n\x0c\n\x05\x05\x04\x02\x02\x02\x12\x03D\x17\x18\n\n\n\
    \x02\x04\x05\x12\x04G\0J\x01\n\n\n\x03\x04\x05\x01\x12\x03G\x08\x11\n\
    \x0b\n\x04\x04\x05\x02\0\x12\x03H\x047\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03H\x04\x0c\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03H\r$\n\x0c\n\x05\x04\
    \x05\x02\0\x01\x12\x03H%2\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03H56\n\x0b\
    \n\x04\x04\x05\x02\x01\x12\x03I\x04-\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\
    \x03I\x04\x0c\n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03I\r\x12\n\x0c\n\x05\
    \x04\x05\x02\x01\x01\x12\x03I\x13#\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\
    \x03I+,\n\n\n\x02\x04\x06\x12\x04L\0O\x01\n\n\n\x03\x04\x06\x01\x12\x03L\
    \x08\x14\n\x0b\n\x04\x04\x06\x02\0\x12\x03M\x04\x1c\n\x0c\n\x05\x04\x06\
    \x02\0\x04\x12\x03M\x04\x0c\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03M\r\x12\
    \n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03M\x13\x17\n\x0c\n\x05\x04\x06\x02\
    \0\x03\x12\x03M\x1a\x1b\n\x0b\n\x04\x04\x06\x02\x01\x12\x03N\x04\x1d\n\
    \x0c\n\x05\x04\x06\x02\x01\x04\x12\x03N\x04\x0c\n\x0c\n\x05\x04\x06\x02\
    \x01\x05\x12\x03N\r\x12\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03N\x13\x18\
    \n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03N\x1b\x1c\n\n\n\x02\x04\x07\x12\
    \x04Q\0U\x01\n\n\n\x03\x04\x07\x01\x12\x03Q\x08!\n3\n\x04\x04\x07\x02\0\
    \x12\x03R\x04,\"&\x20\xe8\xa1\xa8\xe5\xbd\x93\xe5\x89\x8d\xe7\x9a\x84\
    \xe9\xa2\x84\xe7\x95\x99\xe5\x90\x9e\xe5\x90\x90\xe9\x87\x8f\xe7\x9a\x84\
    \xe5\x80\xbc\xe3\x80\x82\n\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03R\x04\
    \x0c\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03R\r\x19\n\x0c\n\x05\x04\x07\
    \x02\0\x01\x12\x03R\x1a'\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03R*+\n<\n\
    \x04\x04\x07\x02\x01\x12\x03S\x04*\"/\x20\xe6\x9c\x80\xe5\x90\x8e\xe4\
    \xb8\x80\xe6\xac\xa1\xe4\xb8\x8a\xe8\xb0\x83\xe9\xa2\x84\xe7\x95\x99\xe5\
    \x90\x9e\xe5\x90\x90\xe9\x87\x8f\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xe3\
    \x80\x82\n\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03S\x04\x0c\n\x0c\n\x05\
    \x04\x07\x02\x01\x05\x12\x03S\r\x12\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\
    \x03S\x13%\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03S()\n<\n\x04\x04\x07\
    \x02\x02\x12\x03T\x04*\"/\x20\xe6\x9c\x80\xe5\x90\x8e\xe4\xb8\x80\xe6\
    \xac\xa1\xe4\xb8\x8b\xe8\xb0\x83\xe9\xa2\x84\xe7\x95\x99\xe5\x90\x9e\xe5\
    \x90\x90\xe9\x87\x8f\xe7\x9a\x84\xe6\x97\xb6\xe9\x97\xb4\xe3\x80\x82\n\n\
    \x0c\n\x05\x04\x07\x02\x02\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x07\x02\
    \x02\x05\x12\x03T\r\x12\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03T\x13%\n\
    \x0c\n\x05\x04\x07\x02\x02\x03\x12\x03T()\n\n\n\x02\x04\x08\x12\x04W\0Y\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03W\x08\x1a\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03X\x04,\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03X\x04\x0c\n\x0c\n\
    \x05\x04\x08\x02\0\x06\x12\x03X\r\x19\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03X\x1a'\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03X*+\n\n\n\x02\x04\t\x12\
    \x04[\0]\x01\n\n\n\x03\x04\t\x01\x12\x03[\x08\x18\n\x0b\n\x04\x04\t\x02\
    \0\x12\x03\\\x04,\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03\\\x04\x0c\n\x0c\n\
    \x05\x04\t\x02\0\x06\x12\x03\\\r\x19\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03\
    \\\x1a'\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03\\*+\n\n\n\x02\x04\n\x12\x04_\
    \0b\x01\n\n\n\x03\x04\n\x01\x12\x03_\x08\x1b\n\x0b\n\x04\x04\n\x02\0\x12\
    \x03`\x04$\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03`\x04\x0c\n\x0c\n\x05\x04\
    \n\x02\0\x05\x12\x03`\r\x11\n\x0c\n\x05\x04\n\x02\0\x01\x12\x03`\x12\x1f\
    \n\x0c\n\x05\x04\n\x02\0\x03\x12\x03`\"#\n\x0b\n\x04\x04\n\x02\x01\x12\
    \x03a\x04'\n\x0c\n\x05\x04\n\x02\x01\x04\x12\x03a\x04\x0c\n\x0c\n\x05\
    \x04\n\x02\x01\x05\x12\x03a\r\x12\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03a\
    \x13\"\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03a%&\n\n\n\x02\x04\x0b\x12\
    \x04d\0i\x01\n\n\n\x03\x04\x0b\x01\x12\x03d\x08\x15\n\x0b\n\x04\x04\x0b\
    \x02\0\x12\x03e\x04$\n\x0c\n\x05\x04\x0b\x02\0\x04\x12\x03e\x04\x0c\n\
    \x0c\n\x05\x04\x0b\x02\0\x05\x12\x03e\r\x11\n\x0c\n\x05\x04\x0b\x02\0\
    \x01\x12\x03e\x12\x1f\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03e\"#\n\x0b\n\
    \x04\x04\x0b\x02\x01\x12\x03f\x04\"\n\x0c\n\x05\x04\x0b\x02\x01\x04\x12\
    \x03f\x04\x0c\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03f\r\x13\n\x0c\n\x05\
    \x04\x0b\x02\x01\x01\x12\x03f\x14\x1d\n\x0c\n\x05\x04\x0b\x02\x01\x03\
    \x12\x03f\x20!\n\x0b\n\x04\x04\x0b\x02\x02\x12\x03g\x04'\n\x0c\n\x05\x04\
    \x0b\x02\x02\x04\x12\x03g\x04\x0c\n\x0c\n\x05\x04\x0b\x02\x02\x05\x12\
    \x03g\r\x12\n\x0c\n\x05\x04\x0b\x02\x02\x01\x12\x03g\x13\"\n\x0c\n\x05\
    \x04\x0b\x02\x02\x03\x12\x03g%&\n\x0b\n\x04\x04\x0b\x02\x03\x12\x03h\x04\
    (\n\x0c\n\x05\x04\x0b\x02\x03\x04\x12\x03h\x04\x0c\n\x0c\n\x05\x04\x0b\
    \x02\x03\x05\x12\x03h\r\x12\n\x0c\n\x05\x04\x0b\x02\x03\x01\x12\x03h\x13\
    #\n\x0c\n\x05\x04\x0b\x02\x03\x03\x12\x03h&'\n\x8c\x06\n\x02\x04\x0c\x12\
    \x04w\0~\x01\x1a\x92\x05*\n\x20table_meta\xe7\x94\xa8\xe4\xba\x8e\xe5\
    \xad\x98\xe5\x82\xa8\xe8\xa1\xa8\xe4\xb8\xad\xe4\xb8\x8d\xe5\x8f\xaf\xe6\
    \x9b\xb4\xe6\x94\xb9\xe7\x9a\x84schema\xe5\xb1\x9e\xe6\x80\xa7\xef\xbc\
    \x8c\xe5\x8f\xaf\xe4\xbb\xa5\xe6\x9b\xb4\xe6\x94\xb9\xe7\x9a\x84Reserved\
    Throughput\xe5\x92\x8cTableOptions\xe7\x8b\xac\xe7\xab\x8b\xe5\x87\xba\
    \xe6\x9d\xa5\xef\xbc\x8c\xe4\xbd\x9c\xe4\xb8\xbaUpdateTable\xe7\x9a\x84\
    \xe5\x8f\x82\xe6\x95\xb0\xe3\x80\x82\n\x20\xe5\x8a\xa0\xe5\x85\xa5Global\
    Index\xe5\x92\x8cLocalIndex\xe4\xb9\x8b\xe5\x90\x8e\xef\xbc\x8c\xe7\xbb\
    \x93\xe6\x9e\x84\xe4\xbc\x9a\xe5\x8f\x98\xe4\xb8\xba\xef\xbc\x9a\n\x20me\
    ssage\x20CreateTableRequest\x20{\n\x20\x20\x20\x20\x20\x20\x20\x20\x20re\
    quired\x20TableMeta\x20table_meta\x20=\x201;\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20required\x20ReservedThroughput\x20reserved_throughput\x20=\
    \x202;\n\x20\x20\x20\x20\x20\x20\x20\x20\x20required\x20TableOptions\x20\
    table_options\x20=\x203;\n\x20\x20\x20\x20\x20\x20\x20\x20\x20repeated\
    \x20LocalIndex\x20local_indexes\x20=\x204;\x20//\x20LocalIndex\xe4\xb8\
    \x8d\xe5\x86\x8d\xe5\x8d\x95\xe7\x8b\xac\xe5\x8c\x85\xe5\x90\xabReserved\
    Throughput\xe5\x92\x8cTableOptions\xef\xbc\x8c\xe5\x85\xb6\xe4\xb8\x8e\
    \xe4\xb8\xbb\xe8\xa1\xa8\xe5\x85\xb1\xe4\xba\xab\xe9\x85\x8d\xe7\xbd\xae\
    \xe3\x80\x82\n\x20\x20\x20\x20\x20\x20\x20\x20\x20repeated\x20GlobalInde\
    x\x20global_indexes\x20=\x205;\x20//\x20GlobalIndex\xe5\x86\x85\xe5\x8d\
    \x95\xe7\x8b\xac\xe5\x8c\x85\xe5\x90\xabReservedThroughput\xe5\x92\x8cTa\
    bleOptions\n\x20}\n2k\x20#############################################\
    \x20\x20CreateTable\x20\x20#############################################\
    \x20\n\n\n\x03\x04\x0c\x01\x12\x03w\x08\x1a\n\x0b\n\x04\x04\x0c\x02\0\
    \x12\x03x\x04&\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03x\x04\x0c\n\x0c\n\
    \x05\x04\x0c\x02\0\x06\x12\x03x\r\x16\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\
    \x03x\x17!\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03x$%\n\x9c\x01\n\x04\x04\
    \x0c\x02\x01\x12\x03y\x048\"\x8e\x01\x20\xe6\x9c\xaa\xe6\x94\xbe\xe5\x9c\
    \xa8TableOptions\xe5\x86\x85\xef\xbc\x8c\xe5\x8e\x9f\xe5\x9b\xa0\xe6\x98\
    \xafUpdateTableResponse\xe4\xb8\xad\xe4\xbc\x9a\xe8\xbf\x94\xe5\x9b\x9eR\
    eservedThroughputDetails\xef\xbc\x8c\xe8\x80\x8cTableOptions\xe6\xb2\xa1\
    \xe6\x9c\x89\xe7\xb1\xbb\xe4\xbc\xbc\xe7\x9a\x84\xe8\xbf\x94\xe5\x9b\x9e\
    \xe7\xbb\x93\xe6\x9e\x84\xe3\x80\x82\n\n\x0c\n\x05\x04\x0c\x02\x01\x04\
    \x12\x03y\x04\x0c\n\x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03y\r\x1f\n\x0c\n\
    \x05\x04\x0c\x02\x01\x01\x12\x03y\x203\n\x0c\n\x05\x04\x0c\x02\x01\x03\
    \x12\x03y67\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03z\x04,\n\x0c\n\x05\x04\
    \x0c\x02\x02\x04\x12\x03z\x04\x0c\n\x0c\n\x05\x04\x0c\x02\x02\x06\x12\
    \x03z\r\x19\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03z\x1a'\n\x0c\n\x05\
    \x04\x0c\x02\x02\x03\x12\x03z*+\n\x0b\n\x04\x04\x0c\x02\x03\x12\x03{\x04\
    +\n\x0c\n\x05\x04\x0c\x02\x03\x04\x12\x03{\x04\x0c\n\x0c\n\x05\x04\x0c\
    \x02\x03\x06\x12\x03{\r\x1b\n\x0c\n\x05\x04\x0c\x02\x03\x01\x12\x03{\x1c\
    &\n\x0c\n\x05\x04\x0c\x02\x03\x03\x12\x03{)*\n\x0b\n\x04\x04\x0c\x02\x04\
    \x12\x03|\x041\n\x0c\n\x05\x04\x0c\x02\x04\x04\x12\x03|\x04\x0c\n\x0c\n\
    \x05\x04\x0c\x02\x04\x06\x12\x03|\r\x20\n\x0c\n\x05\x04\x0c\x02\x04\x01\
    \x12\x03|!,\n\x0c\n\x05\x04\x0c\x02\x04\x03\x12\x03|/0\n\x0b\n\x04\x04\
    \x0c\x02\x05\x12\x03}\x04'\n\x0c\n\x05\x04\x0c\x02\x05\x04\x12\x03}\x04\
    \x0c\n\x0c\n\x05\x04\x0c\x02\x05\x06\x12\x03}\r\x16\n\x0c\n\x05\x04\x0c\
    \x02\x05\x01\x12\x03}\x17\"\n\x0c\n\x05\x04\x0c\x02\x05\x03\x12\x03}%&\n\
    \x0c\n\x02\x04\r\x12\x06\x80\x01\0\x81\x01\x01\n\x0b\n\x03\x04\r\x01\x12\
    \x04\x80\x01\x08\x1b\n\xe6\x01\n\x02\x04\x0e\x12\x06\x87\x01\0\x8c\x01\
    \x01\x1ak\x20#############################################\x20\x20Update\
    Table\x20\x20#############################################\x202k\x20####\
    ########################################################################\
    #############################\x20\n\x0b\n\x03\x04\x0e\x01\x12\x04\x87\
    \x01\x08\x1a\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x88\x01\x04#\n\r\n\x05\
    \x04\x0e\x02\0\x04\x12\x04\x88\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\0\x05\
    \x12\x04\x88\x01\r\x13\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x88\x01\x14\
    \x1e\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x88\x01!\"\n\x0c\n\x04\x04\x0e\
    \x02\x01\x12\x04\x89\x01\x048\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x89\
    \x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\x89\x01\r\x1f\n\r\n\
    \x05\x04\x0e\x02\x01\x01\x12\x04\x89\x01\x203\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\x89\x0167\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\x8a\x01\x04,\
    \n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\x8a\x01\x04\x0c\n\r\n\x05\x04\x0e\
    \x02\x02\x06\x12\x04\x8a\x01\r\x19\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\
    \x8a\x01\x1a'\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x8a\x01*+\n\x0c\n\
    \x04\x04\x0e\x02\x03\x12\x04\x8b\x01\x041\n\r\n\x05\x04\x0e\x02\x03\x04\
    \x12\x04\x8b\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x03\x06\x12\x04\x8b\x01\r\
    \x20\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\x8b\x01!,\n\r\n\x05\x04\x0e\
    \x02\x03\x03\x12\x04\x8b\x01/0\n\x0c\n\x02\x04\x0f\x12\x06\x8e\x01\0\x92\
    \x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x8e\x01\x08\x1b\n\x0c\n\x04\x04\
    \x0f\x02\0\x12\x04\x8f\x01\x04G\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\x8f\
    \x01\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x06\x12\x04\x8f\x01\r&\n\r\n\x05\
    \x04\x0f\x02\0\x01\x12\x04\x8f\x01'B\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \x8f\x01EF\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x90\x01\x04,\n\r\n\x05\
    \x04\x0f\x02\x01\x04\x12\x04\x90\x01\x04\x0c\n\r\n\x05\x04\x0f\x02\x01\
    \x06\x12\x04\x90\x01\r\x19\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x90\x01\
    \x1a'\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x90\x01*+\n\x0c\n\x04\x04\
    \x0f\x02\x02\x12\x04\x91\x01\x04.\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\
    \x91\x01\x04\x0c\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\x91\x01\r\x1a\n\r\
    \n\x05\x04\x0f\x02\x02\x01\x12\x04\x91\x01\x1b)\n\r\n\x05\x04\x0f\x02\
    \x02\x03\x12\x04\x91\x01,-\n{\n\x02\x04\x10\x12\x06\x96\x01\0\x98\x01\
    \x01\x1am\x20#############################################\x20\x20Descri\
    beTable\x20\x20#############################################\x20\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\x96\x01\x08\x1c\n\x0c\n\x04\x04\x10\x02\0\x12\
    \x04\x97\x01\x04#\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x97\x01\x04\x0c\n\
    \r\n\x05\x04\x10\x02\0\x05\x12\x04\x97\x01\r\x13\n\r\n\x05\x04\x10\x02\0\
    \x01\x12\x04\x97\x01\x14\x1e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x97\x01\
    !\"\n\x0c\n\x02\x04\x11\x12\x06\x9a\x01\0\xa2\x01\x01\n\x0b\n\x03\x04\
    \x11\x01\x12\x04\x9a\x01\x08\x1d\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x9b\
    \x01\x04&\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x9b\x01\x04\x0c\n\r\n\x05\
    \x04\x11\x02\0\x06\x12\x04\x9b\x01\r\x16\n\r\n\x05\x04\x11\x02\0\x01\x12\
    \x04\x9b\x01\x17!\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x9b\x01$%\n\x0c\n\
    \x04\x04\x11\x02\x01\x12\x04\x9c\x01\x04G\n\r\n\x05\x04\x11\x02\x01\x04\
    \x12\x04\x9c\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\x9c\x01\r\
    &\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x9c\x01'B\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\x9c\x01EF\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\x9d\x01\
    \x04,\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\x9d\x01\x04\x0c\n\r\n\x05\
    \x04\x11\x02\x02\x06\x12\x04\x9d\x01\r\x19\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\x9d\x01\x1a'\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\x9d\x01*+\n\
    \x0c\n\x04\x04\x11\x02\x03\x12\x04\x9e\x01\x04*\n\r\n\x05\x04\x11\x02\
    \x03\x04\x12\x04\x9e\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x03\x06\x12\x04\
    \x9e\x01\r\x18\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\x9e\x01\x19%\n\r\n\
    \x05\x04\x11\x02\x03\x03\x12\x04\x9e\x01()\n\x0c\n\x04\x04\x11\x02\x04\
    \x12\x04\x9f\x01\x04.\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\x9f\x01\x04\
    \x0c\n\r\n\x05\x04\x11\x02\x04\x06\x12\x04\x9f\x01\r\x1a\n\r\n\x05\x04\
    \x11\x02\x04\x01\x12\x04\x9f\x01\x1b)\n\r\n\x05\x04\x11\x02\x04\x03\x12\
    \x04\x9f\x01,-\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\xa0\x01\x04$\n\r\n\
    \x05\x04\x11\x02\x05\x04\x12\x04\xa0\x01\x04\x0c\n\r\n\x05\x04\x11\x02\
    \x05\x05\x12\x04\xa0\x01\r\x12\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\xa0\
    \x01\x13\x1f\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xa0\x01\"#\n\x0c\n\
    \x04\x04\x11\x02\x06\x12\x04\xa1\x01\x04'\n\r\n\x05\x04\x11\x02\x06\x04\
    \x12\x04\xa1\x01\x04\x0c\n\r\n\x05\x04\x11\x02\x06\x06\x12\x04\xa1\x01\r\
    \x16\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xa1\x01\x17\"\n\r\n\x05\x04\
    \x11\x02\x06\x03\x12\x04\xa1\x01%&\nw\n\x02\x04\x12\x12\x06\xa6\x01\0\
    \xa7\x01\x01\x1ai\x20#############################################\x20\
    \x20ListTable\x20\x20#############################################\x20\n\
    \x0b\n\x03\x04\x12\x01\x12\x04\xa6\x01\x08\x18\n\xb9\x02\n\x02\x04\x13\
    \x12\x06\xad\x01\0\xaf\x01\x01\x1a\xaa\x02*\n\x20\xe5\xbd\x93\xe5\x89\
    \x8d\xe5\x8f\xaa\xe8\xbf\x94\xe5\x9b\x9e\xe4\xb8\x80\xe4\xb8\xaa\xe7\xae\
    \x80\xe5\x8d\x95\xe7\x9a\x84\xe5\x90\x8d\xe7\xa7\xb0\xe5\x88\x97\xe8\xa1\
    \xa8\xef\xbc\x8c\xe9\x9c\x80\xe8\xa6\x81\xe8\xae\xa8\xe8\xae\xba\xe6\x98\
    \xaf\xe5\x90\xa6\xe6\x9c\x89\xe4\xb8\x9a\xe5\x8a\xa1\xe5\x9c\xba\xe6\x99\
    \xaf\xe9\x9c\x80\xe8\xa6\x81\xe8\x8e\xb7\xe5\x8f\x96\xe9\x99\xa4\xe4\xba\
    \x86\xe8\xa1\xa8\xe5\x90\x8d\xe4\xb9\x8b\xe5\xa4\x96\xe7\x9a\x84\xe5\x85\
    \xb6\xe4\xbb\x96\xe4\xbf\xa1\xe6\x81\xaf\xe3\x80\x82\n\x20\xe5\x85\xb6\
    \xe4\xbb\x96\xe4\xbf\xa1\xe6\x81\xaf\xe5\x8f\xaf\xe4\xbb\xa5\xe5\x8c\x85\
    \xe5\x90\xab\xe9\xa2\x84\xe7\x95\x99\xe5\x90\x9e\xe5\x90\x90\xe9\x87\x8f\
    \xe4\xbb\xa5\xe5\x8f\x8a\xe8\xa1\xa8\xe7\x9a\x84\xe7\x8a\xb6\xe6\x80\x81\
    \xef\xbc\x8c\xe8\xbf\x99\xe4\xb8\xaa\xe4\xbf\xa1\xe6\x81\xaf\xe5\x8f\xaa\
    \xe8\x83\xbd\xe6\x98\xaf\xe4\xb8\x80\xe4\xb8\xaa\xe7\xb2\x97\xe7\x95\xa5\
    \xe7\x9a\x84\xe4\xbf\xa1\xe6\x81\xaf\xef\xbc\x8c\xe8\xa1\xa8\xe7\x9a\x84\
    \xe8\xaf\xa6\xe7\xbb\x86\xe4\xbf\xa1\xe6\x81\xaf\xe8\xbf\x98\xe6\x98\xaf\
    \xe9\x9c\x80\xe8\xa6\x81\xe9\x80\x9a\xe8\xbf\x87DescribeTable\xe6\x9d\
    \xa5\xe8\x8e\xb7\xe5\x8f\x96\xe3\x80\x82\n\n\x0b\n\x03\x04\x13\x01\x12\
    \x04\xad\x01\x08\x19\n\x0c\n\x04\x04\x13\x02\0\x12\x04\xae\x01\x04$\n\r\
    \n\x05\x04\x13\x02\0\x04\x12\x04\xae\x01\x04\x0c\n\r\n\x05\x04\x13\x02\0\
    \x05\x12\x04\xae\x01\r\x13\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xae\x01\
    \x14\x1f\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xae\x01\"#\ny\n\x02\x04\x14\
    \x12\x06\xb3\x01\0\xb5\x01\x01\x1ak\x20#################################\
    ############\x20\x20DeleteTable\x20\x20#################################\
    ############\x20\n\x0b\n\x03\x04\x14\x01\x12\x04\xb3\x01\x08\x1a\n\x0c\n\
    \x04\x04\x14\x02\0\x12\x04\xb4\x01\x04#\n\r\n\x05\x04\x14\x02\0\x04\x12\
    \x04\xb4\x01\x04\x0c\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xb4\x01\r\x13\n\
    \r\n\x05\x04\x14\x02\0\x01\x12\x04\xb4\x01\x14\x1e\n\r\n\x05\x04\x14\x02\
    \0\x03\x12\x04\xb4\x01!\"\n\x0c\n\x02\x04\x15\x12\x06\xb7\x01\0\xb8\x01\
    \x01\n\x0b\n\x03\x04\x15\x01\x12\x04\xb7\x01\x08\x1b\nw\n\x02\x04\x16\
    \x12\x06\xbc\x01\0\xbe\x01\x01\x1ai\x20#################################\
    ############\x20\x20LoadTable\x20\x20###################################\
    ##########\x20\n\x0b\n\x03\x04\x16\x01\x12\x04\xbc\x01\x08\x18\n\x0c\n\
    \x04\x04\x16\x02\0\x12\x04\xbd\x01\x04#\n\r\n\x05\x04\x16\x02\0\x04\x12\
    \x04\xbd\x01\x04\x0c\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xbd\x01\r\x13\n\
    \r\n\x05\x04\x16\x02\0\x01\x12\x04\xbd\x01\x14\x1e\n\r\n\x05\x04\x16\x02\
    \0\x03\x12\x04\xbd\x01!\"\n\x0c\n\x02\x04\x17\x12\x06\xc0\x01\0\xc1\x01\
    \x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xc0\x01\x08\x19\ny\n\x02\x04\x18\
    \x12\x06\xc5\x01\0\xc7\x01\x01\x1ak\x20#################################\
    ############\x20\x20UnloadTable\x20\x20#################################\
    ############\x20\n\x0b\n\x03\x04\x18\x01\x12\x04\xc5\x01\x08\x1a\n\x0c\n\
    \x04\x04\x18\x02\0\x12\x04\xc6\x01\x04#\n\r\n\x05\x04\x18\x02\0\x04\x12\
    \x04\xc6\x01\x04\x0c\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xc6\x01\r\x13\n\
    \r\n\x05\x04\x18\x02\0\x01\x12\x04\xc6\x01\x14\x1e\n\r\n\x05\x04\x18\x02\
    \0\x03\x12\x04\xc6\x01!\"\n\x0c\n\x02\x04\x19\x12\x06\xc9\x01\0\xcb\x01\
    \x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xc9\x01\x08\x1b\n\xc7\x01\n\x02\x04\
    \x1a\x12\x06\xd3\x01\0\xd7\x01\x01\x1a\xb8\x01*\n\x20\xe6\x97\xb6\xe9\
    \x97\xb4\xe6\x88\xb3\xe7\x9a\x84\xe5\x8f\x96\xe5\x80\xbc\xe6\x9c\x80\xe5\
    \xb0\x8f\xe5\x80\xbc\xe4\xb8\xba0\xef\xbc\x8c\xe6\x9c\x80\xe5\xa4\xa7\
    \xe5\x80\xbc\xe4\xb8\xbaINT64.MAX\n\x201.\x20\xe8\x8b\xa5\xe8\xa6\x81\
    \xe6\x9f\xa5\xe8\xaf\xa2\xe4\xb8\x80\xe4\xb8\xaa\xe8\x8c\x83\xe5\x9b\xb4\
    \xef\xbc\x8c\xe5\x88\x99\xe6\x8c\x87\xe5\xae\x9astart_time\xe5\x92\x8cen\
    d_time\n\x202.\x20\xe8\x8b\xa5\xe8\xa6\x81\xe6\x9f\xa5\xe8\xaf\xa2\xe4\
    \xb8\x80\xe4\xb8\xaa\xe7\x89\xb9\xe5\xae\x9a\xe6\x97\xb6\xe9\x97\xb4\xe6\
    \x88\xb3\xef\xbc\x8c\xe5\x88\x99\xe6\x8c\x87\xe5\xae\x9aspecific_time\n\
    \n\x0b\n\x03\x04\x1a\x01\x12\x04\xd3\x01\x08\x11\n\x0c\n\x04\x04\x1a\x02\
    \0\x12\x04\xd4\x01\x04\"\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xd4\x01\x04\
    \x0c\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xd4\x01\r\x12\n\r\n\x05\x04\x1a\
    \x02\0\x01\x12\x04\xd4\x01\x13\x1d\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\
    \xd4\x01\x20!\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xd5\x01\x04\x20\n\r\n\
    \x05\x04\x1a\x02\x01\x04\x12\x04\xd5\x01\x04\x0c\n\r\n\x05\x04\x1a\x02\
    \x01\x05\x12\x04\xd5\x01\r\x12\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xd5\
    \x01\x13\x1b\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xd5\x01\x1e\x1f\n\x0c\
    \n\x04\x04\x1a\x02\x02\x12\x04\xd6\x01\x04%\n\r\n\x05\x04\x1a\x02\x02\
    \x04\x12\x04\xd6\x01\x04\x0c\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xd6\
    \x01\r\x12\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xd6\x01\x13\x20\n\r\n\
    \x05\x04\x1a\x02\x02\x03\x12\x04\xd6\x01#$\nt\n\x02\x05\x05\x12\x06\xdb\
    \x01\0\xdf\x01\x012f\x20#############################################\
    \x20\x20GetRow\x20\x20#############################################\x20\
    \n\x0b\n\x03\x05\x05\x01\x12\x04\xdb\x01\x05\x0f\n\x0c\n\x04\x05\x05\x02\
    \0\x12\x04\xdc\x01\x04\x10\n\r\n\x05\x05\x05\x02\0\x01\x12\x04\xdc\x01\
    \x04\x0b\n\r\n\x05\x05\x05\x02\0\x02\x12\x04\xdc\x01\x0e\x0f\n\x0c\n\x04\
    \x05\x05\x02\x01\x12\x04\xdd\x01\x04\x0e\n\r\n\x05\x05\x05\x02\x01\x01\
    \x12\x04\xdd\x01\x04\t\n\r\n\x05\x05\x05\x02\x01\x02\x12\x04\xdd\x01\x0c\
    \r\n\x0c\n\x04\x05\x05\x02\x02\x12\x04\xde\x01\x04\x18\n\r\n\x05\x05\x05\
    \x02\x02\x01\x12\x04\xde\x01\x04\x13\n\r\n\x05\x05\x05\x02\x02\x02\x12\
    \x04\xde\x01\x16\x17\n\x0c\n\x02\x04\x1b\x12\x06\xe1\x01\0\xe4\x01\x01\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\xe1\x01\x08\x15\n\x0c\n\x04\x04\x1b\x02\0\
    \x12\x04\xe2\x01\x04(\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xe2\x01\x04\
    \x0c\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\xe2\x01\r\x17\n\r\n\x05\x04\x1b\
    \x02\0\x01\x12\x04\xe2\x01\x18#\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe2\
    \x01&'\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xe3\x01\x04,\n\r\n\x05\x04\
    \x1b\x02\x01\x04\x12\x04\xe3\x01\x04\x0c\n\r\n\x05\x04\x1b\x02\x01\x05\
    \x12\x04\xe3\x01\r\x13\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xe3\x01\x14\
    '\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xe3\x01*+\n\x99\x01\n\x02\x04\
    \x1c\x12\x06\xea\x01\0\xf6\x01\x01\x1a\x8a\x01*\n\x201.\x20\xe6\x94\xaf\
    \xe6\x8c\x81\xe7\x94\xa8\xe6\x88\xb7\xe6\x8c\x87\xe5\xae\x9a\xe7\x89\x88\
    \xe6\x9c\xac\xe6\x97\xb6\xe9\x97\xb4\xe6\x88\xb3\xe8\x8c\x83\xe5\x9b\xb4\
    \xe6\x88\x96\xe8\x80\x85\xe7\x89\xb9\xe5\xae\x9a\xe7\x9a\x84\xe7\x89\x88\
    \xe6\x9c\xac\xe6\x97\xb6\xe9\x97\xb4\xe6\x9d\xa5\xe8\xaf\xbb\xe5\x8f\x96\
    \xe6\x8c\x87\xe5\xae\x9a\xe7\x89\x88\xe6\x9c\xac\xe7\x9a\x84\xe5\x88\x97\
    \n\x202.\x20\xe7\x9b\xae\xe5\x89\x8d\xe6\x9a\x82\xe4\xb8\x8d\xe6\x94\xaf\
    \xe6\x8c\x81\xe8\xa1\x8c\xe5\x86\x85\xe7\x9a\x84\xe6\x96\xad\xe7\x82\xb9\
    \n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xea\x01\x08\x15\n\x0c\n\x04\x04\x1c\
    \x02\0\x12\x04\xeb\x01\x04#\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xeb\x01\
    \x04\x0c\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xeb\x01\r\x13\n\r\n\x05\x04\
    \x1c\x02\0\x01\x12\x04\xeb\x01\x14\x1e\n\r\n\x05\x04\x1c\x02\0\x03\x12\
    \x04\xeb\x01!\"\nH\n\x04\x04\x1c\x02\x01\x12\x04\xec\x01\x04#\":\x20enco\
    ded\x20as\x20InplaceRowChangeSet,\x20but\x20only\x20has\x20primary\x20ke\
    y\n\n\r\n\x05\x04\x1c\x02\x01\x04\x12\x04\xec\x01\x04\x0c\n\r\n\x05\x04\
    \x1c\x02\x01\x05\x12\x04\xec\x01\r\x12\n\r\n\x05\x04\x1c\x02\x01\x01\x12\
    \x04\xec\x01\x13\x1e\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xec\x01!\"\n.\
    \n\x04\x04\x1c\x02\x02\x12\x04\xed\x01\x04'\"\x20\x20\xe4\xb8\x8d\xe6\
    \x8c\x87\xe5\xae\x9a\xe5\x88\x99\xe8\xaf\xbb\xe5\x87\xba\xe6\x89\x80\xe6\
    \x9c\x89\xe7\x9a\x84\xe5\x88\x97\n\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\
    \xed\x01\x04\x0c\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xed\x01\r\x13\n\r\
    \n\x05\x04\x1c\x02\x02\x01\x12\x04\xed\x01\x14\"\n\r\n\x05\x04\x1c\x02\
    \x02\x03\x12\x04\xed\x01%&\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\xee\x01\
    \x04&\n\r\n\x05\x04\x1c\x02\x03\x04\x12\x04\xee\x01\x04\x0c\n\r\n\x05\
    \x04\x1c\x02\x03\x06\x12\x04\xee\x01\r\x16\n\r\n\x05\x04\x1c\x02\x03\x01\
    \x12\x04\xee\x01\x17!\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xee\x01$%\n\
    \x0c\n\x04\x04\x1c\x02\x04\x12\x04\xef\x01\x04$\n\r\n\x05\x04\x1c\x02\
    \x04\x04\x12\x04\xef\x01\x04\x0c\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\
    \xef\x01\r\x12\n\r\n\x05\x04\x1c\x02\x04\x01\x12\x04\xef\x01\x13\x1f\n\r\
    \n\x05\x04\x1c\x02\x04\x03\x12\x04\xef\x01\"#\n;\n\x04\x04\x1c\x02\x05\
    \x12\x04\xf0\x01\x044\"-\x20\xe6\x9c\xac\xe6\xac\xa1\xe8\xaf\xbb\xe5\x87\
    \xba\xe7\x9a\x84\xe6\x95\xb0\xe6\x8d\xae\xe6\x98\xaf\xe5\x90\xa6\xe8\xbf\
    \x9b\xe5\x85\xa5BlockCache\n\n\r\n\x05\x04\x1c\x02\x05\x04\x12\x04\xf0\
    \x01\x04\x0c\n\r\n\x05\x04\x1c\x02\x05\x05\x12\x04\xf0\x01\r\x11\n\r\n\
    \x05\x04\x1c\x02\x05\x01\x12\x04\xf0\x01\x12\x1e\n\r\n\x05\x04\x1c\x02\
    \x05\x03\x12\x04\xf0\x01!\"\n\r\n\x05\x04\x1c\x02\x05\x08\x12\x04\xf0\
    \x01#3\n\r\n\x05\x04\x1c\x02\x05\x07\x12\x04\xf0\x01.2\n\x0c\n\x04\x04\
    \x1c\x02\x06\x12\x04\xf1\x01\x04\x1e\n\r\n\x05\x04\x1c\x02\x06\x04\x12\
    \x04\xf1\x01\x04\x0c\n\r\n\x05\x04\x1c\x02\x06\x05\x12\x04\xf1\x01\r\x12\
    \n\r\n\x05\x04\x1c\x02\x06\x01\x12\x04\xf1\x01\x13\x19\n\r\n\x05\x04\x1c\
    \x02\x06\x03\x12\x04\xf1\x01\x1c\x1d\n\x0c\n\x04\x04\x1c\x02\x07\x12\x04\
    \xf2\x01\x04%\n\r\n\x05\x04\x1c\x02\x07\x04\x12\x04\xf2\x01\x04\x0c\n\r\
    \n\x05\x04\x1c\x02\x07\x05\x12\x04\xf2\x01\r\x13\n\r\n\x05\x04\x1c\x02\
    \x07\x01\x12\x04\xf2\x01\x14\x20\n\r\n\x05\x04\x1c\x02\x07\x03\x12\x04\
    \xf2\x01#$\n\x0c\n\x04\x04\x1c\x02\x08\x12\x04\xf3\x01\x04#\n\r\n\x05\
    \x04\x1c\x02\x08\x04\x12\x04\xf3\x01\x04\x0c\n\r\n\x05\x04\x1c\x02\x08\
    \x05\x12\x04\xf3\x01\r\x13\n\r\n\x05\x04\x1c\x02\x08\x01\x12\x04\xf3\x01\
    \x14\x1e\n\r\n\x05\x04\x1c\x02\x08\x03\x12\x04\xf3\x01!\"\n\x0c\n\x04\
    \x04\x1c\x02\t\x12\x04\xf4\x01\x04\x1e\n\r\n\x05\x04\x1c\x02\t\x04\x12\
    \x04\xf4\x01\x04\x0c\n\r\n\x05\x04\x1c\x02\t\x05\x12\x04\xf4\x01\r\x12\n\
    \r\n\x05\x04\x1c\x02\t\x01\x12\x04\xf4\x01\x13\x18\n\r\n\x05\x04\x1c\x02\
    \t\x03\x12\x04\xf4\x01\x1b\x1d\n\x0c\n\x04\x04\x1c\x02\n\x12\x04\xf5\x01\
    \x04(\n\r\n\x05\x04\x1c\x02\n\x04\x12\x04\xf5\x01\x04\x0c\n\r\n\x05\x04\
    \x1c\x02\n\x05\x12\x04\xf5\x01\r\x13\n\r\n\x05\x04\x1c\x02\n\x01\x12\x04\
    \xf5\x01\x14\"\n\r\n\x05\x04\x1c\x02\n\x03\x12\x04\xf5\x01%'\n\x0c\n\x02\
    \x04\x1d\x12\x06\xf8\x01\0\xfc\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\
    \xf8\x01\x08\x16\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xf9\x01\x04+\n\r\n\
    \x05\x04\x1d\x02\0\x04\x12\x04\xf9\x01\x04\x0c\n\r\n\x05\x04\x1d\x02\0\
    \x06\x12\x04\xf9\x01\r\x1d\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xf9\x01\
    \x1e&\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf9\x01)*\n.\n\x04\x04\x1d\x02\
    \x01\x12\x04\xfa\x01\x04\x1b\"\x20\x20encoded\x20as\x20InplaceRowChangeS\
    et\n\n\r\n\x05\x04\x1d\x02\x01\x04\x12\x04\xfa\x01\x04\x0c\n\r\n\x05\x04\
    \x1d\x02\x01\x05\x12\x04\xfa\x01\r\x12\n\r\n\x05\x04\x1d\x02\x01\x01\x12\
    \x04\xfa\x01\x13\x16\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xfa\x01\x19\
    \x1a\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xfb\x01\x04\"\n\r\n\x05\x04\x1d\
    \x02\x02\x04\x12\x04\xfb\x01\x04\x0c\n\r\n\x05\x04\x1d\x02\x02\x05\x12\
    \x04\xfb\x01\r\x12\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xfb\x01\x13\x1d\
    \n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xfb\x01\x20!\nw\n\x02\x04\x1e\x12\
    \x06\x80\x02\0\x86\x02\x01\x1ai\x20#####################################\
    ########\x20\x20UpdateRow\x20\x20#######################################\
    ######\x20\n\x0b\n\x03\x04\x1e\x01\x12\x04\x80\x02\x08\x18\n\x0c\n\x04\
    \x04\x1e\x02\0\x12\x04\x81\x02\x04#\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\
    \x81\x02\x04\x0c\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\x81\x02\r\x13\n\r\n\
    \x05\x04\x1e\x02\0\x01\x12\x04\x81\x02\x14\x1e\n\r\n\x05\x04\x1e\x02\0\
    \x03\x12\x04\x81\x02!\"\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\x82\x02\x04\
    \"\n\r\n\x05\x04\x1e\x02\x01\x04\x12\x04\x82\x02\x04\x0c\n\r\n\x05\x04\
    \x1e\x02\x01\x05\x12\x04\x82\x02\r\x12\n\r\n\x05\x04\x1e\x02\x01\x01\x12\
    \x04\x82\x02\x13\x1d\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\x82\x02\x20!\
    \n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\x83\x02\x04%\n\r\n\x05\x04\x1e\x02\
    \x02\x04\x12\x04\x83\x02\x04\x0c\n\r\n\x05\x04\x1e\x02\x02\x06\x12\x04\
    \x83\x02\r\x16\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\x83\x02\x17\x20\n\r\
    \n\x05\x04\x1e\x02\x02\x03\x12\x04\x83\x02#$\n\x0c\n\x04\x04\x1e\x02\x03\
    \x12\x04\x84\x02\x04.\n\r\n\x05\x04\x1e\x02\x03\x04\x12\x04\x84\x02\x04\
    \x0c\n\r\n\x05\x04\x1e\x02\x03\x06\x12\x04\x84\x02\r\x1a\n\r\n\x05\x04\
    \x1e\x02\x03\x01\x12\x04\x84\x02\x1b)\n\r\n\x05\x04\x1e\x02\x03\x03\x12\
    \x04\x84\x02,-\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\x85\x02\x04'\n\r\n\
    \x05\x04\x1e\x02\x04\x04\x12\x04\x85\x02\x04\x0c\n\r\n\x05\x04\x1e\x02\
    \x04\x05\x12\x04\x85\x02\r\x13\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\x85\
    \x02\x14\"\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\x85\x02%&\n\x0c\n\x02\
    \x04\x1f\x12\x06\x88\x02\0\x8b\x02\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\
    \x88\x02\x08\x19\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x89\x02\x04+\n\r\n\
    \x05\x04\x1f\x02\0\x04\x12\x04\x89\x02\x04\x0c\n\r\n\x05\x04\x1f\x02\0\
    \x06\x12\x04\x89\x02\r\x1d\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x89\x02\
    \x1e&\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x89\x02)*\n\x0c\n\x04\x04\x1f\
    \x02\x01\x12\x04\x8a\x02\x04\x1b\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\
    \x8a\x02\x04\x0c\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\x8a\x02\r\x12\n\r\
    \n\x05\x04\x1f\x02\x01\x01\x12\x04\x8a\x02\x13\x16\n\r\n\x05\x04\x1f\x02\
    \x01\x03\x12\x04\x8a\x02\x19\x1a\n\xa3\x04\n\x02\x04\x20\x12\x06\x96\x02\
    \0\x9c\x02\x01\x1a\xc1\x02*\n\x20\xe8\xbf\x99\xe9\x87\x8c\xe5\x85\x81\
    \xe8\xae\xb8\xe7\x94\xa8\xe6\x88\xb7\xe4\xb8\xba\xe6\xaf\x8f\xe5\x88\x97\
    \xe5\x8d\x95\xe7\x8b\xac\xe8\xae\xbe\xe7\xbd\xaetimestamp\xef\xbc\x8c\
    \xe8\x80\x8c\xe4\xb8\x8d\xe6\x98\xaf\xe5\xbc\xba\xe5\x88\xb6\xe6\x95\xb4\
    \xe8\xa1\x8c\xe7\xbb\x9f\xe4\xb8\x80\xe4\xb8\x80\xe4\xb8\xaatimestamp\
    \xe3\x80\x82\n\x20\xe5\x8e\x9f\xe5\x9b\xa0\xe6\x98\xaf\xe5\x88\x97\xe9\
    \x83\xbd\xe6\x98\xaf\xe7\x94\xa8\xe7\xbb\x9f\xe4\xb8\x80\xe7\x9a\x84\xe7\
    \xbb\x93\xe6\x9e\x84\xef\xbc\x8c\xe8\xaf\xa5\xe7\xbb\x93\xe6\x9e\x84\xe6\
    \x9c\xac\xe8\xba\xab\xe6\x98\xaf\xe5\xb8\xa6timestamp\xe7\x9a\x84\xef\
    \xbc\x8c\xe5\x85\xb6\xe6\xac\xa1\xe5\xbc\xba\xe5\x88\xb6\xe7\xbb\x9f\xe4\
    \xb8\x80timestamp\xe5\xa2\x9e\xe5\xbc\xba\xe4\xba\x86\xe8\xa7\x84\xe8\
    \x8c\x83\xe6\x80\xa7\xe4\xbd\x86\xe6\x98\xaf\xe4\xb8\xa7\xe5\xa4\xb1\xe4\
    \xba\x86\xe7\x81\xb5\xe6\xb4\xbb\xe6\x80\xa7\xef\xbc\x8c\xe4\xb8\x94\xe8\
    \xaf\xa5\xe8\xa7\x84\xe8\x8c\x83\xe6\x80\xa7\xe6\xb2\xa1\xe6\x9c\x89\xe6\
    \x98\x8e\xe6\x98\xbe\xe7\x9a\x84\xe5\xa5\xbd\xe5\xa4\x84\xef\xbc\x8c\xe5\
    \x8f\x8d\xe8\x80\x8c\xe5\xb8\xa6\xe6\x9d\xa5\xe4\xba\x86\xe7\xbb\x93\xe6\
    \x9e\x84\xe7\x9a\x84\xe5\xa4\x8d\xe6\x9d\x82\xe3\x80\x82\n2i\x20########\
    ########################################################################\
    #######################\x202f\x20#######################################\
    ######\x20\x20PutRow\x20\x20############################################\
    #\x20\n\x0b\n\x03\x04\x20\x01\x12\x04\x96\x02\x08\x15\n\x0c\n\x04\x04\
    \x20\x02\0\x12\x04\x97\x02\x04#\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\x97\
    \x02\x04\x0c\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x97\x02\r\x13\n\r\n\x05\
    \x04\x20\x02\0\x01\x12\x04\x97\x02\x14\x1e\n\r\n\x05\x04\x20\x02\0\x03\
    \x12\x04\x97\x02!\"\n.\n\x04\x04\x20\x02\x01\x12\x04\x98\x02\x04\x1b\"\
    \x20\x20encoded\x20as\x20InplaceRowChangeSet\n\n\r\n\x05\x04\x20\x02\x01\
    \x04\x12\x04\x98\x02\x04\x0c\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\x98\
    \x02\r\x12\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x98\x02\x13\x16\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\x98\x02\x19\x1a\n\x0c\n\x04\x04\x20\x02\
    \x02\x12\x04\x99\x02\x04%\n\r\n\x05\x04\x20\x02\x02\x04\x12\x04\x99\x02\
    \x04\x0c\n\r\n\x05\x04\x20\x02\x02\x06\x12\x04\x99\x02\r\x16\n\r\n\x05\
    \x04\x20\x02\x02\x01\x12\x04\x99\x02\x17\x20\n\r\n\x05\x04\x20\x02\x02\
    \x03\x12\x04\x99\x02#$\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\x9a\x02\x04.\
    \n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x9a\x02\x04\x0c\n\r\n\x05\x04\x20\
    \x02\x03\x06\x12\x04\x9a\x02\r\x1a\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\
    \x9a\x02\x1b)\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\x9a\x02,-\n\x0c\n\
    \x04\x04\x20\x02\x04\x12\x04\x9b\x02\x04'\n\r\n\x05\x04\x20\x02\x04\x04\
    \x12\x04\x9b\x02\x04\x0c\n\r\n\x05\x04\x20\x02\x04\x05\x12\x04\x9b\x02\r\
    \x13\n\r\n\x05\x04\x20\x02\x04\x01\x12\x04\x9b\x02\x14\"\n\r\n\x05\x04\
    \x20\x02\x04\x03\x12\x04\x9b\x02%&\n\x0c\n\x02\x04!\x12\x06\x9e\x02\0\
    \xa1\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\x9e\x02\x08\x16\n\x0c\n\x04\
    \x04!\x02\0\x12\x04\x9f\x02\x04+\n\r\n\x05\x04!\x02\0\x04\x12\x04\x9f\
    \x02\x04\x0c\n\r\n\x05\x04!\x02\0\x06\x12\x04\x9f\x02\r\x1d\n\r\n\x05\
    \x04!\x02\0\x01\x12\x04\x9f\x02\x1e&\n\r\n\x05\x04!\x02\0\x03\x12\x04\
    \x9f\x02)*\n\x0c\n\x04\x04!\x02\x01\x12\x04\xa0\x02\x04\x1b\n\r\n\x05\
    \x04!\x02\x01\x04\x12\x04\xa0\x02\x04\x0c\n\r\n\x05\x04!\x02\x01\x05\x12\
    \x04\xa0\x02\r\x12\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xa0\x02\x13\x16\n\
    \r\n\x05\x04!\x02\x01\x03\x12\x04\xa0\x02\x19\x1a\n\x82\x02\n\x02\x04\"\
    \x12\x06\xa9\x02\0\xaf\x02\x01\x1a\x88\x01*\n\x20OTS\xe5\x8f\xaa\xe6\x94\
    \xaf\xe6\x8c\x81\xe5\x88\xa0\xe9\x99\xa4\xe8\xaf\xa5\xe8\xa1\x8c\xe7\x9a\
    \x84\xe6\x89\x80\xe6\x9c\x89\xe5\x88\x97\xe6\x89\x80\xe6\x9c\x89\xe7\x89\
    \x88\xe6\x9c\xac\xef\xbc\x8c\xe4\xb8\x8d\xe6\x94\xaf\xe6\x8c\x81\xef\xbc\
    \x9a\n\x20\x201.\x20\xe5\x88\xa0\xe9\x99\xa4\xe6\x89\x80\xe6\x9c\x89\xe5\
    \x88\x97\xe7\x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe5\xb0\x8f\xe4\xba\x8e\xe7\
    \xad\x89\xe4\xba\x8e\xe6\x9f\x90\xe4\xb8\xaa\xe7\x89\x88\xe6\x9c\xac\xe7\
    \x9a\x84\xe6\x89\x80\xe6\x9c\x89\xe7\x89\x88\xe6\x9c\xac\n2i\x20########\
    #####################################\x20\x20DeleteRow\x20\x20##########\
    ###################################\x20\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xa9\x02\x08\x18\n\x0c\n\x04\x04\"\x02\0\x12\x04\xaa\x02\x04#\n\r\n\x05\
    \x04\"\x02\0\x04\x12\x04\xaa\x02\x04\x0c\n\r\n\x05\x04\"\x02\0\x05\x12\
    \x04\xaa\x02\r\x13\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xaa\x02\x14\x1e\n\r\
    \n\x05\x04\"\x02\0\x03\x12\x04\xaa\x02!\"\nH\n\x04\x04\"\x02\x01\x12\x04\
    \xab\x02\x04#\":\x20encoded\x20as\x20InplaceRowChangeSet,\x20but\x20only\
    \x20has\x20primary\x20key\n\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xab\x02\
    \x04\x0c\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xab\x02\r\x12\n\r\n\x05\x04\
    \"\x02\x01\x01\x12\x04\xab\x02\x13\x1e\n\r\n\x05\x04\"\x02\x01\x03\x12\
    \x04\xab\x02!\"\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xac\x02\x04%\n\r\n\x05\
    \x04\"\x02\x02\x04\x12\x04\xac\x02\x04\x0c\n\r\n\x05\x04\"\x02\x02\x06\
    \x12\x04\xac\x02\r\x16\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xac\x02\x17\
    \x20\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xac\x02#$\n\x0c\n\x04\x04\"\x02\
    \x03\x12\x04\xad\x02\x04.\n\r\n\x05\x04\"\x02\x03\x04\x12\x04\xad\x02\
    \x04\x0c\n\r\n\x05\x04\"\x02\x03\x06\x12\x04\xad\x02\r\x1a\n\r\n\x05\x04\
    \"\x02\x03\x01\x12\x04\xad\x02\x1b)\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\
    \xad\x02,-\n\x0c\n\x04\x04\"\x02\x04\x12\x04\xae\x02\x04'\n\r\n\x05\x04\
    \"\x02\x04\x04\x12\x04\xae\x02\x04\x0c\n\r\n\x05\x04\"\x02\x04\x05\x12\
    \x04\xae\x02\r\x13\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xae\x02\x14\"\n\r\
    \n\x05\x04\"\x02\x04\x03\x12\x04\xae\x02%&\n\x0c\n\x02\x04#\x12\x06\xb1\
    \x02\0\xb4\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\xb1\x02\x08\x19\n\x0c\n\
    \x04\x04#\x02\0\x12\x04\xb2\x02\x04+\n\r\n\x05\x04#\x02\0\x04\x12\x04\
    \xb2\x02\x04\x0c\n\r\n\x05\x04#\x02\0\x06\x12\x04\xb2\x02\r\x1d\n\r\n\
    \x05\x04#\x02\0\x01\x12\x04\xb2\x02\x1e&\n\r\n\x05\x04#\x02\0\x03\x12\
    \x04\xb2\x02)*\n\x0c\n\x04\x04#\x02\x01\x12\x04\xb3\x02\x04\x1b\n\r\n\
    \x05\x04#\x02\x01\x04\x12\x04\xb3\x02\x04\x0c\n\r\n\x05\x04#\x02\x01\x05\
    \x12\x04\xb3\x02\r\x12\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xb3\x02\x13\
    \x16\n\r\n\x05\x04#\x02\x01\x03\x12\x04\xb3\x02\x19\x1a\n\xce\x01\n\x02\
    \x04$\x12\x06\xbb\x02\0\xc6\x02\x01\x1aS*\n\x20HBase\xe6\x94\xaf\xe6\x8c\
    \x81Batch\xe6\x93\x8d\xe4\xbd\x9c\xe7\x9a\x84\xe6\xaf\x8f\xe8\xa1\x8c\
    \xe9\x83\xbd\xe6\x8b\xa5\xe6\x9c\x89\xe4\xb8\x8d\xe5\x90\x8c\xe7\x9a\x84\
    \xe6\x9f\xa5\xe8\xaf\xa2\xe5\x8f\x82\xe6\x95\xb0\xef\xbc\x8cOTS\xe4\xb8\
    \x8d\xe6\x94\xaf\xe6\x8c\x81\xe3\x80\x82\n2k\x20########################\
    #####################\x20\x20BatchGetRow\x20\x20########################\
    #####################\x20\n\x0b\n\x03\x04$\x01\x12\x04\xbb\x02\x08!\n\
    \x0c\n\x04\x04$\x02\0\x12\x04\xbc\x02\x04#\n\r\n\x05\x04$\x02\0\x04\x12\
    \x04\xbc\x02\x04\x0c\n\r\n\x05\x04$\x02\0\x05\x12\x04\xbc\x02\r\x13\n\r\
    \n\x05\x04$\x02\0\x01\x12\x04\xbc\x02\x14\x1e\n\r\n\x05\x04$\x02\0\x03\
    \x12\x04\xbc\x02!\"\nH\n\x04\x04$\x02\x01\x12\x04\xbd\x02\x04#\":\x20enc\
    oded\x20as\x20InplaceRowChangeSet,\x20but\x20only\x20has\x20primary\x20k\
    ey\n\n\r\n\x05\x04$\x02\x01\x04\x12\x04\xbd\x02\x04\x0c\n\r\n\x05\x04$\
    \x02\x01\x05\x12\x04\xbd\x02\r\x12\n\r\n\x05\x04$\x02\x01\x01\x12\x04\
    \xbd\x02\x13\x1e\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xbd\x02!\"\n\x0c\n\
    \x04\x04$\x02\x02\x12\x04\xbe\x02\x04\x1d\n\r\n\x05\x04$\x02\x02\x04\x12\
    \x04\xbe\x02\x04\x0c\n\r\n\x05\x04$\x02\x02\x05\x12\x04\xbe\x02\r\x12\n\
    \r\n\x05\x04$\x02\x02\x01\x12\x04\xbe\x02\x13\x18\n\r\n\x05\x04$\x02\x02\
    \x03\x12\x04\xbe\x02\x1b\x1c\n.\n\x04\x04$\x02\x03\x12\x04\xbf\x02\x04'\
    \"\x20\x20\xe4\xb8\x8d\xe6\x8c\x87\xe5\xae\x9a\xe5\x88\x99\xe8\xaf\xbb\
    \xe5\x87\xba\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\x84\xe5\x88\x97\n\n\r\n\x05\
    \x04$\x02\x03\x04\x12\x04\xbf\x02\x04\x0c\n\r\n\x05\x04$\x02\x03\x05\x12\
    \x04\xbf\x02\r\x13\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xbf\x02\x14\"\n\r\
    \n\x05\x04$\x02\x03\x03\x12\x04\xbf\x02%&\n\x0c\n\x04\x04$\x02\x04\x12\
    \x04\xc0\x02\x04&\n\r\n\x05\x04$\x02\x04\x04\x12\x04\xc0\x02\x04\x0c\n\r\
    \n\x05\x04$\x02\x04\x06\x12\x04\xc0\x02\r\x16\n\r\n\x05\x04$\x02\x04\x01\
    \x12\x04\xc0\x02\x17!\n\r\n\x05\x04$\x02\x04\x03\x12\x04\xc0\x02$%\n\x0c\
    \n\x04\x04$\x02\x05\x12\x04\xc1\x02\x04$\n\r\n\x05\x04$\x02\x05\x04\x12\
    \x04\xc1\x02\x04\x0c\n\r\n\x05\x04$\x02\x05\x05\x12\x04\xc1\x02\r\x12\n\
    \r\n\x05\x04$\x02\x05\x01\x12\x04\xc1\x02\x13\x1f\n\r\n\x05\x04$\x02\x05\
    \x03\x12\x04\xc1\x02\"#\n;\n\x04\x04$\x02\x06\x12\x04\xc2\x02\x044\"-\
    \x20\xe6\x9c\xac\xe6\xac\xa1\xe8\xaf\xbb\xe5\x87\xba\xe7\x9a\x84\xe6\x95\
    \xb0\xe6\x8d\xae\xe6\x98\xaf\xe5\x90\xa6\xe8\xbf\x9b\xe5\x85\xa5BlockCac\
    he\n\n\r\n\x05\x04$\x02\x06\x04\x12\x04\xc2\x02\x04\x0c\n\r\n\x05\x04$\
    \x02\x06\x05\x12\x04\xc2\x02\r\x11\n\r\n\x05\x04$\x02\x06\x01\x12\x04\
    \xc2\x02\x12\x1e\n\r\n\x05\x04$\x02\x06\x03\x12\x04\xc2\x02!\"\n\r\n\x05\
    \x04$\x02\x06\x08\x12\x04\xc2\x02#3\n\r\n\x05\x04$\x02\x06\x07\x12\x04\
    \xc2\x02.2\n\x0c\n\x04\x04$\x02\x07\x12\x04\xc3\x02\x04\x1e\n\r\n\x05\
    \x04$\x02\x07\x04\x12\x04\xc3\x02\x04\x0c\n\r\n\x05\x04$\x02\x07\x05\x12\
    \x04\xc3\x02\r\x12\n\r\n\x05\x04$\x02\x07\x01\x12\x04\xc3\x02\x13\x19\n\
    \r\n\x05\x04$\x02\x07\x03\x12\x04\xc3\x02\x1c\x1d\n\x0c\n\x04\x04$\x02\
    \x08\x12\x04\xc4\x02\x04%\n\r\n\x05\x04$\x02\x08\x04\x12\x04\xc4\x02\x04\
    \x0c\n\r\n\x05\x04$\x02\x08\x05\x12\x04\xc4\x02\r\x13\n\r\n\x05\x04$\x02\
    \x08\x01\x12\x04\xc4\x02\x14\x20\n\r\n\x05\x04$\x02\x08\x03\x12\x04\xc4\
    \x02#$\n\x0c\n\x04\x04$\x02\t\x12\x04\xc5\x02\x04$\n\r\n\x05\x04$\x02\t\
    \x04\x12\x04\xc5\x02\x04\x0c\n\r\n\x05\x04$\x02\t\x05\x12\x04\xc5\x02\r\
    \x13\n\r\n\x05\x04$\x02\t\x01\x12\x04\xc5\x02\x14\x1e\n\r\n\x05\x04$\x02\
    \t\x03\x12\x04\xc5\x02!#\n\x0c\n\x02\x04%\x12\x06\xc8\x02\0\xca\x02\x01\
    \n\x0b\n\x03\x04%\x01\x12\x04\xc8\x02\x08\x1a\n\x0c\n\x04\x04%\x02\0\x12\
    \x04\xc9\x02\x042\n\r\n\x05\x04%\x02\0\x04\x12\x04\xc9\x02\x04\x0c\n\r\n\
    \x05\x04%\x02\0\x06\x12\x04\xc9\x02\r&\n\r\n\x05\x04%\x02\0\x01\x12\x04\
    \xc9\x02'-\n\r\n\x05\x04%\x02\0\x03\x12\x04\xc9\x0201\n\x0c\n\x02\x04&\
    \x12\x06\xcc\x02\0\xd2\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\xcc\x02\x08\
    \x20\n\x0c\n\x04\x04&\x02\0\x12\x04\xcd\x02\x04\x1c\n\r\n\x05\x04&\x02\0\
    \x04\x12\x04\xcd\x02\x04\x0c\n\r\n\x05\x04&\x02\0\x05\x12\x04\xcd\x02\r\
    \x11\n\r\n\x05\x04&\x02\0\x01\x12\x04\xcd\x02\x12\x17\n\r\n\x05\x04&\x02\
    \0\x03\x12\x04\xcd\x02\x1a\x1b\n\x0c\n\x04\x04&\x02\x01\x12\x04\xce\x02\
    \x04\x1d\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xce\x02\x04\x0c\n\r\n\x05\
    \x04&\x02\x01\x06\x12\x04\xce\x02\r\x12\n\r\n\x05\x04&\x02\x01\x01\x12\
    \x04\xce\x02\x13\x18\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xce\x02\x1b\x1c\
    \n\x0c\n\x04\x04&\x02\x02\x12\x04\xcf\x02\x04+\n\r\n\x05\x04&\x02\x02\
    \x04\x12\x04\xcf\x02\x04\x0c\n\r\n\x05\x04&\x02\x02\x06\x12\x04\xcf\x02\
    \r\x1d\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xcf\x02\x1e&\n\r\n\x05\x04&\
    \x02\x02\x03\x12\x04\xcf\x02)*\n.\n\x04\x04&\x02\x03\x12\x04\xd0\x02\x04\
    \x1b\"\x20\x20encoded\x20as\x20InplaceRowChangeSet\n\n\r\n\x05\x04&\x02\
    \x03\x04\x12\x04\xd0\x02\x04\x0c\n\r\n\x05\x04&\x02\x03\x05\x12\x04\xd0\
    \x02\r\x12\n\r\n\x05\x04&\x02\x03\x01\x12\x04\xd0\x02\x13\x16\n\r\n\x05\
    \x04&\x02\x03\x03\x12\x04\xd0\x02\x19\x1a\n\x0c\n\x04\x04&\x02\x04\x12\
    \x04\xd1\x02\x04\"\n\r\n\x05\x04&\x02\x04\x04\x12\x04\xd1\x02\x04\x0c\n\
    \r\n\x05\x04&\x02\x04\x05\x12\x04\xd1\x02\r\x12\n\r\n\x05\x04&\x02\x04\
    \x01\x12\x04\xd1\x02\x13\x1d\n\r\n\x05\x04&\x02\x04\x03\x12\x04\xd1\x02\
    \x20!\n\x0c\n\x02\x04'\x12\x06\xd4\x02\0\xd7\x02\x01\n\x0b\n\x03\x04'\
    \x01\x12\x04\xd4\x02\x08\"\n\x0c\n\x04\x04'\x02\0\x12\x04\xd5\x02\x04#\n\
    \r\n\x05\x04'\x02\0\x04\x12\x04\xd5\x02\x04\x0c\n\r\n\x05\x04'\x02\0\x05\
    \x12\x04\xd5\x02\r\x13\n\r\n\x05\x04'\x02\0\x01\x12\x04\xd5\x02\x14\x1e\
    \n\r\n\x05\x04'\x02\0\x03\x12\x04\xd5\x02!\"\n\x0c\n\x04\x04'\x02\x01\
    \x12\x04\xd6\x02\x04/\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xd6\x02\x04\x0c\
    \n\r\n\x05\x04'\x02\x01\x06\x12\x04\xd6\x02\r%\n\r\n\x05\x04'\x02\x01\
    \x01\x12\x04\xd6\x02&*\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xd6\x02-.\n\
    \x0c\n\x02\x04(\x12\x06\xd9\x02\0\xdb\x02\x01\n\x0b\n\x03\x04(\x01\x12\
    \x04\xd9\x02\x08\x1b\n\x0c\n\x04\x04(\x02\0\x12\x04\xda\x02\x043\n\r\n\
    \x05\x04(\x02\0\x04\x12\x04\xda\x02\x04\x0c\n\r\n\x05\x04(\x02\0\x06\x12\
    \x04\xda\x02\r'\n\r\n\x05\x04(\x02\0\x01\x12\x04\xda\x02(.\n\r\n\x05\x04\
    (\x02\0\x03\x12\x04\xda\x0212\n{\n\x02\x05\x06\x12\x06\xe0\x02\0\xe4\x02\
    \x012m\x20#############################################\x20\x20BatchWrit\
    eRow\x20\x20#############################################\x20\n\x0b\n\
    \x03\x05\x06\x01\x12\x04\xe0\x02\x05\x12\n\x0c\n\x04\x05\x06\x02\0\x12\
    \x04\xe1\x02\x04\x0c\n\r\n\x05\x05\x06\x02\0\x01\x12\x04\xe1\x02\x04\x07\
    \n\r\n\x05\x05\x06\x02\0\x02\x12\x04\xe1\x02\n\x0b\n\x0c\n\x04\x05\x06\
    \x02\x01\x12\x04\xe2\x02\x04\x0f\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\
    \xe2\x02\x04\n\n\r\n\x05\x05\x06\x02\x01\x02\x12\x04\xe2\x02\r\x0e\n\x0c\
    \n\x04\x05\x06\x02\x02\x12\x04\xe3\x02\x04\x0f\n\r\n\x05\x05\x06\x02\x02\
    \x01\x12\x04\xe3\x02\x04\n\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\xe3\x02\
    \r\x0e\n\x0c\n\x02\x04)\x12\x06\xe6\x02\0\xeb\x02\x01\n\x0b\n\x03\x04)\
    \x01\x12\x04\xe6\x02\x08!\n\x0c\n\x04\x04)\x02\0\x12\x04\xe7\x02\x04$\n\
    \r\n\x05\x04)\x02\0\x04\x12\x04\xe7\x02\x04\x0c\n\r\n\x05\x04)\x02\0\x06\
    \x12\x04\xe7\x02\r\x1a\n\r\n\x05\x04)\x02\0\x01\x12\x04\xe7\x02\x1b\x1f\
    \n\r\n\x05\x04)\x02\0\x03\x12\x04\xe7\x02\"#\n.\n\x04\x04)\x02\x01\x12\
    \x04\xe8\x02\x04\"\"\x20\x20encoded\x20as\x20InplaceRowChangeSet\n\n\r\n\
    \x05\x04)\x02\x01\x04\x12\x04\xe8\x02\x04\x0c\n\r\n\x05\x04)\x02\x01\x05\
    \x12\x04\xe8\x02\r\x12\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xe8\x02\x13\
    \x1d\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xe8\x02\x20!\n\x0c\n\x04\x04)\
    \x02\x02\x12\x04\xe9\x02\x04%\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xe9\x02\
    \x04\x0c\n\r\n\x05\x04)\x02\x02\x06\x12\x04\xe9\x02\r\x16\n\r\n\x05\x04)\
    \x02\x02\x01\x12\x04\xe9\x02\x17\x20\n\r\n\x05\x04)\x02\x02\x03\x12\x04\
    \xe9\x02#$\n\x0c\n\x04\x04)\x02\x03\x12\x04\xea\x02\x04.\n\r\n\x05\x04)\
    \x02\x03\x04\x12\x04\xea\x02\x04\x0c\n\r\n\x05\x04)\x02\x03\x06\x12\x04\
    \xea\x02\r\x1a\n\r\n\x05\x04)\x02\x03\x01\x12\x04\xea\x02\x1b)\n\r\n\x05\
    \x04)\x02\x03\x03\x12\x04\xea\x02,-\n\x0c\n\x02\x04*\x12\x06\xed\x02\0\
    \xf0\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\xed\x02\x08#\n\x0c\n\x04\x04*\
    \x02\0\x12\x04\xee\x02\x04#\n\r\n\x05\x04*\x02\0\x04\x12\x04\xee\x02\x04\
    \x0c\n\r\n\x05\x04*\x02\0\x05\x12\x04\xee\x02\r\x13\n\r\n\x05\x04*\x02\0\
    \x01\x12\x04\xee\x02\x14\x1e\n\r\n\x05\x04*\x02\0\x03\x12\x04\xee\x02!\"\
    \n\x0c\n\x04\x04*\x02\x01\x12\x04\xef\x02\x040\n\r\n\x05\x04*\x02\x01\
    \x04\x12\x04\xef\x02\x04\x0c\n\r\n\x05\x04*\x02\x01\x06\x12\x04\xef\x02\
    \r&\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xef\x02'+\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xef\x02./\n\x0c\n\x02\x04+\x12\x06\xf2\x02\0\xf6\x02\x01\n\
    \x0b\n\x03\x04+\x01\x12\x04\xf2\x02\x08\x1c\n\x0c\n\x04\x04+\x02\0\x12\
    \x04\xf3\x02\x044\n\r\n\x05\x04+\x02\0\x04\x12\x04\xf3\x02\x04\x0c\n\r\n\
    \x05\x04+\x02\0\x06\x12\x04\xf3\x02\r(\n\r\n\x05\x04+\x02\0\x01\x12\x04\
    \xf3\x02)/\n\r\n\x05\x04+\x02\0\x03\x12\x04\xf3\x0223\n\x0c\n\x04\x04+\
    \x02\x01\x12\x04\xf4\x02\x04'\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xf4\x02\
    \x04\x0c\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xf4\x02\r\x13\n\r\n\x05\x04+\
    \x02\x01\x01\x12\x04\xf4\x02\x14\"\n\r\n\x05\x04+\x02\x01\x03\x12\x04\
    \xf4\x02%&\n\x0c\n\x04\x04+\x02\x02\x12\x04\xf5\x02\x04\x20\n\r\n\x05\
    \x04+\x02\x02\x04\x12\x04\xf5\x02\x04\x0c\n\r\n\x05\x04+\x02\x02\x05\x12\
    \x04\xf5\x02\r\x11\n\r\n\x05\x04+\x02\x02\x01\x12\x04\xf5\x02\x12\x1b\n\
    \r\n\x05\x04+\x02\x02\x03\x12\x04\xf5\x02\x1e\x1f\n\x0c\n\x02\x04,\x12\
    \x06\xf8\x02\0\xfd\x02\x01\n\x0b\n\x03\x04,\x01\x12\x04\xf8\x02\x08\"\n\
    \x0c\n\x04\x04,\x02\0\x12\x04\xf9\x02\x04\x1c\n\r\n\x05\x04,\x02\0\x04\
    \x12\x04\xf9\x02\x04\x0c\n\r\n\x05\x04,\x02\0\x05\x12\x04\xf9\x02\r\x11\
    \n\r\n\x05\x04,\x02\0\x01\x12\x04\xf9\x02\x12\x17\n\r\n\x05\x04,\x02\0\
    \x03\x12\x04\xf9\x02\x1a\x1b\n\x0c\n\x04\x04,\x02\x01\x12\x04\xfa\x02\
    \x04\x1d\n\r\n\x05\x04,\x02\x01\x04\x12\x04\xfa\x02\x04\x0c\n\r\n\x05\
    \x04,\x02\x01\x06\x12\x04\xfa\x02\r\x12\n\r\n\x05\x04,\x02\x01\x01\x12\
    \x04\xfa\x02\x13\x18\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xfa\x02\x1b\x1c\
    \n\x0c\n\x04\x04,\x02\x02\x12\x04\xfb\x02\x04+\n\r\n\x05\x04,\x02\x02\
    \x04\x12\x04\xfb\x02\x04\x0c\n\r\n\x05\x04,\x02\x02\x06\x12\x04\xfb\x02\
    \r\x1d\n\r\n\x05\x04,\x02\x02\x01\x12\x04\xfb\x02\x1e&\n\r\n\x05\x04,\
    \x02\x02\x03\x12\x04\xfb\x02)*\n\x0c\n\x04\x04,\x02\x03\x12\x04\xfc\x02\
    \x04\x1b\n\r\n\x05\x04,\x02\x03\x04\x12\x04\xfc\x02\x04\x0c\n\r\n\x05\
    \x04,\x02\x03\x05\x12\x04\xfc\x02\r\x12\n\r\n\x05\x04,\x02\x03\x01\x12\
    \x04\xfc\x02\x13\x16\n\r\n\x05\x04,\x02\x03\x03\x12\x04\xfc\x02\x19\x1a\
    \n\x0c\n\x02\x04-\x12\x06\xff\x02\0\x82\x03\x01\n\x0b\n\x03\x04-\x01\x12\
    \x04\xff\x02\x08$\n\x0c\n\x04\x04-\x02\0\x12\x04\x80\x03\x04#\n\r\n\x05\
    \x04-\x02\0\x04\x12\x04\x80\x03\x04\x0c\n\r\n\x05\x04-\x02\0\x05\x12\x04\
    \x80\x03\r\x13\n\r\n\x05\x04-\x02\0\x01\x12\x04\x80\x03\x14\x1e\n\r\n\
    \x05\x04-\x02\0\x03\x12\x04\x80\x03!\"\n\x0c\n\x04\x04-\x02\x01\x12\x04\
    \x81\x03\x041\n\r\n\x05\x04-\x02\x01\x04\x12\x04\x81\x03\x04\x0c\n\r\n\
    \x05\x04-\x02\x01\x06\x12\x04\x81\x03\r'\n\r\n\x05\x04-\x02\x01\x01\x12\
    \x04\x81\x03(,\n\r\n\x05\x04-\x02\x01\x03\x12\x04\x81\x03/0\n\x0c\n\x02\
    \x04.\x12\x06\x84\x03\0\x86\x03\x01\n\x0b\n\x03\x04.\x01\x12\x04\x84\x03\
    \x08\x1d\n\x0c\n\x04\x04.\x02\0\x12\x04\x85\x03\x045\n\r\n\x05\x04.\x02\
    \0\x04\x12\x04\x85\x03\x04\x0c\n\r\n\x05\x04.\x02\0\x06\x12\x04\x85\x03\
    \r)\n\r\n\x05\x04.\x02\0\x01\x12\x04\x85\x03*0\n\r\n\x05\x04.\x02\0\x03\
    \x12\x04\x85\x0334\nv\n\x02\x05\x07\x12\x06\x8a\x03\0\x8d\x03\x01\x1ah\
    \x20#############################################\x20\x20GetRange\x20\
    \x20#############################################\x20\n\x0b\n\x03\x05\
    \x07\x01\x12\x04\x8a\x03\x05\x0e\n\x0c\n\x04\x05\x07\x02\0\x12\x04\x8b\
    \x03\x04\x10\n\r\n\x05\x05\x07\x02\0\x01\x12\x04\x8b\x03\x04\x0b\n\r\n\
    \x05\x05\x07\x02\0\x02\x12\x04\x8b\x03\x0e\x0f\n\x0c\n\x04\x05\x07\x02\
    \x01\x12\x04\x8c\x03\x04\x11\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\x8c\
    \x03\x04\x0c\n\r\n\x05\x05\x07\x02\x01\x02\x12\x04\x8c\x03\x0f\x10\n\xae\
    \x01\n\x02\x04/\x12\x06\x95\x03\0\xa4\x03\x01\x1a\x9f\x01*\n\x20HBase\
    \xe6\x94\xaf\xe6\x8c\x81\xe4\xbb\xa5\xe4\xb8\x8b\xe5\x8f\x82\xe6\x95\xb0\
    \xef\xbc\x9a\n\x20\x20\x20\x20\x201.\x20TimeRange\xe6\x88\x96\xe6\x8c\
    \x87\xe5\xae\x9atime\n\x20\x20\x20\x20\x202.\x20Filter\xef\xbc\x88\xe6\
    \xa0\xb9\xe6\x8d\xae\xe5\x88\x97\xe5\x80\xbc\xe6\x88\x96\xe5\x88\x97\xe5\
    \x90\x8d\xe6\x9d\xa5\xe8\xbf\x87\xe6\xbb\xa4\xef\xbc\x89\n\x20\xe6\x88\
    \x91\xe4\xbb\xac\xe5\x8f\xaa\xe6\x94\xaf\xe6\x8c\x81\xe7\xbb\x99\xe5\x90\
    \x8c\xe7\x89\x88\xe6\x9c\xac\xe7\x9a\x84\xe9\x80\x89\xe6\x8b\xa9\xe6\x9d\
    \xa1\xe4\xbb\xb6\xe3\x80\x82\n\n\x0b\n\x03\x04/\x01\x12\x04\x95\x03\x08\
    \x17\n\x0c\n\x04\x04/\x02\0\x12\x04\x96\x03\x04#\n\r\n\x05\x04/\x02\0\
    \x04\x12\x04\x96\x03\x04\x0c\n\r\n\x05\x04/\x02\0\x05\x12\x04\x96\x03\r\
    \x13\n\r\n\x05\x04/\x02\0\x01\x12\x04\x96\x03\x14\x1e\n\r\n\x05\x04/\x02\
    \0\x03\x12\x04\x96\x03!\"\n\x0c\n\x04\x04/\x02\x01\x12\x04\x97\x03\x04%\
    \n\r\n\x05\x04/\x02\x01\x04\x12\x04\x97\x03\x04\x0c\n\r\n\x05\x04/\x02\
    \x01\x06\x12\x04\x97\x03\r\x16\n\r\n\x05\x04/\x02\x01\x01\x12\x04\x97\
    \x03\x17\x20\n\r\n\x05\x04/\x02\x01\x03\x12\x04\x97\x03#$\n.\n\x04\x04/\
    \x02\x02\x12\x04\x98\x03\x04'\"\x20\x20\xe4\xb8\x8d\xe6\x8c\x87\xe5\xae\
    \x9a\xe5\x88\x99\xe8\xaf\xbb\xe5\x87\xba\xe6\x89\x80\xe6\x9c\x89\xe7\x9a\
    \x84\xe5\x88\x97\n\n\r\n\x05\x04/\x02\x02\x04\x12\x04\x98\x03\x04\x0c\n\
    \r\n\x05\x04/\x02\x02\x05\x12\x04\x98\x03\r\x13\n\r\n\x05\x04/\x02\x02\
    \x01\x12\x04\x98\x03\x14\"\n\r\n\x05\x04/\x02\x02\x03\x12\x04\x98\x03%&\
    \n\x0c\n\x04\x04/\x02\x03\x12\x04\x99\x03\x04&\n\r\n\x05\x04/\x02\x03\
    \x04\x12\x04\x99\x03\x04\x0c\n\r\n\x05\x04/\x02\x03\x06\x12\x04\x99\x03\
    \r\x16\n\r\n\x05\x04/\x02\x03\x01\x12\x04\x99\x03\x17!\n\r\n\x05\x04/\
    \x02\x03\x03\x12\x04\x99\x03$%\n\x0c\n\x04\x04/\x02\x04\x12\x04\x9a\x03\
    \x04$\n\r\n\x05\x04/\x02\x04\x04\x12\x04\x9a\x03\x04\x0c\n\r\n\x05\x04/\
    \x02\x04\x05\x12\x04\x9a\x03\r\x12\n\r\n\x05\x04/\x02\x04\x01\x12\x04\
    \x9a\x03\x13\x1f\n\r\n\x05\x04/\x02\x04\x03\x12\x04\x9a\x03\"#\n\x0c\n\
    \x04\x04/\x02\x05\x12\x04\x9b\x03\x04\x1d\n\r\n\x05\x04/\x02\x05\x04\x12\
    \x04\x9b\x03\x04\x0c\n\r\n\x05\x04/\x02\x05\x05\x12\x04\x9b\x03\r\x12\n\
    \r\n\x05\x04/\x02\x05\x01\x12\x04\x9b\x03\x13\x18\n\r\n\x05\x04/\x02\x05\
    \x03\x12\x04\x9b\x03\x1b\x1c\nH\n\x04\x04/\x02\x06\x12\x04\x9c\x03\x043\
    \":\x20encoded\x20as\x20InplaceRowChangeSet,\x20but\x20only\x20has\x20pr\
    imary\x20key\n\n\r\n\x05\x04/\x02\x06\x04\x12\x04\x9c\x03\x04\x0c\n\r\n\
    \x05\x04/\x02\x06\x05\x12\x04\x9c\x03\r\x12\n\r\n\x05\x04/\x02\x06\x01\
    \x12\x04\x9c\x03\x13.\n\r\n\x05\x04/\x02\x06\x03\x12\x04\x9c\x0312\nH\n\
    \x04\x04/\x02\x07\x12\x04\x9d\x03\x041\":\x20encoded\x20as\x20InplaceRow\
    ChangeSet,\x20but\x20only\x20has\x20primary\x20key\n\n\r\n\x05\x04/\x02\
    \x07\x04\x12\x04\x9d\x03\x04\x0c\n\r\n\x05\x04/\x02\x07\x05\x12\x04\x9d\
    \x03\r\x12\n\r\n\x05\x04/\x02\x07\x01\x12\x04\x9d\x03\x13,\n\r\n\x05\x04\
    /\x02\x07\x03\x12\x04\x9d\x03/0\n;\n\x04\x04/\x02\x08\x12\x04\x9e\x03\
    \x044\"-\x20\xe6\x9c\xac\xe6\xac\xa1\xe8\xaf\xbb\xe5\x87\xba\xe7\x9a\x84\
    \xe6\x95\xb0\xe6\x8d\xae\xe6\x98\xaf\xe5\x90\xa6\xe8\xbf\x9b\xe5\x85\xa5\
    BlockCache\n\n\r\n\x05\x04/\x02\x08\x04\x12\x04\x9e\x03\x04\x0c\n\r\n\
    \x05\x04/\x02\x08\x05\x12\x04\x9e\x03\r\x11\n\r\n\x05\x04/\x02\x08\x01\
    \x12\x04\x9e\x03\x12\x1e\n\r\n\x05\x04/\x02\x08\x03\x12\x04\x9e\x03!\"\n\
    \r\n\x05\x04/\x02\x08\x08\x12\x04\x9e\x03#3\n\r\n\x05\x04/\x02\x08\x07\
    \x12\x04\x9e\x03.2\n\x0c\n\x04\x04/\x02\t\x12\x04\x9f\x03\x04\x1f\n\r\n\
    \x05\x04/\x02\t\x04\x12\x04\x9f\x03\x04\x0c\n\r\n\x05\x04/\x02\t\x05\x12\
    \x04\x9f\x03\r\x12\n\r\n\x05\x04/\x02\t\x01\x12\x04\x9f\x03\x13\x19\n\r\
    \n\x05\x04/\x02\t\x03\x12\x04\x9f\x03\x1c\x1e\n\x0c\n\x04\x04/\x02\n\x12\
    \x04\xa0\x03\x04&\n\r\n\x05\x04/\x02\n\x04\x12\x04\xa0\x03\x04\x0c\n\r\n\
    \x05\x04/\x02\n\x05\x12\x04\xa0\x03\r\x13\n\r\n\x05\x04/\x02\n\x01\x12\
    \x04\xa0\x03\x14\x20\n\r\n\x05\x04/\x02\n\x03\x12\x04\xa0\x03#%\n\x0c\n\
    \x04\x04/\x02\x0b\x12\x04\xa1\x03\x04$\n\r\n\x05\x04/\x02\x0b\x04\x12\
    \x04\xa1\x03\x04\x0c\n\r\n\x05\x04/\x02\x0b\x05\x12\x04\xa1\x03\r\x13\n\
    \r\n\x05\x04/\x02\x0b\x01\x12\x04\xa1\x03\x14\x1e\n\r\n\x05\x04/\x02\x0b\
    \x03\x12\x04\xa1\x03!#\n\x0c\n\x04\x04/\x02\x0c\x12\x04\xa2\x03\x04\x1e\
    \n\r\n\x05\x04/\x02\x0c\x04\x12\x04\xa2\x03\x04\x0c\n\r\n\x05\x04/\x02\
    \x0c\x05\x12\x04\xa2\x03\r\x12\n\r\n\x05\x04/\x02\x0c\x01\x12\x04\xa2\
    \x03\x13\x18\n\r\n\x05\x04/\x02\x0c\x03\x12\x04\xa2\x03\x1b\x1d\n\x0c\n\
    \x04\x04/\x02\r\x12\x04\xa3\x03\x04(\n\r\n\x05\x04/\x02\r\x04\x12\x04\
    \xa3\x03\x04\x0c\n\r\n\x05\x04/\x02\r\x05\x12\x04\xa3\x03\r\x13\n\r\n\
    \x05\x04/\x02\r\x01\x12\x04\xa3\x03\x14\"\n\r\n\x05\x04/\x02\r\x03\x12\
    \x04\xa3\x03%'\n\x0c\n\x02\x040\x12\x06\xa6\x03\0\xab\x03\x01\n\x0b\n\
    \x03\x040\x01\x12\x04\xa6\x03\x08\x18\n\x0c\n\x04\x040\x02\0\x12\x04\xa7\
    \x03\x04+\n\r\n\x05\x040\x02\0\x04\x12\x04\xa7\x03\x04\x0c\n\r\n\x05\x04\
    0\x02\0\x06\x12\x04\xa7\x03\r\x1d\n\r\n\x05\x040\x02\0\x01\x12\x04\xa7\
    \x03\x1e&\n\r\n\x05\x040\x02\0\x03\x12\x04\xa7\x03)*\n.\n\x04\x040\x02\
    \x01\x12\x04\xa8\x03\x04\x1c\"\x20\x20encoded\x20as\x20InplaceRowChangeS\
    et\n\n\r\n\x05\x040\x02\x01\x04\x12\x04\xa8\x03\x04\x0c\n\r\n\x05\x040\
    \x02\x01\x05\x12\x04\xa8\x03\r\x12\n\r\n\x05\x040\x02\x01\x01\x12\x04\
    \xa8\x03\x13\x17\n\r\n\x05\x040\x02\x01\x03\x12\x04\xa8\x03\x1a\x1b\nw\n\
    \x04\x040\x02\x02\x12\x04\xa9\x03\x04.\"i\x20\xe8\x8b\xa5\xe4\xb8\xba\
    \xe7\xa9\xba\xef\xbc\x8c\xe5\x88\x99\xe4\xbb\xa3\xe8\xa1\xa8\xe6\x95\xb0\
    \xe6\x8d\xae\xe5\x85\xa8\xe9\x83\xa8\xe8\xaf\xbb\xe5\x8f\x96\xe5\xae\x8c\
    \xe6\xaf\x95.\x20encoded\x20as\x20InplaceRowChangeSet,\x20but\x20only\
    \x20has\x20primary\x20key\n\n\r\n\x05\x040\x02\x02\x04\x12\x04\xa9\x03\
    \x04\x0c\n\r\n\x05\x040\x02\x02\x05\x12\x04\xa9\x03\r\x12\n\r\n\x05\x040\
    \x02\x02\x01\x12\x04\xa9\x03\x13)\n\r\n\x05\x040\x02\x02\x03\x12\x04\xa9\
    \x03,-\n\x0c\n\x04\x040\x02\x03\x12\x04\xaa\x03\x04\"\n\r\n\x05\x040\x02\
    \x03\x04\x12\x04\xaa\x03\x04\x0c\n\r\n\x05\x040\x02\x03\x05\x12\x04\xaa\
    \x03\r\x12\n\r\n\x05\x040\x02\x03\x01\x12\x04\xaa\x03\x13\x1d\n\r\n\x05\
    \x040\x02\x03\x03\x12\x04\xaa\x03\x20!\nt\n\x02\x041\x12\x06\xaf\x03\0\
    \xb1\x03\x012f\x20#############################################\x20\x20S\
    tream\x20\x20#############################################\x20\n\x0b\n\
    \x03\x041\x01\x12\x04\xaf\x03\x08\x19\n\x0c\n\x04\x041\x02\0\x12\x04\xb0\
    \x03\x04#\n\r\n\x05\x041\x02\0\x04\x12\x04\xb0\x03\x04\x0c\n\r\n\x05\x04\
    1\x02\0\x05\x12\x04\xb0\x03\r\x13\n\r\n\x05\x041\x02\0\x01\x12\x04\xb0\
    \x03\x14\x1e\n\r\n\x05\x041\x02\0\x03\x12\x04\xb0\x03!\"\n\x0c\n\x02\x04\
    2\x12\x06\xb3\x03\0\xb7\x03\x01\n\x0b\n\x03\x042\x01\x12\x04\xb3\x03\x08\
    \x0e\n\x0c\n\x04\x042\x02\0\x12\x04\xb4\x03\x04\"\n\r\n\x05\x042\x02\0\
    \x04\x12\x04\xb4\x03\x04\x0c\n\r\n\x05\x042\x02\0\x05\x12\x04\xb4\x03\r\
    \x13\n\r\n\x05\x042\x02\0\x01\x12\x04\xb4\x03\x14\x1d\n\r\n\x05\x042\x02\
    \0\x03\x12\x04\xb4\x03\x20!\n\x0c\n\x04\x042\x02\x01\x12\x04\xb5\x03\x04\
    #\n\r\n\x05\x042\x02\x01\x04\x12\x04\xb5\x03\x04\x0c\n\r\n\x05\x042\x02\
    \x01\x05\x12\x04\xb5\x03\r\x13\n\r\n\x05\x042\x02\x01\x01\x12\x04\xb5\
    \x03\x14\x1e\n\r\n\x05\x042\x02\x01\x03\x12\x04\xb5\x03!\"\n\x0c\n\x04\
    \x042\x02\x02\x12\x04\xb6\x03\x04%\n\r\n\x05\x042\x02\x02\x04\x12\x04\
    \xb6\x03\x04\x0c\n\r\n\x05\x042\x02\x02\x05\x12\x04\xb6\x03\r\x12\n\r\n\
    \x05\x042\x02\x02\x01\x12\x04\xb6\x03\x13\x20\n\r\n\x05\x042\x02\x02\x03\
    \x12\x04\xb6\x03#$\n\x0c\n\x02\x043\x12\x06\xb9\x03\0\xbb\x03\x01\n\x0b\
    \n\x03\x043\x01\x12\x04\xb9\x03\x08\x1a\n\x0c\n\x04\x043\x02\0\x12\x04\
    \xba\x03\x04\x20\n\r\n\x05\x043\x02\0\x04\x12\x04\xba\x03\x04\x0c\n\r\n\
    \x05\x043\x02\0\x06\x12\x04\xba\x03\r\x13\n\r\n\x05\x043\x02\0\x01\x12\
    \x04\xba\x03\x14\x1b\n\r\n\x05\x043\x02\0\x03\x12\x04\xba\x03\x1e\x1f\n\
    \x0c\n\x02\x044\x12\x06\xbd\x03\0\xc1\x03\x01\n\x0b\n\x03\x044\x01\x12\
    \x04\xbd\x03\x08\x13\n\x0c\n\x04\x044\x02\0\x12\x04\xbe\x03\x04!\n\r\n\
    \x05\x044\x02\0\x04\x12\x04\xbe\x03\x04\x0c\n\r\n\x05\x044\x02\0\x05\x12\
    \x04\xbe\x03\r\x13\n\r\n\x05\x044\x02\0\x01\x12\x04\xbe\x03\x14\x1c\n\r\
    \n\x05\x044\x02\0\x03\x12\x04\xbe\x03\x1f\x20\n\x0c\n\x04\x044\x02\x01\
    \x12\x04\xbf\x03\x04\"\n\r\n\x05\x044\x02\x01\x04\x12\x04\xbf\x03\x04\
    \x0c\n\r\n\x05\x044\x02\x01\x05\x12\x04\xbf\x03\r\x13\n\r\n\x05\x044\x02\
    \x01\x01\x12\x04\xbf\x03\x14\x1d\n\r\n\x05\x044\x02\x01\x03\x12\x04\xbf\
    \x03\x20!\n\x0c\n\x04\x044\x02\x02\x12\x04\xc0\x03\x04*\n\r\n\x05\x044\
    \x02\x02\x04\x12\x04\xc0\x03\x04\x0c\n\r\n\x05\x044\x02\x02\x05\x12\x04\
    \xc0\x03\r\x13\n\r\n\x05\x044\x02\x02\x01\x12\x04\xc0\x03\x14%\n\r\n\x05\
    \x044\x02\x02\x03\x12\x04\xc0\x03()\n\x0c\n\x02\x05\x08\x12\x06\xc3\x03\
    \0\xc6\x03\x01\n\x0b\n\x03\x05\x08\x01\x12\x04\xc3\x03\x05\x11\n\x0c\n\
    \x04\x05\x08\x02\0\x12\x04\xc4\x03\x04\x18\n\r\n\x05\x05\x08\x02\0\x01\
    \x12\x04\xc4\x03\x04\x13\n\r\n\x05\x05\x08\x02\0\x02\x12\x04\xc4\x03\x16\
    \x17\n\x0c\n\x04\x05\x08\x02\x01\x12\x04\xc5\x03\x04\x16\n\r\n\x05\x05\
    \x08\x02\x01\x01\x12\x04\xc5\x03\x04\x11\n\r\n\x05\x05\x08\x02\x01\x02\
    \x12\x04\xc5\x03\x14\x15\n\x0c\n\x02\x045\x12\x06\xc8\x03\0\xcc\x03\x01\
    \n\x0b\n\x03\x045\x01\x12\x04\xc8\x03\x08\x1d\n\x0c\n\x04\x045\x02\0\x12\
    \x04\xc9\x03\x04\"\n\r\n\x05\x045\x02\0\x04\x12\x04\xc9\x03\x04\x0c\n\r\
    \n\x05\x045\x02\0\x05\x12\x04\xc9\x03\r\x13\n\r\n\x05\x045\x02\0\x01\x12\
    \x04\xc9\x03\x14\x1d\n\r\n\x05\x045\x02\0\x03\x12\x04\xc9\x03\x20!\n\x0c\
    \n\x04\x045\x02\x01\x12\x04\xca\x03\x041\n\r\n\x05\x045\x02\x01\x04\x12\
    \x04\xca\x03\x04\x0c\n\r\n\x05\x045\x02\x01\x05\x12\x04\xca\x03\r\x13\n\
    \r\n\x05\x045\x02\x01\x01\x12\x04\xca\x03\x14,\n\r\n\x05\x045\x02\x01\
    \x03\x12\x04\xca\x03/0\n\x0c\n\x04\x045\x02\x02\x12\x04\xcb\x03\x04#\n\r\
    \n\x05\x045\x02\x02\x04\x12\x04\xcb\x03\x04\x0c\n\r\n\x05\x045\x02\x02\
    \x05\x12\x04\xcb\x03\r\x12\n\r\n\x05\x045\x02\x02\x01\x12\x04\xcb\x03\
    \x13\x1e\n\r\n\x05\x045\x02\x02\x03\x12\x04\xcb\x03!\"\n\x0c\n\x02\x046\
    \x12\x06\xce\x03\0\xd6\x03\x01\n\x0b\n\x03\x046\x01\x12\x04\xce\x03\x08\
    \x1e\n\x0c\n\x04\x046\x02\0\x12\x04\xcf\x03\x04\"\n\r\n\x05\x046\x02\0\
    \x04\x12\x04\xcf\x03\x04\x0c\n\r\n\x05\x046\x02\0\x05\x12\x04\xcf\x03\r\
    \x13\n\r\n\x05\x046\x02\0\x01\x12\x04\xcf\x03\x14\x1d\n\r\n\x05\x046\x02\
    \0\x03\x12\x04\xcf\x03\x20!\n\x0c\n\x04\x046\x02\x01\x12\x04\xd0\x03\x04\
    '\n\r\n\x05\x046\x02\x01\x04\x12\x04\xd0\x03\x04\x0c\n\r\n\x05\x046\x02\
    \x01\x05\x12\x04\xd0\x03\r\x12\n\r\n\x05\x046\x02\x01\x01\x12\x04\xd0\
    \x03\x13\"\n\r\n\x05\x046\x02\x01\x03\x12\x04\xd0\x03%&\n\x0c\n\x04\x046\
    \x02\x02\x12\x04\xd1\x03\x04#\n\r\n\x05\x046\x02\x02\x04\x12\x04\xd1\x03\
    \x04\x0c\n\r\n\x05\x046\x02\x02\x05\x12\x04\xd1\x03\r\x13\n\r\n\x05\x046\
    \x02\x02\x01\x12\x04\xd1\x03\x14\x1e\n\r\n\x05\x046\x02\x02\x03\x12\x04\
    \xd1\x03!\"\n\x0c\n\x04\x046\x02\x03\x12\x04\xd2\x03\x04%\n\r\n\x05\x046\
    \x02\x03\x04\x12\x04\xd2\x03\x04\x0c\n\r\n\x05\x046\x02\x03\x05\x12\x04\
    \xd2\x03\r\x12\n\r\n\x05\x046\x02\x03\x01\x12\x04\xd2\x03\x13\x20\n\r\n\
    \x05\x046\x02\x03\x03\x12\x04\xd2\x03#$\n\x0c\n\x04\x046\x02\x04\x12\x04\
    \xd3\x03\x04,\n\r\n\x05\x046\x02\x04\x04\x12\x04\xd3\x03\x04\x0c\n\r\n\
    \x05\x046\x02\x04\x06\x12\x04\xd3\x03\r\x19\n\r\n\x05\x046\x02\x04\x01\
    \x12\x04\xd3\x03\x1a'\n\r\n\x05\x046\x02\x04\x03\x12\x04\xd3\x03*+\n\x0c\
    \n\x04\x046\x02\x05\x12\x04\xd4\x03\x04$\n\r\n\x05\x046\x02\x05\x04\x12\
    \x04\xd4\x03\x04\x0c\n\r\n\x05\x046\x02\x05\x06\x12\x04\xd4\x03\r\x18\n\
    \r\n\x05\x046\x02\x05\x01\x12\x04\xd4\x03\x19\x1f\n\r\n\x05\x046\x02\x05\
    \x03\x12\x04\xd4\x03\"#\n\x0c\n\x04\x046\x02\x06\x12\x04\xd5\x03\x04&\n\
    \r\n\x05\x046\x02\x06\x04\x12\x04\xd5\x03\x04\x0c\n\r\n\x05\x046\x02\x06\
    \x05\x12\x04\xd5\x03\r\x13\n\r\n\x05\x046\x02\x06\x01\x12\x04\xd5\x03\
    \x14!\n\r\n\x05\x046\x02\x06\x03\x12\x04\xd5\x03$%\n\x0c\n\x02\x047\x12\
    \x06\xd8\x03\0\xdd\x03\x01\n\x0b\n\x03\x047\x01\x12\x04\xd8\x03\x08\x1f\
    \n\x0c\n\x04\x047\x02\0\x12\x04\xd9\x03\x04\"\n\r\n\x05\x047\x02\0\x04\
    \x12\x04\xd9\x03\x04\x0c\n\r\n\x05\x047\x02\0\x05\x12\x04\xd9\x03\r\x13\
    \n\r\n\x05\x047\x02\0\x01\x12\x04\xd9\x03\x14\x1d\n\r\n\x05\x047\x02\0\
    \x03\x12\x04\xd9\x03\x20!\n\x0c\n\x04\x047\x02\x01\x12\x04\xda\x03\x04!\
    \n\r\n\x05\x047\x02\x01\x04\x12\x04\xda\x03\x04\x0c\n\r\n\x05\x047\x02\
    \x01\x05\x12\x04\xda\x03\r\x13\n\r\n\x05\x047\x02\x01\x01\x12\x04\xda\
    \x03\x14\x1c\n\r\n\x05\x047\x02\x01\x03\x12\x04\xda\x03\x1f\x20\n\x0c\n\
    \x04\x047\x02\x02\x12\x04\xdb\x03\x04!\n\r\n\x05\x047\x02\x02\x04\x12\
    \x04\xdb\x03\x04\x0c\n\r\n\x05\x047\x02\x02\x05\x12\x04\xdb\x03\r\x12\n\
    \r\n\x05\x047\x02\x02\x01\x12\x04\xdb\x03\x13\x1c\n\r\n\x05\x047\x02\x02\
    \x03\x12\x04\xdb\x03\x1f\x20\n\x0c\n\x04\x047\x02\x03\x12\x04\xdc\x03\
    \x04\x1e\n\r\n\x05\x047\x02\x03\x04\x12\x04\xdc\x03\x04\x0c\n\r\n\x05\
    \x047\x02\x03\x05\x12\x04\xdc\x03\r\x13\n\r\n\x05\x047\x02\x03\x01\x12\
    \x04\xdc\x03\x14\x19\n\r\n\x05\x047\x02\x03\x03\x12\x04\xdc\x03\x1c\x1d\
    \n\x0c\n\x02\x048\x12\x06\xdf\x03\0\xe2\x03\x01\n\x0b\n\x03\x048\x01\x12\
    \x04\xdf\x03\x08\x20\n\x0c\n\x04\x048\x02\0\x12\x04\xe0\x03\x04'\n\r\n\
    \x05\x048\x02\0\x04\x12\x04\xe0\x03\x04\x0c\n\r\n\x05\x048\x02\0\x05\x12\
    \x04\xe0\x03\r\x13\n\r\n\x05\x048\x02\0\x01\x12\x04\xe0\x03\x14\"\n\r\n\
    \x05\x048\x02\0\x03\x12\x04\xe0\x03%&\n\x0c\n\x04\x048\x02\x01\x12\x04\
    \xe1\x03\x04#\n\r\n\x05\x048\x02\x01\x04\x12\x04\xe1\x03\x04\x0c\n\r\n\
    \x05\x048\x02\x01\x05\x12\x04\xe1\x03\r\x13\n\r\n\x05\x048\x02\x01\x01\
    \x12\x04\xe1\x03\x14\x1e\n\r\n\x05\x048\x02\x01\x03\x12\x04\xe1\x03!\"\n\
    \x0c\n\x02\x049\x12\x06\xe4\x03\0\xe7\x03\x01\n\x0b\n\x03\x049\x01\x12\
    \x04\xe4\x03\x08\x1e\n\x0c\n\x04\x049\x02\0\x12\x04\xe5\x03\x04'\n\r\n\
    \x05\x049\x02\0\x04\x12\x04\xe5\x03\x04\x0c\n\r\n\x05\x049\x02\0\x05\x12\
    \x04\xe5\x03\r\x13\n\r\n\x05\x049\x02\0\x01\x12\x04\xe5\x03\x14\"\n\r\n\
    \x05\x049\x02\0\x03\x12\x04\xe5\x03%&\n\x0c\n\x04\x049\x02\x01\x12\x04\
    \xe6\x03\x04\x1d\n\r\n\x05\x049\x02\x01\x04\x12\x04\xe6\x03\x04\x0c\n\r\
    \n\x05\x049\x02\x01\x05\x12\x04\xe6\x03\r\x12\n\r\n\x05\x049\x02\x01\x01\
    \x12\x04\xe6\x03\x13\x18\n\r\n\x05\x049\x02\x01\x03\x12\x04\xe6\x03\x1b\
    \x1c\n\x0c\n\x02\x05\t\x12\x06\xe9\x03\0\xed\x03\x01\n\x0b\n\x03\x05\t\
    \x01\x12\x04\xe9\x03\x05\x0f\n\x0c\n\x04\x05\t\x02\0\x12\x04\xea\x03\x04\
    \x10\n\r\n\x05\x05\t\x02\0\x01\x12\x04\xea\x03\x04\x0b\n\r\n\x05\x05\t\
    \x02\0\x02\x12\x04\xea\x03\x0e\x0f\n\x0c\n\x04\x05\t\x02\x01\x12\x04\xeb\
    \x03\x04\x13\n\r\n\x05\x05\t\x02\x01\x01\x12\x04\xeb\x03\x04\x0e\n\r\n\
    \x05\x05\t\x02\x01\x02\x12\x04\xeb\x03\x11\x12\n\x0c\n\x04\x05\t\x02\x02\
    \x12\x04\xec\x03\x04\x13\n\r\n\x05\x05\t\x02\x02\x01\x12\x04\xec\x03\x04\
    \x0e\n\r\n\x05\x05\t\x02\x02\x02\x12\x04\xec\x03\x11\x12\n\x0c\n\x02\x04\
    :\x12\x06\xef\x03\0\xf6\x03\x01\n\x0b\n\x03\x04:\x01\x12\x04\xef\x03\x08\
    \x1f\n\x0e\n\x04\x04:\x03\0\x12\x06\xf0\x03\x04\xf3\x03\x05\n\r\n\x05\
    \x04:\x03\0\x01\x12\x04\xf0\x03\x0c\x18\n\x0e\n\x06\x04:\x03\0\x02\0\x12\
    \x04\xf1\x03\x08,\n\x0f\n\x07\x04:\x03\0\x02\0\x04\x12\x04\xf1\x03\x08\
    \x10\n\x0f\n\x07\x04:\x03\0\x02\0\x06\x12\x04\xf1\x03\x11\x1b\n\x0f\n\
    \x07\x04:\x03\0\x02\0\x01\x12\x04\xf1\x03\x1c'\n\x0f\n\x07\x04:\x03\0\
    \x02\0\x03\x12\x04\xf1\x03*+\n\x0e\n\x06\x04:\x03\0\x02\x01\x12\x04\xf2\
    \x03\x08\"\n\x0f\n\x07\x04:\x03\0\x02\x01\x04\x12\x04\xf2\x03\x08\x10\n\
    \x0f\n\x07\x04:\x03\0\x02\x01\x05\x12\x04\xf2\x03\x11\x16\n\x0f\n\x07\
    \x04:\x03\0\x02\x01\x01\x12\x04\xf2\x03\x17\x1d\n\x0f\n\x07\x04:\x03\0\
    \x02\x01\x03\x12\x04\xf2\x03\x20!\n\x0c\n\x04\x04:\x02\0\x12\x04\xf4\x03\
    \x04-\n\r\n\x05\x04:\x02\0\x04\x12\x04\xf4\x03\x04\x0c\n\r\n\x05\x04:\
    \x02\0\x06\x12\x04\xf4\x03\r\x19\n\r\n\x05\x04:\x02\0\x01\x12\x04\xf4\
    \x03\x1a(\n\r\n\x05\x04:\x02\0\x03\x12\x04\xf4\x03+,\n\x0c\n\x04\x04:\
    \x02\x01\x12\x04\xf5\x03\x04,\n\r\n\x05\x04:\x02\x01\x04\x12\x04\xf5\x03\
    \x04\x0c\n\r\n\x05\x04:\x02\x01\x05\x12\x04\xf5\x03\r\x13\n\r\n\x05\x04:\
    \x02\x01\x01\x12\x04\xf5\x03\x14'\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xf5\
    \x03*+\n5\n\x02\x04;\x12\x06\xf9\x03\0\xfc\x03\x01\x1a'\x20+++++\x20Comp\
    uteSplitPointsBySize\x20\x20+++++\x20\n\x0b\n\x03\x04;\x01\x12\x04\xf9\
    \x03\x08'\n\x0c\n\x04\x04;\x02\0\x12\x04\xfa\x03\x04#\n\r\n\x05\x04;\x02\
    \0\x04\x12\x04\xfa\x03\x04\x0c\n\r\n\x05\x04;\x02\0\x05\x12\x04\xfa\x03\
    \r\x13\n\r\n\x05\x04;\x02\0\x01\x12\x04\xfa\x03\x14\x1e\n\r\n\x05\x04;\
    \x02\0\x03\x12\x04\xfa\x03!\"\n\x18\n\x04\x04;\x02\x01\x12\x04\xfb\x03\
    \x04\"\"\n\x20in\x20100MB\n\n\r\n\x05\x04;\x02\x01\x04\x12\x04\xfb\x03\
    \x04\x0c\n\r\n\x05\x04;\x02\x01\x05\x12\x04\xfb\x03\r\x12\n\r\n\x05\x04;\
    \x02\x01\x01\x12\x04\xfb\x03\x13\x1d\n\r\n\x05\x04;\x02\x01\x03\x12\x04\
    \xfb\x03\x20!\n\x0c\n\x02\x04<\x12\x06\xfe\x03\0\x9a\x04\x01\n\x0b\n\x03\
    \x04<\x01\x12\x04\xfe\x03\x08(\n\x0c\n\x04\x04<\x02\0\x12\x04\xff\x03\
    \x04+\n\r\n\x05\x04<\x02\0\x04\x12\x04\xff\x03\x04\x0c\n\r\n\x05\x04<\
    \x02\0\x06\x12\x04\xff\x03\r\x1d\n\r\n\x05\x04<\x02\0\x01\x12\x04\xff\
    \x03\x1e&\n\r\n\x05\x04<\x02\0\x03\x12\x04\xff\x03)*\n\x0c\n\x04\x04<\
    \x02\x01\x12\x04\x80\x04\x04)\n\r\n\x05\x04<\x02\x01\x04\x12\x04\x80\x04\
    \x04\x0c\n\r\n\x05\x04<\x02\x01\x06\x12\x04\x80\x04\r\x1d\n\r\n\x05\x04<\
    \x02\x01\x01\x12\x04\x80\x04\x1e$\n\r\n\x05\x04<\x02\x01\x03\x12\x04\x80\
    \x04'(\n\x98\x03\n\x04\x04<\x02\x02\x12\x04\x8d\x04\x04$\x1a\x89\x03*\n\
    \x20Split\x20points\x20between\x20splits,\x20in\x20the\x20increasing\x20\
    order\n\n\x20A\x20split\x20is\x20a\x20consecutive\x20range\x20of\x20prim\
    ary\x20keys,\n\x20whose\x20data\x20size\x20is\x20about\x20split_size\x20\
    specified\x20in\x20the\x20request.\n\x20The\x20size\x20could\x20be\x20ha\
    rd\x20to\x20be\x20precise.\n\x20\n\x20A\x20split\x20point\x20is\x20an\
    \x20array\x20of\x20primary-key\x20column\x20w.r.t.\x20table\x20schema,\n\
    \x20which\x20is\x20never\x20longer\x20than\x20that\x20of\x20table\x20sch\
    ema.\n\x20Tailing\x20-inf\x20will\x20be\x20omitted\x20to\x20reduce\x20tr\
    ansmission\x20payloads.\n\n\r\n\x05\x04<\x02\x02\x04\x12\x04\x8d\x04\x04\
    \x0c\n\r\n\x05\x04<\x02\x02\x05\x12\x04\x8d\x04\r\x12\n\r\n\x05\x04<\x02\
    \x02\x01\x12\x04\x8d\x04\x13\x1f\n\r\n\x05\x04<\x02\x02\x03\x12\x04\x8d\
    \x04\"#\n\xce\x01\n\x04\x04<\x03\0\x12\x06\x95\x04\x05\x98\x04\x06\x1a\
    \xbd\x01*\n\x20Locations\x20where\x20splits\x20lies\x20in.\n\n\x20By\x20\
    the\x20managed\x20nature\x20of\x20TableStore,\x20these\x20locations\x20a\
    re\x20no\x20more\x20than\x20hints.\n\x20If\x20a\x20location\x20is\x20not\
    \x20suitable\x20to\x20be\x20seen,\x20an\x20empty\x20string\x20will\x20be\
    \x20placed.\n\n\r\n\x05\x04<\x03\0\x01\x12\x04\x95\x04\r\x1a\n\x0e\n\x06\
    \x04<\x03\0\x02\0\x12\x04\x96\x04\t&\n\x0f\n\x07\x04<\x03\0\x02\0\x04\
    \x12\x04\x96\x04\t\x11\n\x0f\n\x07\x04<\x03\0\x02\0\x05\x12\x04\x96\x04\
    \x12\x18\n\x0f\n\x07\x04<\x03\0\x02\0\x01\x12\x04\x96\x04\x19!\n\x0f\n\
    \x07\x04<\x03\0\x02\0\x03\x12\x04\x96\x04$%\n\x0e\n\x06\x04<\x03\0\x02\
    \x01\x12\x04\x97\x04\t$\n\x0f\n\x07\x04<\x03\0\x02\x01\x04\x12\x04\x97\
    \x04\t\x11\n\x0f\n\x07\x04<\x03\0\x02\x01\x05\x12\x04\x97\x04\x12\x18\n\
    \x0f\n\x07\x04<\x03\0\x02\x01\x01\x12\x04\x97\x04\x19\x1f\n\x0f\n\x07\
    \x04<\x03\0\x02\x01\x03\x12\x04\x97\x04\"#\n\x0c\n\x04\x04<\x02\x03\x12\
    \x04\x99\x04\x05*\n\r\n\x05\x04<\x02\x03\x04\x12\x04\x99\x04\x05\r\n\r\n\
    \x05\x04<\x02\x03\x06\x12\x04\x99\x04\x0e\x1b\n\r\n\x05\x04<\x02\x03\x01\
    \x12\x04\x99\x04\x1c%\n\r\n\x05\x04<\x02\x03\x03\x12\x04\x99\x04()\n\x0c\
    \n\x02\x05\n\x12\x06\x9d\x04\0\xa5\x04\x01\n\x0b\n\x03\x05\n\x01\x12\x04\
    \x9d\x04\x05\x16\n\x0c\n\x04\x05\n\x02\0\x12\x04\x9e\x04\x04\x14\n\r\n\
    \x05\x05\n\x02\0\x01\x12\x04\x9e\x04\x04\x0f\n\r\n\x05\x05\n\x02\0\x02\
    \x12\x04\x9e\x04\x12\x13\n\x0c\n\x04\x05\n\x02\x01\x12\x04\x9f\x04\x04\
    \x13\n\r\n\x05\x05\n\x02\x01\x01\x12\x04\x9f\x04\x04\x0e\n\r\n\x05\x05\n\
    \x02\x01\x02\x12\x04\x9f\x04\x11\x12\n\x0c\n\x04\x05\n\x02\x02\x12\x04\
    \xa0\x04\x04\x14\n\r\n\x05\x05\n\x02\x02\x01\x12\x04\xa0\x04\x04\x0f\n\r\
    \n\x05\x05\n\x02\x02\x02\x12\x04\xa0\x04\x12\x13\n\x0c\n\x04\x05\n\x02\
    \x03\x12\x04\xa1\x04\x04\x13\n\r\n\x05\x05\n\x02\x03\x01\x12\x04\xa1\x04\
    \x04\x0e\n\r\n\x05\x05\n\x02\x03\x02\x12\x04\xa1\x04\x11\x12\n}\n\x04\
    \x05\n\x02\x04\x12\x04\xa4\x04\x04\x11\x1ao\x20field\x205\x20is\x20reser\
    ved\x20for\x20date\x20type,\x20not\x20supported\x20yet\n\x20field\x206\
    \x20is\x20reserved\x20for\x20decimal\x20type,\x20not\x20supported\x20yet\
    \n\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\xa4\x04\x04\x0c\n\r\n\x05\x05\n\
    \x02\x04\x02\x12\x04\xa4\x04\x0f\x10\n\x0c\n\x02\x04=\x12\x06\xa7\x04\0\
    \xaa\x04\x01\n\x0b\n\x03\x04=\x01\x12\x04\xa7\x04\x08\x1b\n\x0c\n\x04\
    \x04=\x02\0\x12\x04\xa8\x04\x04\x1d\n\r\n\x05\x04=\x02\0\x04\x12\x04\xa8\
    \x04\x04\x0c\n\r\n\x05\x04=\x02\0\x05\x12\x04\xa8\x04\r\x13\n\r\n\x05\
    \x04=\x02\0\x01\x12\x04\xa8\x04\x14\x18\n\r\n\x05\x04=\x02\0\x03\x12\x04\
    \xa8\x04\x1b\x1c\n\x0c\n\x04\x04=\x02\x01\x12\x04\xa9\x04\x04(\n\r\n\x05\
    \x04=\x02\x01\x04\x12\x04\xa9\x04\x04\x0c\n\r\n\x05\x04=\x02\x01\x06\x12\
    \x04\xa9\x04\r\x1e\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xa9\x04\x1f#\n\r\n\
    \x05\x04=\x02\x01\x03\x12\x04\xa9\x04&'\n\x0c\n\x02\x05\x0b\x12\x06\xac\
    \x04\0\xaf\x04\x01\n\x0b\n\x03\x05\x0b\x01\x12\x04\xac\x04\x05\x14\n\x0c\
    \n\x04\x05\x0b\x02\0\x12\x04\xad\x04\x04\x18\n\r\n\x05\x05\x0b\x02\0\x01\
    \x12\x04\xad\x04\x04\x13\n\r\n\x05\x05\x0b\x02\0\x02\x12\x04\xad\x04\x16\
    \x17\n\x0c\n\x04\x05\x0b\x02\x01\x12\x04\xae\x04\x04\x17\n\r\n\x05\x05\
    \x0b\x02\x01\x01\x12\x04\xae\x04\x04\x12\n\r\n\x05\x05\x0b\x02\x01\x02\
    \x12\x04\xae\x04\x15\x16\n\x0c\n\x02\x05\x0c\x12\x06\xb1\x04\0\xb4\x04\
    \x01\n\x0b\n\x03\x05\x0c\x01\x12\x04\xb1\x04\x05\x0e\n\x0c\n\x04\x05\x0c\
    \x02\0\x12\x04\xb2\x04\x04\x18\n\r\n\x05\x05\x0c\x02\0\x01\x12\x04\xb2\
    \x04\x04\x13\n\r\n\x05\x05\x0c\x02\0\x02\x12\x04\xb2\x04\x16\x17\n\x0c\n\
    \x04\x05\x0c\x02\x01\x12\x04\xb3\x04\x04\x17\n\r\n\x05\x05\x0c\x02\x01\
    \x01\x12\x04\xb3\x04\x04\x12\n\r\n\x05\x05\x0c\x02\x01\x02\x12\x04\xb3\
    \x04\x15\x16\n\x0c\n\x02\x04>\x12\x06\xb6\x04\0\xbc\x04\x01\n\x0b\n\x03\
    \x04>\x01\x12\x04\xb6\x04\x08\x11\n\x0c\n\x04\x04>\x02\0\x12\x04\xb7\x04\
    \x04\x1d\n\r\n\x05\x04>\x02\0\x04\x12\x04\xb7\x04\x04\x0c\n\r\n\x05\x04>\
    \x02\0\x05\x12\x04\xb7\x04\r\x13\n\r\n\x05\x04>\x02\0\x01\x12\x04\xb7\
    \x04\x14\x18\n\r\n\x05\x04>\x02\0\x03\x12\x04\xb7\x04\x1b\x1c\n\x0c\n\
    \x04\x04>\x02\x01\x12\x04\xb8\x04\x04$\n\r\n\x05\x04>\x02\x01\x04\x12\
    \x04\xb8\x04\x04\x0c\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xb8\x04\r\x13\n\
    \r\n\x05\x04>\x02\x01\x01\x12\x04\xb8\x04\x14\x1f\n\r\n\x05\x04>\x02\x01\
    \x03\x12\x04\xb8\x04\"#\n\x0c\n\x04\x04>\x02\x02\x12\x04\xb9\x04\x04'\n\
    \r\n\x05\x04>\x02\x02\x04\x12\x04\xb9\x04\x04\x0c\n\r\n\x05\x04>\x02\x02\
    \x05\x12\x04\xb9\x04\r\x13\n\r\n\x05\x04>\x02\x02\x01\x12\x04\xb9\x04\
    \x14\"\n\r\n\x05\x04>\x02\x02\x03\x12\x04\xb9\x04%&\n\x0c\n\x04\x04>\x02\
    \x03\x12\x04\xba\x04\x043\n\r\n\x05\x04>\x02\x03\x04\x12\x04\xba\x04\x04\
    \x0c\n\r\n\x05\x04>\x02\x03\x06\x12\x04\xba\x04\r\x1c\n\r\n\x05\x04>\x02\
    \x03\x01\x12\x04\xba\x04\x1d.\n\r\n\x05\x04>\x02\x03\x03\x12\x04\xba\x04\
    12\n\x0c\n\x04\x04>\x02\x04\x12\x04\xbb\x04\x04&\n\r\n\x05\x04>\x02\x04\
    \x04\x12\x04\xbb\x04\x04\x0c\n\r\n\x05\x04>\x02\x04\x06\x12\x04\xbb\x04\
    \r\x16\n\r\n\x05\x04>\x02\x04\x01\x12\x04\xbb\x04\x17!\n\r\n\x05\x04>\
    \x02\x04\x03\x12\x04\xbb\x04$%\n\x0c\n\x02\x04?\x12\x06\xbe\x04\0\xc2\
    \x04\x01\n\x0b\n\x03\x04?\x01\x12\x04\xbe\x04\x08\x1a\n\x0c\n\x04\x04?\
    \x02\0\x12\x04\xbf\x04\x04(\n\r\n\x05\x04?\x02\0\x04\x12\x04\xbf\x04\x04\
    \x0c\n\r\n\x05\x04?\x02\0\x05\x12\x04\xbf\x04\r\x13\n\r\n\x05\x04?\x02\0\
    \x01\x12\x04\xbf\x04\x14#\n\r\n\x05\x04?\x02\0\x03\x12\x04\xbf\x04&'\n\
    \x0c\n\x04\x04?\x02\x01\x12\x04\xc0\x04\x04&\n\r\n\x05\x04?\x02\x01\x04\
    \x12\x04\xc0\x04\x04\x0c\n\r\n\x05\x04?\x02\x01\x06\x12\x04\xc0\x04\r\
    \x16\n\r\n\x05\x04?\x02\x01\x01\x12\x04\xc0\x04\x17!\n\r\n\x05\x04?\x02\
    \x01\x03\x12\x04\xc0\x04$%\n\x0c\n\x04\x04?\x02\x02\x12\x04\xc1\x04\x04(\
    \n\r\n\x05\x04?\x02\x02\x04\x12\x04\xc1\x04\x04\x0c\n\r\n\x05\x04?\x02\
    \x02\x05\x12\x04\xc1\x04\r\x11\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xc1\
    \x04\x12#\n\r\n\x05\x04?\x02\x02\x03\x12\x04\xc1\x04&'\n\x0c\n\x02\x04@\
    \x12\x06\xc4\x04\0\xc5\x04\x01\n\x0b\n\x03\x04@\x01\x12\x04\xc4\x04\x08\
    \x1b\n\x0c\n\x02\x04A\x12\x06\xc7\x04\0\xca\x04\x01\n\x0b\n\x03\x04A\x01\
    \x12\x04\xc7\x04\x08\x18\n\x0c\n\x04\x04A\x02\0\x12\x04\xc8\x04\x04(\n\r\
    \n\x05\x04A\x02\0\x04\x12\x04\xc8\x04\x04\x0c\n\r\n\x05\x04A\x02\0\x05\
    \x12\x04\xc8\x04\r\x13\n\r\n\x05\x04A\x02\0\x01\x12\x04\xc8\x04\x14#\n\r\
    \n\x05\x04A\x02\0\x03\x12\x04\xc8\x04&'\n\x0c\n\x04\x04A\x02\x01\x12\x04\
    \xc9\x04\x04#\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xc9\x04\x04\x0c\n\r\n\
    \x05\x04A\x02\x01\x05\x12\x04\xc9\x04\r\x13\n\r\n\x05\x04A\x02\x01\x01\
    \x12\x04\xc9\x04\x14\x1e\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xc9\x04!\"\n\
    \x0c\n\x02\x04B\x12\x06\xcc\x04\0\xcd\x04\x01\n\x0b\n\x03\x04B\x01\x12\
    \x04\xcc\x04\x08\x19\n\x0c\n\x02\x04C\x12\x06\xcf\x04\0\xd2\x04\x01\n\
    \x0b\n\x03\x04C\x01\x12\x04\xcf\x04\x08\x1f\n\x0c\n\x04\x04C\x02\0\x12\
    \x04\xd0\x04\x04#\n\r\n\x05\x04C\x02\0\x04\x12\x04\xd0\x04\x04\x0c\n\r\n\
    \x05\x04C\x02\0\x05\x12\x04\xd0\x04\r\x13\n\r\n\x05\x04C\x02\0\x01\x12\
    \x04\xd0\x04\x14\x1e\n\r\n\x05\x04C\x02\0\x03\x12\x04\xd0\x04!\"\n\x0c\n\
    \x04\x04C\x02\x01\x12\x04\xd1\x04\x04-\n\r\n\x05\x04C\x02\x01\x04\x12\
    \x04\xd1\x04\x04\x0c\n\r\n\x05\x04C\x02\x01\x06\x12\x04\xd1\x04\r\x20\n\
    \r\n\x05\x04C\x02\x01\x01\x12\x04\xd1\x04!(\n\r\n\x05\x04C\x02\x01\x03\
    \x12\x04\xd1\x04+,\n\x0c\n\x02\x04D\x12\x06\xd4\x04\0\xd5\x04\x01\n\x0b\
    \n\x03\x04D\x01\x12\x04\xd4\x04\x08\x20\n\x0c\n\x02\x04E\x12\x06\xd7\x04\
    \0\xda\x04\x01\n\x0b\n\x03\x04E\x01\x12\x04\xd7\x04\x08\"\n\x0c\n\x04\
    \x04E\x02\0\x12\x04\xd8\x04\x04#\n\r\n\x05\x04E\x02\0\x04\x12\x04\xd8\
    \x04\x04\x0c\n\r\n\x05\x04E\x02\0\x05\x12\x04\xd8\x04\r\x13\n\r\n\x05\
    \x04E\x02\0\x01\x12\x04\xd8\x04\x14\x1e\n\r\n\x05\x04E\x02\0\x03\x12\x04\
    \xd8\x04!\"\n\x0c\n\x04\x04E\x02\x01\x12\x04\xd9\x04\x04\x20\n\r\n\x05\
    \x04E\x02\x01\x04\x12\x04\xd9\x04\x04\x0c\n\r\n\x05\x04E\x02\x01\x05\x12\
    \x04\xd9\x04\r\x13\n\r\n\x05\x04E\x02\x01\x01\x12\x04\xd9\x04\x14\x1b\n\
    \r\n\x05\x04E\x02\x01\x03\x12\x04\xd9\x04\x1e\x1f\n\x0c\n\x02\x04F\x12\
    \x06\xdc\x04\0\xdd\x04\x01\n\x0b\n\x03\x04F\x01\x12\x04\xdc\x04\x08#\nz\
    \n\x02\x04G\x12\x06\xe0\x04\0\xe3\x04\x01\x1al\x20######################\
    #####################\x20\x20LocalTransaction\x20\x20###################\
    ########################\x20\n\x0b\n\x03\x04G\x01\x12\x04\xe0\x04\x08$\n\
    \x0c\n\x04\x04G\x02\0\x12\x04\xe1\x04\x04#\n\r\n\x05\x04G\x02\0\x04\x12\
    \x04\xe1\x04\x04\x0c\n\r\n\x05\x04G\x02\0\x05\x12\x04\xe1\x04\r\x13\n\r\
    \n\x05\x04G\x02\0\x01\x12\x04\xe1\x04\x14\x1e\n\r\n\x05\x04G\x02\0\x03\
    \x12\x04\xe1\x04!\"\n%\n\x04\x04G\x02\x01\x12\x04\xe2\x04\x04\x1b\"\x17\
    \x20encoded\x20as\x20SQLVariant\n\n\r\n\x05\x04G\x02\x01\x04\x12\x04\xe2\
    \x04\x04\x0c\n\r\n\x05\x04G\x02\x01\x05\x12\x04\xe2\x04\r\x12\n\r\n\x05\
    \x04G\x02\x01\x01\x12\x04\xe2\x04\x13\x16\n\r\n\x05\x04G\x02\x01\x03\x12\
    \x04\xe2\x04\x19\x1a\n\x0c\n\x02\x04H\x12\x06\xe5\x04\0\xe7\x04\x01\n\
    \x0b\n\x03\x04H\x01\x12\x04\xe5\x04\x08%\n\x0c\n\x04\x04H\x02\0\x12\x04\
    \xe6\x04\x04'\n\r\n\x05\x04H\x02\0\x04\x12\x04\xe6\x04\x04\x0c\n\r\n\x05\
    \x04H\x02\0\x05\x12\x04\xe6\x04\r\x13\n\r\n\x05\x04H\x02\0\x01\x12\x04\
    \xe6\x04\x14\"\n\r\n\x05\x04H\x02\0\x03\x12\x04\xe6\x04%&\n\x0c\n\x02\
    \x04I\x12\x06\xe9\x04\0\xeb\x04\x01\n\x0b\n\x03\x04I\x01\x12\x04\xe9\x04\
    \x08\x20\n\x0c\n\x04\x04I\x02\0\x12\x04\xea\x04\x04'\n\r\n\x05\x04I\x02\
    \0\x04\x12\x04\xea\x04\x04\x0c\n\r\n\x05\x04I\x02\0\x05\x12\x04\xea\x04\
    \r\x13\n\r\n\x05\x04I\x02\0\x01\x12\x04\xea\x04\x14\"\n\r\n\x05\x04I\x02\
    \0\x03\x12\x04\xea\x04%&\n\x0c\n\x02\x04J\x12\x06\xed\x04\0\xee\x04\x01\
    \n\x0b\n\x03\x04J\x01\x12\x04\xed\x04\x08!\n\x0c\n\x02\x04K\x12\x06\xf0\
    \x04\0\xf2\x04\x01\n\x0b\n\x03\x04K\x01\x12\x04\xf0\x04\x08\x1f\n\x0c\n\
    \x04\x04K\x02\0\x12\x04\xf1\x04\x04'\n\r\n\x05\x04K\x02\0\x04\x12\x04\
    \xf1\x04\x04\x0c\n\r\n\x05\x04K\x02\0\x05\x12\x04\xf1\x04\r\x13\n\r\n\
    \x05\x04K\x02\0\x01\x12\x04\xf1\x04\x14\"\n\r\n\x05\x04K\x02\0\x03\x12\
    \x04\xf1\x04%&\n\x0c\n\x02\x04L\x12\x06\xf4\x04\0\xf5\x04\x01\n\x0b\n\
    \x03\x04L\x01\x12\x04\xf4\x04\x08\x20\n\x8a\x01\n\x02\x04M\x12\x06\xfa\
    \x04\0\xfd\x04\x01\x1a\x0f\x20computeSplits\x202k\x20###################\
    ########################################################################\
    ##############\x20\n\x0b\n\x03\x04M\x01\x12\x04\xfa\x04\x08\x1c\n\x0c\n\
    \x04\x04M\x02\0\x12\x04\xfb\x04\x04#\n\r\n\x05\x04M\x02\0\x04\x12\x04\
    \xfb\x04\x04\x0c\n\r\n\x05\x04M\x02\0\x05\x12\x04\xfb\x04\r\x13\n\r\n\
    \x05\x04M\x02\0\x01\x12\x04\xfb\x04\x14\x1e\n\r\n\x05\x04M\x02\0\x03\x12\
    \x04\xfb\x04!\"\n\x0c\n\x04\x04M\x02\x01\x12\x04\xfc\x04\x04F\n\r\n\x05\
    \x04M\x02\x01\x04\x12\x04\xfc\x04\x04\x0c\n\r\n\x05\x04M\x02\x01\x06\x12\
    \x04\xfc\x04\r%\n\r\n\x05\x04M\x02\x01\x01\x12\x04\xfc\x04&A\n\r\n\x05\
    \x04M\x02\x01\x03\x12\x04\xfc\x04DE\n\x0c\n\x02\x04N\x12\x06\xff\x04\0\
    \x81\x05\x01\n\x0b\n\x03\x04N\x01\x12\x04\xff\x04\x08\x20\n\x0c\n\x04\
    \x04N\x02\0\x12\x04\x80\x05\x04#\n\r\n\x05\x04N\x02\0\x04\x12\x04\x80\
    \x05\x04\x0c\n\r\n\x05\x04N\x02\0\x05\x12\x04\x80\x05\r\x13\n\r\n\x05\
    \x04N\x02\0\x01\x12\x04\x80\x05\x14\x1e\n\r\n\x05\x04N\x02\0\x03\x12\x04\
    \x80\x05!\"\n\x0c\n\x02\x04O\x12\x06\x83\x05\0\x86\x05\x01\n\x0b\n\x03\
    \x04O\x01\x12\x04\x83\x05\x08\x1d\n\x0c\n\x04\x04O\x02\0\x12\x04\x84\x05\
    \x04\"\n\r\n\x05\x04O\x02\0\x04\x12\x04\x84\x05\x04\x0c\n\r\n\x05\x04O\
    \x02\0\x05\x12\x04\x84\x05\r\x12\n\r\n\x05\x04O\x02\0\x01\x12\x04\x84\
    \x05\x13\x1d\n\r\n\x05\x04O\x02\0\x03\x12\x04\x84\x05\x20!\n\x0c\n\x04\
    \x04O\x02\x01\x12\x04\x85\x05\x04#\n\r\n\x05\x04O\x02\x01\x04\x12\x04\
    \x85\x05\x04\x0c\n\r\n\x05\x04O\x02\x01\x05\x12\x04\x85\x05\r\x12\n\r\n\
    \x05\x04O\x02\x01\x01\x12\x04\x85\x05\x13\x1e\n\r\n\x05\x04O\x02\x01\x03\
    \x12\x04\x85\x05!\"\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
